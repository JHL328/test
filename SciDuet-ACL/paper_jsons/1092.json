{"title": "Sparse and Constrained Attention for Neural Machine Translation", "abstract": "In NMT, words are sometimes dropped from the source or generated repeatedly in the translation. We explore novel strategies to address the coverage problem that change only the attention transformation. Our approach allocates fertilities to source words, used to bound the attention each word can receive. We experiment with various sparse and constrained attention transformations and propose a new one, constrained sparsemax, shown to be differentiable and sparse. Empirical evaluation is provided in three languages pairs.", "text": [{"id": 0, "string": "Introduction Neural machine translation (NMT) emerged in the last few years as a very successful paradigm (Sutskever et al., 2014; Bahdanau et al., 2014; Gehring et al., 2017; Vaswani et al., 2017) ."}, {"id": 1, "string": "While NMT is generally more fluent than previous statistical systems, adequacy is still a major concern (Koehn and Knowles, 2017) : common mistakes include dropping source words and repeating words in the generated translation."}, {"id": 2, "string": "Previous work has attempted to mitigate this problem in various ways."}, {"id": 3, "string": "Wu et al."}, {"id": 4, "string": "(2016) incorporate coverage and length penalties during beam search-a simple yet limited solution, since it only affects the scores of translation hypotheses that are already in the beam."}, {"id": 5, "string": "Other approaches involve architectural changes: providing coverage vectors to track the attention history (Mi et al., 2016; Tu et al., 2016) , using gating architectures and adaptive attention to control the amount of source context provided (Tu et al., 2017a; Li and Zhu, 2017) , or adding a reconstruction loss (Tu et al., 2017b) ."}, {"id": 6, "string": "Feng et al."}, {"id": 7, "string": "(2016) also use the notion of fertility * Work done during an internship at Unbabel."}, {"id": 8, "string": "implicitly in their proposed model."}, {"id": 9, "string": "Their fertility conditioned decoder uses a coverage vector and an extract gate which are incorporated in the decoding recurrent unit, increasing the number of parameters."}, {"id": 10, "string": "In this paper, we propose a different solution that does not change the overall architecture, but only the attention transformation."}, {"id": 11, "string": "Namely, we replace the traditional softmax by other recently proposed transformations that either promote attention sparsity (Martins and Astudillo, 2016) or upper bound the amount of attention a word can receive (Martins and Kreutzer, 2017) ."}, {"id": 12, "string": "The bounds are determined by the fertility values of the source words."}, {"id": 13, "string": "While these transformations have given encouraging results in various NLP problems, they have never been applied to NMT, to the best of our knowledge."}, {"id": 14, "string": "Furthermore, we combine these two ideas and propose a novel attention transformation, constrained sparsemax, which produces both sparse and bounded attention weights, yielding a compact and interpretable set of alignments."}, {"id": 15, "string": "While being in-between soft and hard alignments ( Figure 2 ), the constrained sparsemax transformation is end-to-end differentiable, hence amenable for training with gradient backpropagation."}, {"id": 16, "string": "To sum up, our contributions are as follows: 1 \u2022 We formulate constrained sparsemax and derive efficient linear and sublinear-time algorithms for running forward and backward propagation."}, {"id": 17, "string": "This transformation has two levels of sparsity: over time steps, and over the attended words at each step."}, {"id": 18, "string": "\u2022 We provide a detailed empirical comparison of various attention transformations, including softmax (Bahdanau et al., 2014) , sparse-max (Martins and Astudillo, 2016) , constrained softmax (Martins and Kreutzer, 2017) , and our newly proposed constrained sparsemax."}, {"id": 19, "string": "We provide error analysis including two new metrics targeted at detecting coverage problems."}, {"id": 20, "string": "Preliminaries Our underlying model architecture is a standard attentional encoder-decoder (Bahdanau et al., 2014) ."}, {"id": 21, "string": "Let x := x 1:J and y := y 1:T denote the source and target sentences, respectively."}, {"id": 22, "string": "We use a Bi-LSTM encoder to represent the source words as a matrix H := [h 1 , ."}, {"id": 23, "string": "."}, {"id": 24, "string": "."}, {"id": 25, "string": ", h J ] \u2208 R 2D\u00d7J ."}, {"id": 26, "string": "The conditional probability of the target sentence is given as p(y | x) := T t=1 p(y t | y 1:(t\u22121) , x), (1) where p(y t | y 1:(t\u22121) , x) is computed by a softmax output layer that receives a decoder state s t as input."}, {"id": 27, "string": "This state is updated by an auto-regressive LSTM, s t = RNN(embed(y t\u22121 ), s t\u22121 , c t ), where c t is an input context vector."}, {"id": 28, "string": "This vector is computed as c t := H\u03b1 t , where \u03b1 t is a probability distribution that represents the attention over the source words, commonly obtained as \u03b1 t = softmax(z t ), (2) where z t \u2208 R J is a vector of scores."}, {"id": 29, "string": "We follow Luong et al."}, {"id": 30, "string": "(2015) and define z t,j := s t\u22121 W h j as a bilinear transformation of encoder and decoder states, where W is a model parameter."}, {"id": 31, "string": "2 Sparse and Constrained Attention In this work, we consider alternatives to Eq."}, {"id": 32, "string": "2."}, {"id": 33, "string": "Since the softmax is strictly positive, it forces all words in the source to receive some probability mass in the resulting attention distribution, which can be wasteful."}, {"id": 34, "string": "Moreover, it may happen that the decoder attends repeatedly to the same source words across time steps, causing repetitions in the generated translation, as Tu et al."}, {"id": 35, "string": "(2016) observed."}, {"id": 36, "string": "With this in mind, we replace Eq."}, {"id": 37, "string": "2 by \u03b1 t = \u03c1(z t , u t ), where \u03c1 is a transformation that may depend both on the scores z t \u2208 R J and on upper bounds u t \u2208 R J that limit the amount of attention that each word can receive."}, {"id": 38, "string": "We consider three alternatives to softmax, described next."}, {"id": 39, "string": "Sparsemax."}, {"id": 40, "string": "The sparsemax transformation (Martins and Astudillo, 2016 ) is defined as: sparsemax(z) := arg min \u03b1\u2208\u2206 J \u03b1 \u2212 z 2 , (3) where \u2206 J := {\u03b1 \u2208 R J | \u03b1 \u2265 0, j \u03b1 j = 1}."}, {"id": 41, "string": "In words, it is the Euclidean projection of the scores z onto the probability simplex."}, {"id": 42, "string": "These projections tend to hit the boundary of the simplex, yielding a sparse probability distribution."}, {"id": 43, "string": "This allows the decoder to attend only to a few words in the source, assigning zero probability mass to all other words."}, {"id": 44, "string": "Martins and Astudillo (2016) have shown that the sparsemax can be evaluated in O(J) time (same asymptotic cost as softmax) and gradient backpropagation takes sublinear time (faster than softmax), by exploiting the sparsity of the solution."}, {"id": 45, "string": "Constrained softmax."}, {"id": 46, "string": "The constrained softmax transformation was recently proposed by Martins and Kreutzer (2017) in the context of easy-first sequence tagging, being defined as follows: csoftmax(z; u) := arg min \u03b1\u2208\u2206 J KL(\u03b1 softmax(z)) s.t."}, {"id": 47, "string": "\u03b1 \u2264 u, (4) where u is a vector of upper bounds, and KL(."}, {"id": 48, "string": ".)"}, {"id": 49, "string": "is the Kullback-Leibler divergence."}, {"id": 50, "string": "In other words, it returns the distribution closest to softmax(z) whose attention probabilities are bounded by u. Martins and Kreutzer (2017) have shown that this transformation can be evaluated in O(J log J) time and its gradients backpropagated in O(J) time."}, {"id": 51, "string": "To use this transformation in the attention mechanism, we make use of the idea of fertility (Brown et al., 1993) ."}, {"id": 52, "string": "Namely, let \u03b2 t\u22121 := t\u22121 \u03c4 =1 \u03b1 \u03c4 denote the cumulative attention that each source word has received up to time step t, and let f := (f j ) J j=1 be a vector containing fertility upper bounds for each source word."}, {"id": 53, "string": "The attention at step t is computed as \u03b1 t = csoftmax(z t , f \u2212 \u03b2 t\u22121 )."}, {"id": 54, "string": "(5) Intuitively, each source word j gets a credit of f j units of attention, which are consumed along the decoding process."}, {"id": 55, "string": "If all the credit is exhausted, it receives zero attention from then on."}, {"id": 56, "string": "Unlike the sparsemax transformation, which places sparse attention over the source words, the constrained softmax leads to sparsity over time steps."}, {"id": 57, "string": "Figure 1 : Illustration of the different attention transformations for a toy example with three source words."}, {"id": 58, "string": "We show the attention values on the probability simplex."}, {"id": 59, "string": "In the first row we assume scores z = (1.2, 0.8, \u22120.2), and in the second and third rows z = (0.7, 0.9, 0.1) and z = (\u22120.2, 0.2, 0.9), respectively."}, {"id": 60, "string": "For constrained softmax/sparsemax, we set unit fertilities to every word; for each row the upper bounds (represented as green dashed lines) are set as the difference between these fertilities and the cumulative attention each word has received."}, {"id": 61, "string": "The last row illustrates the cumulative attention for the three words after all rounds."}, {"id": 62, "string": "Constrained sparsemax."}, {"id": 63, "string": "In this work, we propose a novel transformation which shares the two properties above: it provides both sparse and bounded probabilities."}, {"id": 64, "string": "It is defined as: csparsemax(z; u) := arg min \u03b1\u2208\u2206 J \u03b1 \u2212 z 2 s.t."}, {"id": 65, "string": "\u03b1 \u2264 u."}, {"id": 66, "string": "(6) The following result, whose detailed proof we include as supplementary material (Appendix A), is key for enabling the use of the constrained sparsemax transformation in neural networks."}, {"id": 67, "string": "Proposition 1 Let \u03b1 = csparsemax(z; u) be the solution of Eq."}, {"id": 68, "string": "6, and define the sets A = {j \u2208 [J] | 0 < \u03b1 j < u j }, A L = {j \u2208 [J] | \u03b1 j = 0}, and A R = {j \u2208 [J] | \u03b1 j = u j }."}, {"id": 69, "string": "Then: \u2022 Forward propagation."}, {"id": 70, "string": "\u03b1 can be computed in O(J) time with the algorithm of Pardalos and Kovoor (1990) (Alg."}, {"id": 71, "string": "1 in Appendix A)."}, {"id": 72, "string": "The solution takes the form \u03b1 j = max{0, min{u j , z j \u2212 \u03c4 }}, where \u03c4 is a normalization constant."}, {"id": 73, "string": "\u2022 Gradient backpropagation."}, {"id": 74, "string": "Backpropagation takes sublinear time O(|A| + |A R |)."}, {"id": 75, "string": "Let L(\u03b8) be a loss function, d\u03b1 = \u2207 \u03b1 L(\u03b8) be the output gradient, and dz = \u2207 z L(\u03b8) and du = \u2207 u L(\u03b8) be the input gradients."}, {"id": 76, "string": "Then, we have: dz j = 1(j \u2208 A)(d\u03b1 j \u2212 m) (7) du j = 1(j \u2208 A R )(d\u03b1 j \u2212 m), (8) where m = 1 |A| j\u2208A d\u03b1 j ."}, {"id": 77, "string": "Fertility Bounds We experiment with three ways of setting the fertility of the source words: CONSTANT, GUIDED, and PREDICTED."}, {"id": 78, "string": "With CONSTANT, we set the fertilities of all source words to a fixed integer value f ."}, {"id": 79, "string": "With GUIDED, we train a word aligner based on IBM Model 2 (we used fast align in our experiments, Dyer et al."}, {"id": 80, "string": "(2013) ) and, for each word in the vocabulary, we set the fertilities to the maximal observed value in the training data (or 1 if no alignment was observed  with fertility upper bounds and the word aligner may miss some word pairs, we found it beneficial to add a constant to this number (1 in our experiments)."}, {"id": 81, "string": "At test time, we use the expected fertilities according to our model."}, {"id": 82, "string": "Sink token."}, {"id": 83, "string": "We append an additional <SINK> token to the end of the source sentence, to which we assign unbounded fertility (f J+1 = \u221e)."}, {"id": 84, "string": "The token is akin to the null alignment in IBM models."}, {"id": 85, "string": "The reason we add this token is the following: without the sink token, the length of the generated target sentence can never exceed j f j words if we use constrained softmax/sparsemax."}, {"id": 86, "string": "At training time this may be problematic, since the target length is fixed and the problems in Eqs."}, {"id": 87, "string": "4-6 can become infeasible."}, {"id": 88, "string": "By adding the sink token we guarantee j f j = \u221e, eliminating the problem."}, {"id": 89, "string": "Exhaustion strategies."}, {"id": 90, "string": "To avoid missing source words, we implemented a simple strategy to encourage more attention to words with larger credit: we redefine the pre-attention word scores as z t = z t + cu t , where c is a constant (c = 0.2 in our experiments)."}, {"id": 91, "string": "This increases the score of words which have not yet exhausted their fertility (we may regard it as a \"soft\" lower bound in Eqs."}, {"id": 92, "string": "4-6)."}, {"id": 93, "string": "Experiments We evaluated our attention transformations on three language pairs."}, {"id": 94, "string": "We focused on small datasets, as they are the most affected by coverage mistakes."}, {"id": 95, "string": "We use the IWSLT 2014 corpus for DE-EN, the KFTT corpus for JA-EN (Neubig, 2011), and the WMT 2016 dataset for RO-EN."}, {"id": 96, "string": "The training sets have 153,326, 329,882, and 560,767 parallel sentences, respectively."}, {"id": 97, "string": "Our reason to prefer smaller datasets is that this regime is what brings more adequacy issues and demands more structural biases, hence it is a good test bed for our methods."}, {"id": 98, "string": "We tokenized the data using the Moses scripts and preprocessed it with subword units (Sennrich et al., 2016) with a joint vocabulary and 32k merge operations."}, {"id": 99, "string": "Our implementation was done on a fork of the OpenNMT-py toolkit (Klein et al., 2017) with the default parameters 4 ."}, {"id": 100, "string": "We used a validation set to tune hyperparameters introduced by our model."}, {"id": 101, "string": "Even though our attention implementations are CPU-based using NumPy (unlike the rest of the computation which is done on the GPU), we did not observe any noticeable slowdown using multiple devices."}, {"id": 102, "string": "As baselines, we use softmax attention, as well as two recently proposed coverage models: \u2022 COVPENALTY (Wu et al., 2016, \u00a77) ."}, {"id": 103, "string": "At test time, the hypotheses in the beam are rescored with a global score that includes a length and a coverage penalty."}, {"id": 104, "string": "5 We tuned \u03b1 and \u03b2 with grid search on {0.2k} 5 k=0 , as in Wu et al."}, {"id": 105, "string": "(2016) ."}, {"id": 106, "string": "\u2022 COVVECTOR (Tu et al., 2016) ."}, {"id": 107, "string": "At training and test time, coverage vectors \u03b2 and additional parameters v are used to condition the next attention step."}, {"id": 108, "string": "We adapted this to our bilinear attention by defining z t,j = s t\u22121 (W h j + v\u03b2 t\u22121,j )."}, {"id": 109, "string": "We also experimented combining the strategies above with the sparsemax transformation."}, {"id": 110, "string": "As evaluation metrics, we report tokenized BLEU, METEOR (Denkowski and Lavie (2014) , as well as two new metrics that we describe next to account for over and under-translation."}, {"id": 111, "string": "6 4 We used a 2-layer LSTM, embedding and hidden size of 500, dropout 0.3, and the SGD optimizer for 13 epochs."}, {"id": 112, "string": "5 Since our sparse attention can become 0 for some words, we extended the original coverage penalty by adding another parameter , set to 0.1: cp(x; y) := \u03b2 J j=1 log max{ , min{1, |y| t=1 \u03b1jt}}."}, {"id": 113, "string": "6 Both evaluation metrics are included in our software package at www.github.com/Unbabel/ sparse constrained attention."}, {"id": 114, "string": "REP-score: a new metric to count repetitions."}, {"id": 115, "string": "Formally, given an n-gram s \u2208 V n , let t(s) and r(s) be the its frequency in the model translation and reference."}, {"id": 116, "string": "We first compute a sentence-level score \u03c3(t, r) = \u03bb 1 s\u2208V n , t(s)\u22652 max{0, t(s) \u2212 r(s)} + \u03bb 2 w\u2208V max{0, t(ww) \u2212 r(ww)}."}, {"id": 117, "string": "The REP-score is then given by summing \u03c3(t, r) over sentences, normalizing by the number of words on the reference corpus, and multiplying by 100."}, {"id": 118, "string": "We used n = 2, \u03bb 1 = 1 and \u03bb 2 = 2."}, {"id": 119, "string": "DROP-score: a new metric that accounts for possibly dropped words."}, {"id": 120, "string": "To compute it, we first compute two sets of word alignments: from source to reference translation, and from source to the predicted translation."}, {"id": 121, "string": "In our experiments, the alignments were obtained with fast align (Dyer et al., 2013) , trained on the training partition of the data."}, {"id": 122, "string": "Then, the DROP-score computes the percentage of source words that aligned with some word from the reference translation, but not with any word from the predicted translation."}, {"id": 123, "string": "Table 1 shows the results."}, {"id": 124, "string": "We can see that on average, the sparse models (csparsemax as well as sparsemax combined with coverage models) have higher scores on both BLEU and METEOR."}, {"id": 125, "string": "Generally, they also obtain better REP and DROP scores than csoftmax and softmax, which suggests that sparse attention alleviates the problem of coverage to some extent."}, {"id": 126, "string": "To compare different fertility strategies, we ran experiments on the DE-EN for the csparsemax transformation ( Table 2) ."}, {"id": 127, "string": "We see that the PRE-DICTED strategy outperforms the others both in terms of BLEU and METEOR, albeit slightly."}, {"id": 128, "string": "Figure 2 shows examples of sentences for which the csparsemax fixed repetitions, along with the corresponding attention maps."}, {"id": 129, "string": "We see that in the case of softmax repetitions, the decoder attends repeatedly to the same portion of the source sentence (the expression \"letzten hundert\" in the first sentence and \"regierung\" in the second sentence)."}, {"id": 130, "string": "Not only did csparsemax avoid repetitions, but it also yielded a sparse set of alignments, as expected."}, {"id": 131, "string": "Appendix B provides more examples of translations from all models in discussion."}, {"id": 132, "string": "Conclusions We proposed a new approach to address the coverage problem in NMT, by replacing the softmax attentional transformation by sparse and constrained alternatives: sparsemax, constrained softmax, and the newly proposed constrained sparsemax."}, {"id": 133, "string": "For the latter, we derived efficient forward and backward propagation algorithms."}, {"id": 134, "string": "By incorporating a model for fertility prediction, our attention transformations led to sparse alignments, avoiding repeated words in the translation."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 19}, {"section": "Preliminaries", "n": "2", "start": 20, "end": 30}, {"section": "Sparse and Constrained Attention", "n": "3", "start": 31, "end": 76}, {"section": "Fertility Bounds", "n": "4", "start": 77, "end": 92}, {"section": "Experiments", "n": "5", "start": 93, "end": 130}, {"section": "Conclusions", "n": "6", "start": 131, "end": 134}], "figures": [{"filename": "../figure/image/1092-Figure1-1.png", "caption": "Figure 1: Illustration of the different attention transformations for a toy example with three source words. We show the attention values on the probability simplex. In the first row we assume scores z = (1.2, 0.8,\u22120.2), and in the second and third rows z = (0.7, 0.9, 0.1) and z = (\u22120.2, 0.2, 0.9), respectively. For constrained softmax/sparsemax, we set unit fertilities to every word; for each row the upper bounds (represented as green dashed lines) are set as the difference between these fertilities and the cumulative attention each word has received. The last row illustrates the cumulative attention for the three words after all rounds.", "page": 2, "bbox": {"x1": 108.47999999999999, "x2": 497.76, "y1": 77.28, "y2": 264.48}}, {"filename": "../figure/image/1092-Table2-1.png", "caption": "Table 2: Impact of various fertility strategies for the csparsemax attention model (DE-EN).", "page": 4, "bbox": {"x1": 100.8, "x2": 261.12, "y1": 204.95999999999998, "y2": 264.0}}, {"filename": "../figure/image/1092-Table1-1.png", "caption": "Table 1: BLEU, METEOR, REP and DROP scores on the test sets for different attention transformations.", "page": 4, "bbox": {"x1": 72.0, "x2": 525.12, "y1": 61.44, "y2": 164.16}}, {"filename": "../figure/image/1092-Figure2-1.png", "caption": "Figure 2: Attention maps for softmax and csparsemax for two DE-EN sentence pairs (white means zero attention). Repeated words are highlighted. The reference translations are \u201cThis is Moore\u2019s law over the last hundred years\u201d and \u201cI am going to go ahead and select government.\u201d", "page": 3, "bbox": {"x1": 81.6, "x2": 281.28, "y1": 63.839999999999996, "y2": 300.47999999999996}}]}