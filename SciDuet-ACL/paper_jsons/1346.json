{"title": "Improving a Neural Semantic Parser by Counterfactual Learning from Human Bandit Feedback", "abstract": "Counterfactual learning from human bandit feedback describes a scenario where user feedback on the quality of outputs of a historic system is logged and used to improve a target system. We show how to apply this learning framework to neural semantic parsing. From a machine learning perspective, the key challenge lies in a proper reweighting of the estimator so as to avoid known degeneracies in counterfactual learning, while still being applicable to stochastic gradient optimization. To conduct experiments with human users, we devise an easy-to-use interface to collect human feedback on semantic parses. Our work is the first to show that semantic parsers can be improved significantly by counterfactual learning from logged human feedback data.", "text": [{"id": 0, "string": "Introduction In semantic parsing, natural language utterances are mapped to machine readable parses which are complex and often tailored specifically to the underlying task."}, {"id": 1, "string": "The cost and difficulty of manually preparing large amounts of such parses thus is a bottleneck for supervised learning in semantic parsing."}, {"id": 2, "string": "Recent work (Liang et al."}, {"id": 3, "string": "(2017) ; Mou et al."}, {"id": 4, "string": "(2017) ; Peng et al."}, {"id": 5, "string": "(2017) ; inter alia) has applied reinforcement learning to address the annotation bottleneck as follows: Given a question, the existence of a corresponding gold answer is assumed."}, {"id": 6, "string": "A semantic parser produces multiple parses per question and corresponding answers are obtained."}, {"id": 7, "string": "These answers are then compared against the gold answer and a positive reward is recorded if there is an overlap."}, {"id": 8, "string": "The parser is then guided towards correct parses using the REIN-FORCE algorithm (Williams, 1992) which scales the gradient for the various parses by their obtained reward (see the left half of Figure 1 )."}, {"id": 9, "string": "However, learning from question-answer pairs is only efficient if gold answers are cheap to obtain."}, {"id": 10, "string": "For complex open-domain question-answering tasks, correct answers are not unique factoids, but openended lists, counts in large ranges, or fuzzily defined objects."}, {"id": 11, "string": "For example, geographical queries against databases such as OpenStreetMap (OSM) can involve fuzzy operators such as \"near\" or \"in walking distance\" and thus need to allow for fuzziness in the answers as well."}, {"id": 12, "string": "A possible solution lies in machine learning from even weaker supervision signals in form of human bandit feedback 1 where the semantic parsing system suggests exactly one parse for which feedback is collected from a human user."}, {"id": 13, "string": "In this setup neither gold parse nor gold answer are known and feedback is obtained for only one system output per question."}, {"id": 14, "string": "The goal of our paper is to exploit this scenario of learning from human bandit feedback to train semantic parsers."}, {"id": 15, "string": "This learning scenario perfectly fits commercial setups such as virtual personal assistants that embed a semantic parser."}, {"id": 16, "string": "Commercial systems can easily log large amounts of interaction data between users and system."}, {"id": 17, "string": "Once sufficient data has been collected, the log can then be used to improve the parser."}, {"id": 18, "string": "This leads to a counterfactual learning scenario (Bottou et al., 2013) where we have to solve the counterfactual problem of how to improve a target system from logged feedback that was given to the outputs of a different historic system (see the right half of Figure 1) ."}, {"id": 19, "string": "In order to achieve our goal of counterfactual learning of semantic parsers from human bandit feedback, the following contributions are required: Figure 1 : Left: Online reinforcement learning setup for semantic parsing setup where both questions and gold answers are available."}, {"id": 20, "string": "The parser attempts to find correct machine readable parses (MRPs) by producing multiple parses, obtaining corresponding answers, and comparing them against the gold answer."}, {"id": 21, "string": "Right: In our setup, a question does not have an associated gold answer."}, {"id": 22, "string": "The parser outputs a single MRP and the corresponding answer is shown to a user who provides some feedback."}, {"id": 23, "string": "Such triplets are collected in a log which can be used for offline training of a semantic parser."}, {"id": 24, "string": "This scenario is called counterfactual since the feedback was logged for outputs from a system different from the target system to be optimized."}, {"id": 25, "string": "First, we need to construct an easy-to-use user interface that allows to collect feedback based on the parse rather than the answer."}, {"id": 26, "string": "To this aim, we automatically convert the parse to a set of statements that can be judged as correct or incorrect by a human."}, {"id": 27, "string": "This approach allows us to assign rewards at the token level, which in turn enables us to perform blame assignment in bandit learning and to learn from partially correct queries where tokens are reinforced individually."}, {"id": 28, "string": "We show that users can provide such feedback for one question-parse pair in 16.4 seconds on average."}, {"id": 29, "string": "This exemplifies that our approach is more efficient and cheaper than recruiting experts to annotate parses or asking workers to compile large answer sets."}, {"id": 30, "string": "Next, we demonstrate experimentally that counterfactual learning can be applied to neural sequence-to-sequence learning for semantic parsing."}, {"id": 31, "string": "A baseline neural semantic parser is trained in fully supervised fashion, human bandit feedback from human users is collected in a log and subsequently used to improve the parser."}, {"id": 32, "string": "The resulting parser significantly outperforms the baseline model as well as a simple bandit-to-supervised approach (B2S) where the subset of completely correct parses is treated as a supervised dataset."}, {"id": 33, "string": "Finally, we repeat our experiments on a larger but simulated log to show that our gains can scale: the baseline system is improved by 7.45% in answer F1 score without ever seeing a gold standard parse."}, {"id": 34, "string": "Lastly, from a machine learning perspective, we have to solve problems of degenerate behavior in counterfactual learning by lifting the multiplicative control variate technique (Swaminathan and Joachims, 2015b; Lawrence et al., 2017b,a) to stochastic learning for neural models."}, {"id": 35, "string": "This is done by reweighting target model probabilities over the logged data under a one-step-late model that decouples the normalization from gradient estimation and is thus applicable in stochastic (minibatch) gradient optimization."}, {"id": 36, "string": "Related Work Semantic parsers have been successfully trained using neural sequence-to-sequence models with a cross-entropy objective and question-parse pairs (Jia and Liang, 2016; Dong and Lapata, 2016)) or question-answer pairs (Neelakantan et al., 2017) ."}, {"id": 37, "string": "Improving semantic parsers using weak feedback has previously been studied (Goldwasser and Roth (2013) ; Artzi and Zettlemoyer (2013) ; inter alia)."}, {"id": 38, "string": "More recently, several works have applied policy gradient techniques such as REINFORCE (Williams, 1992) to train neural semantic parsers (Liang et al."}, {"id": 39, "string": "(2017) ; Mou et al."}, {"id": 40, "string": "(2017) ; Peng et al."}, {"id": 41, "string": "(2017) ; inter alia)."}, {"id": 42, "string": "However, they assume the existence of the true target answers that can be used to obtain a reward for any number of output queries suggested by the system."}, {"id": 43, "string": "It thus differs from a bandit setup where we assume that a reward is available for only one structure."}, {"id": 44, "string": "Our work most closely resembles the work of Iyer et al."}, {"id": 45, "string": "(2017) who do make the assumption of only being able to judge one output."}, {"id": 46, "string": "They improve their parser using simulated and real user feedback."}, {"id": 47, "string": "Parses with negative feedback are given to experts to obtain the correct parse."}, {"id": 48, "string": "Corrected queries and queries with positive feedback are added to the training corpus and learning continues with a cross-entropy objective."}, {"id": 49, "string": "We show that this bandit-to-supervision approach can be outperformed by offline bandit learning from partially correct queries."}, {"id": 50, "string": "Yih et al."}, {"id": 51, "string": "(2016) proposed a user interface for the Freebase database that enables a fast and easy creation of parses."}, {"id": 52, "string": "However, in their setup the worker still requires expert knowledge about the Freebase database, whereas in our approach feedback can be collected freely and from any user interacting with the system."}, {"id": 53, "string": "From a machine learning perspective, related work can be found in the areas of counterfactual bandit learning (Dudik et al., 2011; Swaminathan and Joachims, 2015a) , or equivalently, off-policy reinforcement learning (Precup et al., 2000; Jiang and Li, 2016) ."}, {"id": 54, "string": "Our contribution is to modify the self-normalizing estimator (Kong, 1992; Precup et al., 2000; Swaminathan and Joachims, 2015b; Joachims et al., 2018) to be applicable to neural networks."}, {"id": 55, "string": "Our work is similar to the counterfactual learning setup for machine translation introduced by Lawrence et al."}, {"id": 56, "string": "(2017b) ."}, {"id": 57, "string": "Following their insight, we also assume the logs were created deterministically, i.e."}, {"id": 58, "string": "the logging policy always outputs the most likely sequence."}, {"id": 59, "string": "Their framework was applied to statistical machine translation using linear models."}, {"id": 60, "string": "We show how to generalize their framework to neural models and how to apply it to the task of neural semantic parsing in the OSM domain."}, {"id": 61, "string": "Neural Semantic Parsing Our semantic parsing model is a state-of-theart sequence-to-sequence neural network using an encoder-decoder setup Sutskever et al., 2014) together with an attention mechanism (Bahdanau et al., 2015) ."}, {"id": 62, "string": "We use the settings of Sennrich et al."}, {"id": 63, "string": "(2017) , where an input sequence x = x 1 , x 2 , ."}, {"id": 64, "string": "."}, {"id": 65, "string": "."}, {"id": 66, "string": "x |x| (a natural language question) is encoded by a Recurrent Neural Network (RNN), each input token has an associated hidden vector h i = [ \u2212 \u2192 h i ; \u2190 \u2212 h i ] where the former is created by a forward pass over the input, and the latter by a backward pass."}, {"id": 67, "string": "\u2212 \u2192 h i is obtained by recur- (Chung et al., 2014) , and \u2190 \u2212 h i is computed analogously."}, {"id": 68, "string": "The input sequence is reduced to a single vector c = g({h 1 , ."}, {"id": 69, "string": "."}, {"id": 70, "string": "."}, {"id": 71, "string": ", h |x| }) which serves as the initialization of the decoder RNN."}, {"id": 72, "string": "g calculates the average over all vectors h i ."}, {"id": 73, "string": "At each time step t the decoder state is set by s t = q(s t\u22121 , y t\u22121 , c t )."}, {"id": 74, "string": "q is a conditional GRU with an attention mechanism and c t is the context vector computed by the attention mechanism."}, {"id": 75, "string": "Given an output vocabulary V y and the decoder state s t = {s 1 , ."}, {"id": 76, "string": "."}, {"id": 77, "string": "."}, {"id": 78, "string": ", s |Vy| }, a softmax output layer defines a probability distribution over V y and the probability for a token y j is: sively computing f (x i , \u2212 \u2192 h i\u22121 ) where f is a Gated Recurrent Unit (GRU) \u03c0 w (y j = t o |y <j , x) = exp(s to ) |Vy| v=1 exp(s tv ) ."}, {"id": 79, "string": "(1) The model \u03c0 w can be seen as parameterized policy over an action space defined by the target language vocabulary."}, {"id": 80, "string": "The probability for a full output sequence y = y 1 , y 2 , ."}, {"id": 81, "string": "."}, {"id": 82, "string": "."}, {"id": 83, "string": "y |y| is defined by \u03c0 w (y|x) = |y| j=1 \u03c0 w (y j |y <j , x)."}, {"id": 84, "string": "(2) In our case, output sequences are linearized machine readable parses, called queries in the following."}, {"id": 85, "string": "Given supervised data D sup = {(x t ,\u0233 t )} n t=1 of question-query pairs, where\u0233 t is the true target query for x t , the neural network can be trained using SGD and a cross-entropy (CE) objective: L CE = \u2212 1 n n t=1 |\u0233| j=1 log \u03c0 w (\u0233 j |\u0233 <j , x)."}, {"id": 86, "string": "(3) Counterfactual Learning from Deterministic Bandit Logs Counterfactual Learning Objectives."}, {"id": 87, "string": "We assume a policy \u03c0 w that, given an input x \u2208 X , defines a conditional probability distribution over possible outputs y \u2208 Y(x)."}, {"id": 88, "string": "Furthermore, we assume that the policy is parameterized by w and its gradient can be derived."}, {"id": 89, "string": "In this work, \u03c0 w is defined by the sequence-to-sequence model described in Section 3."}, {"id": 90, "string": "We also assume that the model decomposes over individual output tokens, i.e."}, {"id": 91, "string": "that the model produces the output token by token."}, {"id": 92, "string": "The counterfactual learning problem can be described as follows: We are given a data log of \u2207 wRDPM = 1 n n t=1 \u03b4 t \u03c0 w (y t |x t )\u2207 w log \u03c0 w (y t |x t )."}, {"id": 93, "string": "\u2207 wRDPM+R = 1 n n t=1 [\u03b4 t\u03c0w (y t |x t )(\u2207 w log \u03c0 w (y t |x t ) \u2212 1 n n u=1\u03c0 w (y u |x u )\u2207 log \u03c0 w (y u |x u ))]."}, {"id": 94, "string": "\u2207 wRDPM+OSL = 1 m m t=1 \u03b4 t\u03c0w,w (y t |x t )\u2207 w log \u03c0 w (y t |x t )."}, {"id": 95, "string": "\u2207 wRDPM+T = 1 n n t=1 |y| j=1 \u03b4 j \u03c0 w (y j |x t ) |y| j=1 \u2207 w log \u03c0 w (y j |x t )."}, {"id": 96, "string": "\u2207 wRDPM+T+OSL = 1 m m t=1 |y| j=1 \u03b4 j\u03c0w,w (y t |x t ) |y| j=1 \u2207 w log \u03c0 w (y j |x t )."}, {"id": 97, "string": "triples D log = {(x t , y t , \u03b4 t )} n t=1 where outputs y t for inputs x t were generated by a logging system under policy \u03c0 0 , and loss values \u03b4 t \u2208 [\u22121, 0] 2 were observed for the generated data points."}, {"id": 98, "string": "Our goal is to optimize the expected reward (in our case: minimize the expected risk) for a target policy \u03c0 w given the data log D log ."}, {"id": 99, "string": "In case of deterministic logging, outputs are logged with propensity \u03c0 0 (y t |x t ) = 1, t = 1, ."}, {"id": 100, "string": "."}, {"id": 101, "string": "."}, {"id": 102, "string": ", n. This results in a deterministic propensity matching (DPM) objective (Lawrence et al., 2017b) , without the possibility to correct the sampling bias of the logging policy by inverse propensity scoring (Rosenbaum and Rubin, 1983) : R DPM (\u03c0 w ) = 1 n n t=1 \u03b4 t \u03c0 w (y t |x t )."}, {"id": 103, "string": "(4) This objective can show degenerate behavior in that it overfits to the choices of the logging policy (Swaminathan and Joachims, 2015b; Lawrence et al., 2017a) ."}, {"id": 104, "string": "This degenerate behavior can be avoided by reweighting using a multiplicative control variate (Kong, 1992; Precup et al., 2000; Jiang and Li, 2016; Thomas and Brunskill, 2016) ."}, {"id": 105, "string": "The new objective is called the reweighted deterministic propensity matching (DPM+R) objective in Lawrence et al."}, {"id": 106, "string": "(2017b) : R DPM+R (\u03c0 w ) = 1 n n t=1 \u03b4 t\u03c0w (y t |x t ) (5) = 1 n n t=1 \u03b4 t \u03c0 w (y t |x t ) 1 n n t=1 \u03c0 w (y t |x t ) ."}, {"id": 107, "string": "Algorithms for optimizing the discussed objectives can be derived as gradient descent algorithms where gradients using the score function gradient estimator (Fu, 2006) are shown in Table 1 ."}, {"id": 108, "string": "Reweighting in Stochastic Learning."}, {"id": 109, "string": "As shown in Swaminathan and Joachims (2015b) and Lawrence et al."}, {"id": 110, "string": "(2017a) , reweighting over the entire data log D log is crucial since it avoids that high loss outputs in the log take away probability mass from low loss outputs."}, {"id": 111, "string": "This multiplicative control variate has the additional effect of reducing the variance of the estimator, at the cost of introducing a bias of order O( 1 n ) that decreases as n increases (Kong, 1992) ."}, {"id": 112, "string": "The desirable properties of this control variate cannot be realized in a stochastic (minibatch) learning setup since minibatch sizes large enough to retain the desirable reweighting properties are infeasible for large neural networks."}, {"id": 113, "string": "We offer a simple solution to this problem that nonetheless retains all desired properties of the reweighting."}, {"id": 114, "string": "The idea is inspired by one-step-late algorithms that have been introduced for EM algorithms (Green, 1990) ."}, {"id": 115, "string": "In the EM case, dependencies in objectives are decoupled by evaluating certain terms under parameter settings from previous iterations (thus: one-step-late) in order to achieve closed-form solutions."}, {"id": 116, "string": "In our case, we decouple the reweighting from the parameterization of the objective by evaluating the reweighting under parameters w from some previous iteration."}, {"id": 117, "string": "This allows us to perform gradient descent updates and reweighting asynchronously."}, {"id": 118, "string": "Updates are performed using minibatches, however, reweighting is based on the entire log, allowing us to retain the desirable properties of the control variate."}, {"id": 119, "string": "The new objective, called one-step-late reweighted DPM objective (DPM+OSL), optimizes \u03c0 w,w with respect to w for a minibatch of size m, with reweighting over the entire log of size n under parameters w : R DPM+OSL (\u03c0 w ) = 1 m m t=1 \u03b4 t\u03c0w,w (y t |x t ) (6) = 1 m m t=1 \u03b4 t \u03c0 w (y t |x t ) 1 n n t=1 \u03c0 w (y t |x t ) ."}, {"id": 120, "string": "If the renormalization is updated periodically, e.g."}, {"id": 121, "string": "after every validation step, renormalizations under w or w are not much different and will not hamper convergence."}, {"id": 122, "string": "Despite losing the formal justification from the perspective of control variates, we found empirically that the OSL update schedule for reweighting is sufficient and does not deteriorate performance."}, {"id": 123, "string": "The gradient for learning with OSL updates is given in Table 1 ."}, {"id": 124, "string": "Token-Level Rewards."}, {"id": 125, "string": "For our application of counterfactual learning to human bandit feedback, we found another deviation from standard counterfactual learning to be helpful: For humans, it is hard to assign a graded reward to a query at a sequence level because either the query is correct or it is not."}, {"id": 126, "string": "In particular, with a sequence level reward of 0 for incorrect queries, we do not know which part of the query is wrong and which parts might be correct."}, {"id": 127, "string": "Assigning rewards at token-level will ease the feedback task and allow the semantic parser to learn from partially correct queries."}, {"id": 128, "string": "Thus, assuming the underlying policy can decompose over tokens, a token level (DPM+T) reward objective can be defined: R DPM+T (\u03c0 w ) = 1 n n t=1 \uf8eb \uf8ed |y| j=1 \u03b4 j \u03c0 w (y j |x t ) \uf8f6 \uf8f8 ."}, {"id": 129, "string": "(7) Analogously, we can define an objective that combines the token-level rewards and the minibatched reweighting (DPM+T+OSL): R DPM+T+OSL (\u03c0 w ) = 1 m m t=1 |y| j=1 \u03b4 j \u03c0 w (y j |x t ) 1 n n t=1 \u03c0 w (y t |x t ) ."}, {"id": 130, "string": "(8) Gradients for the DPM+T and DPM+T+OSL objectives are given in Table 1 ."}, {"id": 131, "string": "Semantic Parsing in the OpenStreetMap Domain OpenStreetMap (OSM) is a geographical database in which volunteers annotate points of interests in the world."}, {"id": 132, "string": "A point of interest consists of one or more associated GPS points."}, {"id": 133, "string": "Further relevant information may be added at the discretion of the volunteer in the form of tags."}, {"id": 134, "string": "Each tag consists of a key and an associated value, for example \"tourism : hotel\"."}, {"id": 135, "string": "The NLMAPS corpus was introduced by Haas and Riezler (2016) as a basis to create a natural language interface to the OSM database."}, {"id": 136, "string": "It pairs English questions with machine readable parses, i.e."}, {"id": 137, "string": "queries that can be executed against OSM."}, {"id": 138, "string": "Human Feedback Collection."}, {"id": 139, "string": "The task of creating a natural language interface for OSM demonstrates typical difficulties that make it expensive to collect supervised data."}, {"id": 140, "string": "The machine readable language of the queries is based on the OVERPASS query language which was specifically designed for the OSM database."}, {"id": 141, "string": "It is thus not easily possible to find experts that could provide correct queries."}, {"id": 142, "string": "It is equally difficult to ask workers at crowdsourcing platforms for the correct answer."}, {"id": 143, "string": "For many questions, the answer set is too large to expect a worker to count or list them all in a reasonable amount of time and without errors."}, {"id": 144, "string": "For example, for the question \"How many hotels are there in Paris?\""}, {"id": 145, "string": "there are 951 hotels annotated in the OSM database."}, {"id": 146, "string": "Instead we propose to automatically transform the query into a block of statements that can easily be judged as correct or incorrect by a human."}, {"id": 147, "string": "The question and the created block of statements are embedded in a user interface with a form that can be filled out by users."}, {"id": 148, "string": "Each statement is accompanied by a set of radio buttons where a user can select either \"Yes\" or \"No\"."}, {"id": 149, "string": "For a screenshot of the interface and an example see Figure 2 ."}, {"id": 150, "string": "In total there are 8 different types of statements."}, {"id": 151, "string": "The presence of certain tokens in a query trigger different statement types."}, {"id": 152, "string": "For example, the token \"area\" triggers the statement type \"Town\"."}, {"id": 153, "string": "The statement is then populated with the corresponding information from the query."}, {"id": 154, "string": "In the case of \"area\", the following OSM value is used, e.g."}, {"id": 155, "string": "\"Paris\"."}, {"id": 156, "string": "With this, the meaning of every query can be captured by a set of human-understandable statements."}, {"id": 157, "string": "For a full overview of all statement types and their triggers see section B of the supplementary material."}, {"id": 158, "string": "OSM tags and keys are generally understandable."}, {"id": 159, "string": "For example, the correct OSM tag for \"hotels\" is \"tourism : hotel\" and when searching for websites, the correct question type key would be \"website\"."}, {"id": 160, "string": "Nevertheless, for each OSM tag or key, we automatically search for the corresponding Wikipedia page on the OpenStreetMap Wiki 3 and extract the description for this tag or key."}, {"id": 161, "string": "The description is made available to the user in form of a tool-tip that appears when hovering over the tag or key with the mouse."}, {"id": 162, "string": "If a user is unsure if a OSM tag or key is correct, they can read this description to help in their decision making."}, {"id": 163, "string": "Once the form is submitted, a script maps each statement back to the corresponding tokens in the original query."}, {"id": 164, "string": "These tokens then receive negative or positive feedback based on the feedback the user provided for that statement."}, {"id": 165, "string": "Corpus Extension."}, {"id": 166, "string": "Similar to the extension of the NLMAPS corpus by Lawrence and Riezler (2016) who include shortened questions which are more typically used by humans in search tasks, we present an automatic extension that allows a larger coverage of common OSM tags."}, {"id": 167, "string": "4 The basis for the extension is a hand-written, online freely available list 5 that links natural language expressions such as \"cash machine\" to appropriate OSM tags, in this case \"amenity : atm\"."}, {"id": 168, "string": "Using the list, we generate for each unique expression-tag pair a set of question-query pairs."}, {"id": 169, "string": "These latter pairs contain 3 https://wiki.openstreetmap.org/ 4 The extended dataset, called NLMAPS V2, will be released upon acceptance of the paper."}, {"id": 170, "string": "(Lawrence and Riezler, 2016) and the automatic extensions of the most common OSM tags."}, {"id": 171, "string": "several placeholders which will be filled automatically in a second step."}, {"id": 172, "string": "To fill the area placeholder $LOC, we sample from a list of 30 cities from France, Germany and the UK."}, {"id": 173, "string": "$POI is the placeholder for a point of interest."}, {"id": 174, "string": "We sample it from the list of objects which are located in the prior sampled city and which have a name key."}, {"id": 175, "string": "The corresponding value belonging to the name key will be used to fill this spot."}, {"id": 176, "string": "The placeholder $QTYPE is filled by uniformly sampling from the four primary question types available in the NLMAPS query language."}, {"id": 177, "string": "On the natural language side they corresponded to \"How many\", \"Where\", \"Is there\" and $KEY."}, {"id": 178, "string": "$KEY is a further parameter belonging to the primary question operator FINDKEY."}, {"id": 179, "string": "It can be filled by any OSM key, such as name, website or height."}, {"id": 180, "string": "To ensure that there will be an answer for the generated query, we first ran a query with the current tag (\"amenity : atm\") to find all objects fulfilling this requirement in the area of the already sampled city."}, {"id": 181, "string": "From the list of returned objects and the keys that appear in association with them, we uniformly sampled a key."}, {"id": 182, "string": "For $DIST we chose between the pre-defined options for walking distance and within city distance."}, {"id": 183, "string": "The expressions map to corresponding values which define the size of a radius in which objects of interest (with tag \"amenity : atm\") will be located."}, {"id": 184, "string": "If the walking distance was selected, we added \"in walking distance\" to the question."}, {"id": 185, "string": "Otherwise no extra text was added to the question, assuming the within city distance to be the default."}, {"id": 186, "string": "This sampling process was repeated twice."}, {"id": 187, "string": "Table 2 presents the corpus statistics, comparing NLMAPS to our extension."}, {"id": 188, "string": "The automatic extension, obviating the need for expensive manual work, allows a vast increase of question-query pairs by an order of magnitude."}, {"id": 189, "string": "Consequently the number of tokens and types increase in a similar vein."}, {"id": 190, "string": "However, the average sentence length drops."}, {"id": 191, "string": "This comes as no surprise due to the nature of the rather simple hand-written list which contains never more than one tag for an element, resulting in simpler question structures."}, {"id": 192, "string": "However, the main idea of utilizing this list is to extend the coverage to previously unknown OSM tags."}, {"id": 193, "string": "With 6,582 distinct tags compared to the previous 477, this was clearly successful."}, {"id": 194, "string": "Together with the still complex sentences from the original corpus, a semantic parser is now able to learn both complex questions and a large variety of tags."}, {"id": 195, "string": "An experiment that empirically validates the usefulness of the automatically created data can be found in the supplementary material, section A."}, {"id": 196, "string": "Experiments General Settings."}, {"id": 197, "string": "In our experiments we use the sequence-to-sequence neural network package NEMATUS (Sennrich et al., 2017) ."}, {"id": 198, "string": "Following the method used by Haas and Riezler (2016) , we split the queries into individual tokens by taking a pre-order traversal of the original tree-like structure."}, {"id": 199, "string": "For example, \"query(west(area(keyval('name','Paris')), nwr(keyval('railway','station'))),qtype(count))\" becomes \"query@2 west@2 area@1 keyval@2 name@0 Paris@s nwr@1 keyval@2 railway@0 station@s qtype@1 count@0\"."}, {"id": 200, "string": "The SGD optimizer used is ADADELTA (Zeiler, 2012)."}, {"id": 201, "string": "The model employs 1,024 hidden units and word embeddings of size 1,000."}, {"id": 202, "string": "The maximum sentence length is 200 and gradients are clipped if they exceed a value of 1.0."}, {"id": 203, "string": "The stopping point is determined by validation on the development set and selecting the point at which the highest evaluation score is obtained."}, {"id": 204, "string": "F1 validation is run after every 100 updates, and each update is made on the basis of a minibatch of size 80."}, {"id": 205, "string": "The evaluation of all models is based on the answers obtained by executing the most likely query obtained after a beam search with a beam of size 12."}, {"id": 206, "string": "We report the F1 score which is the harmonic mean of precision and recall."}, {"id": 207, "string": "Recall is defined as the percentage of fully correct answers divided by the set size."}, {"id": 208, "string": "Precision is the percentage of correct answers out of the set of answers with non-empty strings."}, {"id": 209, "string": "Statistical significance between models is measured using an approximate randomization test (Noreen, 1989) ."}, {"id": 210, "string": "Baseline Parser & Log Creation."}, {"id": 211, "string": "Our experiment design assumes a baseline neural semantic parser that is trained in fully supervised fashion, and is to be improved by bandit feedback obtained for system outputs from the baseline system for given questions."}, {"id": 212, "string": "For this purpose, we select 2,000 question-query pairs randomly from the full extended NLMAPS V2 corpus."}, {"id": 213, "string": "We will call this dataset D sup ."}, {"id": 214, "string": "Using this dataset, a baseline semantic parser is trained in supervised fashion under a cross-entropy objective."}, {"id": 215, "string": "It obtains an F1 score of 57.45% and serves as the logging policy \u03c0 0 ."}, {"id": 216, "string": "Furthermore we randomly split off 1,843 and 2,000 pairs for a development and test set, respectively."}, {"id": 217, "string": "This leaves a set of 22,765 question-query pairs."}, {"id": 218, "string": "The questions can be used as input and bandit feedback can be collected for the most likely output of the semantic parser."}, {"id": 219, "string": "We refer to this dataset as D log ."}, {"id": 220, "string": "To collect human feedback, we take the first 1,000 questions from D log and use \u03c0 0 to parse these questions to obtain one output query for each."}, {"id": 221, "string": "5 question-query pairs are discarded because the suggested query is invalid."}, {"id": 222, "string": "For the remaining question-query pairs, the queries are each transformed into a block of human-understandable statements and embedded into the user interface described in Section 5."}, {"id": 223, "string": "We recruited 9 users to provide feedback for these question-query pairs."}, {"id": 224, "string": "The resulting log is referred to as D human ."}, {"id": 225, "string": "Every question-query pair is purposely evaluated only once to mimic a realistic real-world scenario where user logs are collected as users use the system."}, {"id": 226, "string": "In this scenario, it is also not possible to explicitly obtain several evaluations for the same question-query pair."}, {"id": 227, "string": "Some examples of the received feedback can be found in the supplementary material, section C. To verify that the feedback collection is efficient, we measured the time each user took from loading a form to submitting it."}, {"id": 228, "string": "To provide feedback for one question-query pair, users took 16.4 seconds on average with a standard deviation of 33.2 seconds."}, {"id": 229, "string": "The vast majority (728 instances) are completed in less than 10 seconds."}, {"id": 230, "string": "Learning from Human Bandit Feedback."}, {"id": 231, "string": "An analysis of D human shows that for 531 queries all corresponding statements were marked as correct."}, {"id": 232, "string": "We consider a simple baseline that treats completely correct logged data as a supervised data set with which training continues using the crossentropy objective."}, {"id": 233, "string": "We call this baseline banditto-supervised conversion (B2S)."}, {"id": 234, "string": "Furthermore, we present experimental results using the log D human for stochastic (minibatch) gradient descent optimization of the counterfactual objectives introduced in equations 4, 6, 7 and 8."}, {"id": 235, "string": "For the tokenlevel feedback, we map the evaluated statements back to the corresponding tokens in the original query and assign these tokens a feedback of 0 if the corresponding statement was marked as wrong and 1 otherwise."}, {"id": 236, "string": "In the case of sequence-level feedback, the query receives a feedback of 1 if all statements are marked correct, 0 otherwise."}, {"id": 237, "string": "For the OSL objectives, a separate experiment (see below) showed that updating the reweighting constant after every validation step promises the best trade-off between performance and speed."}, {"id": 238, "string": "Results, averaged over 3 runs, are reported in Table 3 ."}, {"id": 239, "string": "The B2S model can slightly improve upon the baseline but not significantly."}, {"id": 240, "string": "DPM improves further, significantly beating the baseline."}, {"id": 241, "string": "Using the multiplicative control variate modified for SGD by OSL updates does not seem to help in this setup."}, {"id": 242, "string": "By moving to token-level rewards, it is possible to learn from partially correct queries."}, {"id": 243, "string": "These partially correct queries provide valuable information that is not present in the subset of correct answers employed by the previous models."}, {"id": 244, "string": "Optimizing DPM+T leads to a slight improvement and combined with the multiplicative control variate, DPM+T+OSL yields an improvement of about 1.0 in F1 score upon the baseline."}, {"id": 245, "string": "It beats both the baseline and the B2S model by a significant margin."}, {"id": 246, "string": "Learning from Large-Scale Simulated Feedback."}, {"id": 247, "string": "We want to investigate whether the results scale if a larger log is used."}, {"id": 248, "string": "Thus, we use \u03c0 0 to parse all 22,765 questions from D log and obtain for each an output query."}, {"id": 249, "string": "For sequence level rewards, we assign feedback of 1 for a query if it is identical to the true target query, 0 otherwise."}, {"id": 250, "string": "We also simulate token-level rewards by iterating over the indices of the output and assigning a feedback of 1 if the same token appears at the current index for the true target query, 0 otherwise."}, {"id": 251, "string": "An analysis of D log shows that 46.27% of the queries have a sequence level reward of 1 and are Table 4 ."}, {"id": 252, "string": "We see that the B2S model outperforms the baseline model by a large margin, yielding an increase in F1 score by 6.24 points."}, {"id": 253, "string": "Optimizing the DPM objective also yields a significant increase over the baseline, but its performance falls short of the stronger B2S baseline."}, {"id": 254, "string": "Optimizing the DPM+OSL objective leads to a substantial improvement in F1 score over optimizing DPM but still falls slightly short of the strong B2S baseline."}, {"id": 255, "string": "Token-level rewards are again crucial to beat the B2S baseline significantly."}, {"id": 256, "string": "DPM+T is already able to significantly outperform B2S in this setup and DPM+T+OSL can improve upon this further."}, {"id": 257, "string": "tained the correct answer and the baseline system did not (see Table 5 )."}, {"id": 258, "string": "The analysis showed that the vast majority of previously wrong queries were fixed by correcting an OSM tag in the query."}, {"id": 259, "string": "For example, for the question \"closest Florist from Manchester in walking distance\" the baseline system chose the tag \"landuse : retail\" in the query, whereas DPM+T+OSL learnt that the correct tag is \"shop : florist\"."}, {"id": 260, "string": "In some cases, the question type had to be corrected, e.g."}, {"id": 261, "string": "the baseline's suggested query returned the location of a point of interest but DPM+T+OSL correctly returns the phone number."}, {"id": 262, "string": "Finally, in a few cases DPM+T+OSL corrected the structure for a query, e.g."}, {"id": 263, "string": "by searching for a point of interest in the east of an area rather than the south."}, {"id": 264, "string": "Analysis OSL Update Variation."}, {"id": 265, "string": "Using the DPM+T+OSL objective and the simulated feedback setup, we vary the frequency of updating the reweighting constant."}, {"id": 266, "string": "Results are reported in Table 6 ."}, {"id": 267, "string": "Calculating the constant only once at the beginning leads to a near identical result in F1 score as not using OSL."}, {"id": 268, "string": "The more frequent update strategies, once or four times per epoch, are more effective."}, {"id": 269, "string": "Both strategies reduce variance further and lead to higher F1 scores."}, {"id": 270, "string": "Updating four times per epoch compared to once per epoch, leads to a nominally higher performance in F1."}, {"id": 271, "string": "It has the additional benefit that the re-calculation is done at the same time as the validation, leading to no additional slow down as executing the queries for the development set against the database takes longer than the re-calculation of the constant."}, {"id": 272, "string": "Updating after every minibatch is infeasible as it slows down training too much."}, {"id": 273, "string": "Compared to the previous setup, iterating over one epoch takes approximately an additional 5.5 hours."}, {"id": 274, "string": "Conclusion We introduced a scenario for improving a neural semantic parser from logged bandit feedback."}, {"id": 275, "string": "This scenario is important to avoid complex and costly data annotation for supervise learning, and it is realistic in commercial applications where weak feedback can be collected easily in large amounts from users."}, {"id": 276, "string": "We presented robust counterfactual learning objectives that allow to perform stochastic gradient optimization which is crucial in working with neural networks."}, {"id": 277, "string": "Furthermore, we showed that it is essential to obtain reward signals at the token-level in order to learn from partially correct queries."}, {"id": 278, "string": "We presented experimental results using feedback collected from humans and a larger scale setup with simulated feedback."}, {"id": 279, "string": "In both cases we show that a strong baseline using a bandit-to-supervised conversion can be significantly outperformed by a combination of a onestep-late reweighting and token-level rewards."}, {"id": 280, "string": "Finally, our approach to collecting feedback can also be transferred to other domains."}, {"id": 281, "string": "For example, (Yih et al., 2016) designed a user interface to help Freebase experts to efficiently create queries."}, {"id": 282, "string": "This interface could be reversed: given a question and a query produced by a parser, the interface is filled out automatically and the user has to verify if the information fits."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 35}, {"section": "Related Work", "n": "2", "start": 36, "end": 60}, {"section": "Neural Semantic Parsing", "n": "3", "start": 61, "end": 85}, {"section": "Counterfactual Learning from Deterministic Bandit Logs", "n": "4", "start": 86, "end": 130}, {"section": "Semantic Parsing in the OpenStreetMap Domain", "n": "5", "start": 131, "end": 195}, {"section": "Experiments", "n": "6", "start": 196, "end": 273}, {"section": "Conclusion", "n": "7", "start": 274, "end": 282}], "figures": [{"filename": "../figure/image/1346-Table2-1.png", "caption": "Table 2: Corpus statistics of the questionanswering corpora NLMAPS and our extension NLMAPS V2 which additionally contains the search engine style queries (Lawrence and Riezler, 2016) and the automatic extensions of the most common OSM tags.", "page": 5, "bbox": {"x1": 306.71999999999997, "x2": 523.1999999999999, "y1": 62.4, "y2": 156.0}}, {"filename": "../figure/image/1346-Figure2-1.png", "caption": "Figure 2: The user interface for collecting feedback from humans with an example question and a correctly filled out form.", "page": 5, "bbox": {"x1": 76.8, "x2": 282.24, "y1": 61.44, "y2": 256.32}}, {"filename": "../figure/image/1346-Figure1-1.png", "caption": "Figure 1: Left: Online reinforcement learning setup for semantic parsing setup where both questions and gold answers are available. The parser attempts to find correct machine readable parses (MRPs) by producing multiple parses, obtaining corresponding answers, and comparing them against the gold answer. Right: In our setup, a question does not have an associated gold answer. The parser outputs a single MRP and the corresponding answer is shown to a user who provides some feedback. Such triplets are collected in a log which can be used for offline training of a semantic parser. This scenario is called counterfactual since the feedback was logged for outputs from a system different from the target system to be optimized.", "page": 1, "bbox": {"x1": 72.0, "x2": 526.0799999999999, "y1": 62.879999999999995, "y2": 189.12}}, {"filename": "../figure/image/1346-Table4-1.png", "caption": "Table 4: Simulated Feedback: Answer F1 scores on the test set for the various setups, averaged over 3 runs. Statistical significance of system differences at p < 0.05 are indicated by experiment number in superscript.", "page": 7, "bbox": {"x1": 307.68, "x2": 522.24, "y1": 262.56, "y2": 370.08}}, {"filename": "../figure/image/1346-Table3-1.png", "caption": "Table 3: Human Feedback: Answer F1 scores on the test set for the various setups, averaged over 3 runs. Statistical significance of system differences at p < 0.05 are indicated by experiment number in superscript.", "page": 7, "bbox": {"x1": 314.88, "x2": 515.04, "y1": 62.4, "y2": 169.92}}, {"filename": "../figure/image/1346-Table1-1.png", "caption": "Table 1: Gradients of counterfactual objectives.", "page": 3, "bbox": {"x1": 81.6, "x2": 515.04, "y1": 48.48, "y2": 168.0}}, {"filename": "../figure/image/1346-Table6-1.png", "caption": "Table 6: Simulated Feedback: Answer F1 scores on the test set for DPM+T and DPM+T+OSL with varying OSL update strategies, averaged over 3 runs. Updating after every minibatch is infeasible as it significantly slows down learning. Statistical significance of system differences at p < 0.05 occur for experiment 4 over experiment 2.", "page": 8, "bbox": {"x1": 312.0, "x2": 518.4, "y1": 62.4, "y2": 169.92}}, {"filename": "../figure/image/1346-Table5-1.png", "caption": "Table 5: Analysis of which type of errors DPM+T+OSL corrected on the test set compared to the baseline system for both human and simulated feedback experiments.", "page": 8, "bbox": {"x1": 90.72, "x2": 268.32, "y1": 62.879999999999995, "y2": 129.12}}]}