{"title": "Linear-Time Constituency Parsing with RNNs and Dynamic Programming", "abstract": "Recently, span-based constituency parsing has achieved competitive accuracies with extremely simple models by using bidirectional RNNs to model \"spans\". However, the minimal span parser of Stern et al. (2017a) which holds the current state of the art accuracy is a chart parser running in cubic time, O(n 3 ), which is too slow for longer sentences and for applications beyond sentence boundaries such as end-toend discourse parsing and joint sentence boundary detection and parsing. We propose a linear-time constituency parser with RNNs and dynamic programming using graph-structured stack and beam search, which runs in time O(nb 2 ) where b is the beam size. We further speed this up to O(nb log b) by integrating cube pruning. Compared with chart parsing baselines, this linear-time parser is substantially faster for long sentences on the Penn Treebank and orders of magnitude faster for discourse parsing, and achieves the highest F1 accuracy on the Penn Treebank among single model end-to-end systems.", "text": [{"id": 0, "string": "Introduction Span-based neural constituency parsing (Cross and Huang, 2016; Stern et al., 2017a) has attracted attention due to its high accuracy and extreme simplicity."}, {"id": 1, "string": "Compared with other recent neural constituency parsers (Dyer et al., 2016; Liu and Zhang, 2016; Durrett and Klein, 2015) which use neural networks to model tree structures, the spanbased framework is considerably simpler, only using bidirectional RNNs to model the input sequence and not the output tree."}, {"id": 2, "string": "Because of this factorization, the output space is decomposable which enables efficient dynamic programming algorithm such as CKY."}, {"id": 3, "string": "But existing span-based parsers suffer from a crucial limitation in terms of search: on the one hand, a greedy span parser (Cross and Huang, 2016 ) is fast (linear-time) but only explores one single path in the exponentially large search space, and on the other hand, a chartbased span parser (Stern et al., 2017a) performs exact search and achieves state-of-the-art accuracy, but in cubic time, which is too slow for longer sentences and for applications that go beyond sentence boundaries such as end-to-end discourse parsing (Hernault et al., 2010; Zhao and Huang, 2017) and integrated sentence boundary detection and parsing (Bj\u00f6rkelund et al., 2016) ."}, {"id": 4, "string": "We propose to combine the merits of both greedy and chart-based approaches and design a linear-time span-based neural parser that searches over exponentially large space."}, {"id": 5, "string": "Following Huang and Sagae (2010) , we perform left-to-right dynamic programming in an action-synchronous style, with (2n \u2212 1) actions (i.e., steps) for a sentence of n words."}, {"id": 6, "string": "While previous non-neural work in this area requires sophisticated features (Huang and Sagae, 2010; Mi and Huang, 2015) and thus high time complexity such as O(n 11 ), our states are as simple as : (i, j) where is the step index and (i, j) is the span, modeled using bidirectional RNNs without any syntactic features."}, {"id": 7, "string": "This gives a running time of O(n 4 ), with the extra O(n) for step index."}, {"id": 8, "string": "We further employ beam search to have a practical runtime of O(nb 2 ) at the cost of exact search where b is the beam size."}, {"id": 9, "string": "However, on the Penn Treebank, most sentences are less than 40 words (n < 40), and even with a small beam size of b = 10, the observed complexity of an O(nb 2 ) parser is not exactly linear in n (see Experiments)."}, {"id": 10, "string": "To solve this problem, we apply cube pruning (Chiang, 2007; Huang and Chiang, 2007) to improve the runtime to O(nb log b) which renders an observed complexity that is linear in n (with minor extra inexactness)."}, {"id": 11, "string": "We make the following contributions: \u2022 We design the first neural parser that is both linear time and capable of searching over exponentially large space."}, {"id": 12, "string": "1 \u2022 We are the first to apply cube pruning to incremental parsing, and achieves, for the first time, the complexity of O(nb log b), i.e., linear in sentence length and (almost) linear in beam size."}, {"id": 13, "string": "This leads to an observed complexity strictly linear in sentence length n. \u2022 We devise a novel loss function which penalizes wrong spans that cross gold-tree spans, and employ max-violation update (Huang et al., 2012) to train this parser with structured SVM and beam search."}, {"id": 14, "string": "\u2022 Compared with chart parsing baselines, our parser is substantially faster for long sentences on the Penn Treebank, and orders of magnitude faster for end-to-end discourse parsing."}, {"id": 15, "string": "It also achieves the highest F1 score on the Penn Treebank among single model end-to-end systems."}, {"id": 16, "string": "\u2022 We devise a new formulation of graphstructured stack (Tomita, 1991) which requires no extra bookkeeping, proving a new theorem that gives deep insight into GSS."}, {"id": 17, "string": "Preliminaries Span-Based Shift-Reduce Parsing A span-based shift-reduce constituency parser (Cross and Huang, 2016 ) maintains a stack of spans (i, j), and progressively adds a new span each time it takes a shift or reduce action."}, {"id": 18, "string": "With (i, j) on top of the stack, the parser can either shift to push the next singleton span (j, j + 1) on the stack, or it can reduce to combine the top two spans, (k, i) and (i, j), forming the larger span (k, j)."}, {"id": 19, "string": "After each shift/reduce action, the top-most span is labeled as either a constituent or with a null label \u2205, which means that the subsequence is not a subtree in the final decoded parse."}, {"id": 20, "string": "Parsing initializes with an empty stack and continues until (0, n) is formed, representing the entire sentence."}, {"id": 21, "string": "shift : , j : (c, ) + 1 : j, j + 1 : (c + \u03be, \u03be) j < n reduce : k, i : (c , v ) : i, j : ( , v) + 1 : k, j : (c + v + \u03c3, v + v + \u03c3) Figure 1: Our shift-reduce deductive system."}, {"id": 22, "string": "Here is the step index, c and v are prefix and inside scores."}, {"id": 23, "string": "Unlike Huang and Sagae (2010) and Cross and Huang (2016) , \u03be and \u03c3 are not shift/reduce scores; instead, they are the (best) label scores of the resulting span: \u03be = max X s(j, j + 1, X) and \u03c3 = max X s(k, j, X) where X is a nonterminal symbol (could be \u2205)."}, {"id": 24, "string": "Here = \u2212 2(j \u2212 i) + 1."}, {"id": 25, "string": "Bi-LSTM features To get the feature representation of a span (i, j), we use the output sequence of a bi-directional LSTM (Cross and Huang, 2016; Stern et al., 2017a) ."}, {"id": 26, "string": "The LSTM produces f 0 , ..., f n forwards and b n , ..., b 0 backwards outputs, which we concatenate the differences of (f j \u2212f i ) and (b i \u2212b j ) as the representation for span (i, j)."}, {"id": 27, "string": "This eliminates the need for complex feature engineering, and can be stored for efficient querying during decoding."}, {"id": 28, "string": "Dynamic Programming Score Decomposition Like Stern et al."}, {"id": 29, "string": "(2017a) , we also decompose the score of a tree t to be the sum of the span scores: s(t) = (i,j,X)\u2208t s(i, j, X) (1) = (i,j)\u2208t max X s((f j \u2212 f i ; b i \u2212 b j ), X) (2) Note that X is a nonterminal label, a unary chain (e.g., S-VP), or null label \u2205."}, {"id": 30, "string": "2 In a shift-reduce setting, there are 2n \u2212 1 steps (n shifts and n \u2212 1 reduces) and after each step we take the best label for the resulting span; therefore there are exactly 2n\u22121 such (labeled) spans (i, j, X) in tree t. Also note that the choice of the label for any span (i, j) is only dependent on (i, j) itself (and not depending on any subtree information), thus the max over label X is independent of other spans, which is a nice property of span-based parsing (Cross and Huang, 2016; Stern et al., 2017a) ."}, {"id": 31, "string": "Graph-Struct."}, {"id": 32, "string": "Stack w/o Bookkeeping We now reformulate this DP parser in the above section as a shift-reduce parser."}, {"id": 33, "string": "We maintain a step index in order to perform action-synchronous beam search (see below)."}, {"id": 34, "string": "Figure 1 shows how to represent a parsing stack using only the top span (i, j)."}, {"id": 35, "string": "If the top span (i, j) shifts, it produces (j, j + 1), but if it reduces, it needs to know the second last span on the stack, (k, i), which is not represented in the current state."}, {"id": 36, "string": "This problem can be solved by graph-structure stack (Tomita, 1991; Huang and Sagae, 2010) , which maintains, for each state p, a set of predecessor states \u03c0(p) that p can combine with on the left."}, {"id": 37, "string": "This is the way our actual code works (\u03c0(p) is implemented as a list of pointers, or \"left pointers\"), but here for simplicity of presentation we devise a novel but easier-to-understand formulation in Fig."}, {"id": 38, "string": "1 , where we explicitly represent the set of predecessor states that state : (i, j) can combine with as : (k, i) where = \u2212 2(j \u2212 i) + 1, i.e., (i, j) at step can combine with any (k, i) for any k at step ."}, {"id": 39, "string": "The rationale behind this new formulation is the following theorem: Theorem 1 The predecessor states \u03c0( : (i, j)) are all in the same step = \u2212 2(j \u2212 i) + 1."}, {"id": 40, "string": "Proof."}, {"id": 41, "string": "By induction."}, {"id": 42, "string": "This Theorem bring new and deep insights and suggests an alternative implementation that does not require any extra bookkeeping."}, {"id": 43, "string": "The time complexity of this algorithm is O(n 4 ) with the extra O(n) due to step index."}, {"id": 44, "string": "3 Action-Synchronous Beam Search The incremental nature of our parser allows us to further lower the runtime complexity at the cost of inexact search."}, {"id": 45, "string": "At each time step, we maintain the top b parsing states, pruning off the rest."}, {"id": 46, "string": "Thus, a candidate parse that made it to the end of decoding had to survive within the top b at every step."}, {"id": 47, "string": "With O(n) parsing actions our time complexity becomes linear in the length of the sentence."}, {"id": 48, "string": "Cube Pruning However, Theorem 1 suggests that a parsing state p can have up to b predecessor states (\"left pointers\"), i.e., |\u03c0(p)| \u2264 b because \u03c0(p) are all in the same step, a reduce action can produce up to b subsequent new reduced states."}, {"id": 49, "string": "With b items on a beam and O(n) actions to take, this gives us an overall complexity of O(nb 2 )."}, {"id": 50, "string": "Even though b 2 is a constant, even modest values of b can make b 2 dominate the length of the sentence."}, {"id": 51, "string": "4 To improve this at the cost of additional inexactness, we introduce cube pruning to our beam search, where we put candidate actions into a heap and retrieve the top b states to be considered in the next time-step."}, {"id": 52, "string": "We heapify the top b shiftmerged states and the top b reduced states."}, {"id": 53, "string": "To avoid inserting all b 2 reduced states from the previous beam, we only consider each state's highest scoring left pointer, 5 and whenever we pop a reduced state from the heap, we iterate down its left pointers to insert the next non-duplicate reduced state back into the heap."}, {"id": 54, "string": "This process finishes when we pop b items from the heap."}, {"id": 55, "string": "The Training We use a Structured SVM approach for training (Stern et al., 2017a; Shi et al., 2017) ."}, {"id": 56, "string": "We want the model to score the gold tree t * higher than any other tree t by at least a margin \u2206(t, t * ): \u2200t, s(t * ) \u2212 s(t) \u2265 \u2206(t, t * )."}, {"id": 57, "string": "Note that \u2206(t, t) = 0 for any t and \u2206(t, t * ) > 0 for any t = t * ."}, {"id": 58, "string": "At training time we perform lossaugmented decoding: t = arg max t s \u2206 (t) = arg max t s(t) + \u2206(t, t * )."}, {"id": 59, "string": "4 The average length of a sentence in the Penn Treebank training set is about 24."}, {"id": 60, "string": "Even with a beam size of 10, we already have b 2 = 100, which would be a significant factor in our runtime."}, {"id": 61, "string": "In practice, each parsing state will rarely have the maximum b left pointers so this ends up being a loose upper-bound."}, {"id": 62, "string": "Nevertheless, the beam search should be performed with the input length in mind, or else as b increases we risk losing a linear runtime."}, {"id": 63, "string": "5 If each previous beam is sorted, and if the beam search is conducted by going top-to-bottom, then each state's left pointers will implicitly be kept in sorted order."}, {"id": 64, "string": "where s \u2206 (\u00b7) is the loss-augmented score."}, {"id": 65, "string": "Ift = t * , then all constraints are satisfied (which implies arg max t s(t) = t * ), otherwise we perform an update by backpropagating from s \u2206 (t) \u2212 s(t * )."}, {"id": 66, "string": "Cross-Span Loss The baseline loss function from Stern et al."}, {"id": 67, "string": "(2017a) counts the incorrect labels (i, j, X) in the predicted tree: \u2206 base (t, t * ) = (i,j,X)\u2208t 1 X = t * (i,j) ."}, {"id": 68, "string": "Note that X can be null \u2205, and t * (i,j) denotes the gold label for span (i, j), which could also be \u2205."}, {"id": 69, "string": "6 However, there are two cases where t * (i,j) = \u2205: a subspan (i, j) due to binarization (e.g., a span combining the first two subtrees in a ternary branching node), or an invalid span in t that crosses a gold span in t * ."}, {"id": 70, "string": "In the baseline function above, these two cases are treated equivalently; for example, a span (3, 5, \u2205) \u2208 t is not penalized even if there is a gold span (4, 6, VP) \u2208 t * ."}, {"id": 71, "string": "So we revise our loss function as: \u2206 new (t, t * ) = (i,j,X)\u2208t 1 X = t * (i,j) \u2228 cross(i, j, t * ) 6 Note that the predicted tree t has exactly 2n \u2212 1 spans but t * has much fewer spans (only labeled spans without \u2205)."}, {"id": 72, "string": "where cross(i, j, t * ) = \u2203 (k, l) \u2208 t * , and i < k < j < l or k < i < l < j. Max Violation Updates Given that we maintain loss-augmented scores even for partial trees, we can perform a training update on a given example sentence by choosing to take the loss where it is the greatest along the parse trajectory."}, {"id": 73, "string": "At each parsing time-step , the violation is the difference between the highest augmented-scoring parse trajectory up to that point and the gold trajectory (Huang et al., 2012; Yu et al., 2013) ."}, {"id": 74, "string": "Note that computing the violation gives us the max-margin loss described above."}, {"id": 75, "string": "Taking the largest violation from all time-steps gives us the max-violation loss."}, {"id": 76, "string": "Experiments We present experiments on the Penn Treebank (Marcus et al., 1993) and the PTB-RST discourse treebank (Zhao and Huang, 2017) ."}, {"id": 77, "string": "In both cases, the training set is shuffled before each epoch, and dropout (Hinton et al., 2012) is employed with probability 0.4 to the recurrent outputs for regularization."}, {"id": 78, "string": "Updates with minibatches of size 10 and 1 are used for PTB and the PTB-RST respectively."}, {"id": 79, "string": "We use Adam (Kingma and Ba, 2014) with default settings to schedule learning rates for all the weights."}, {"id": 80, "string": "To address unknown words during training, we adopt the strategy described by Kiperwasser and Goldberg (Kiperwasser and Goldberg, 2016) ; words in the training set are replaced with the unknown word symbol UNK with probability p unk = Socher et al."}, {"id": 81, "string": "(2013) 90.4 Durrett and Klein (2015) 91.1 Cross and Huang (2016) 90.  occurrences of word w in the training corpus."}, {"id": 82, "string": "Our system is implemented in Python using the DyNet neural network library (Neubig et al., 2017) ."}, {"id": 83, "string": "Penn Treebank We use the Wall Street Journal portion of the Penn Treebank, with the standard split of sections 2-21 for training, 22 for development, and 23 for testing."}, {"id": 84, "string": "Tags are provided using the Stanford tagger with 10-way jackknifing."}, {"id": 85, "string": "Table 1 shows our development results and overall speeds, while Table 2 compares our test results."}, {"id": 86, "string": "We show that a beam size of 20 can be fast while still achieving state-of-the-art performances."}, {"id": 87, "string": "Discourse Parsing To measure the tractability of parsing on longer sequences, we also consider experiments on the Table 3 , broken down to focus on the discourse labels."}, {"id": 88, "string": "PTB-RST discourse Treebank, a joint discourse and constituency dataset with a combined representation, allowing for parsing at either level (Zhao and Huang, 2017) ."}, {"id": 89, "string": "We compare our runtimes out-of-the-box in Figure 3 ."}, {"id": 90, "string": "Without any pre-processing, and by treating discourse examples as constituency trees with thousands of words, our trained models represent end-to-end discourse parsing systems."}, {"id": 91, "string": "For our overall constituency results in Table 3 , and for discourse results in Table 4 , we adapt the split-point feature described in (Zhao and Huang, 2017) in addition to the base parser."}, {"id": 92, "string": "We find that larger beamsizes are required to achieve good discourse scores."}, {"id": 93, "string": "Conclusions We have developed a new neural parser that maintains linear time, while still searching over an exponentially large space."}, {"id": 94, "string": "We also use cube pruning to further improve the runtime to O(nb log b)."}, {"id": 95, "string": "For training, we introduce a new loss function, and achieve state-of-the-art results among singlemodel end-to-end systems."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 16}, {"section": "Span-Based Shift-Reduce Parsing", "n": "2.1", "start": 17, "end": 24}, {"section": "Bi-LSTM features", "n": "2.2", "start": 25, "end": 27}, {"section": "Score Decomposition", "n": "3.1", "start": 28, "end": 31}, {"section": "Graph-Struct. Stack w/o Bookkeeping", "n": "3.2", "start": 32, "end": 43}, {"section": "Action-Synchronous Beam Search", "n": "3.3", "start": 44, "end": 47}, {"section": "Cube Pruning", "n": "3.4", "start": 48, "end": 54}, {"section": "Training", "n": "4", "start": 55, "end": 65}, {"section": "Cross-Span Loss", "n": "4.1", "start": 66, "end": 71}, {"section": "Max Violation Updates", "n": "4.2", "start": 72, "end": 75}, {"section": "Experiments", "n": "5", "start": 76, "end": 82}, {"section": "Penn Treebank", "n": "5.1", "start": 83, "end": 86}, {"section": "Discourse Parsing", "n": "5.2", "start": 87, "end": 91}, {"section": "Conclusions", "n": "6", "start": 92, "end": 95}], "figures": [{"filename": "../figure/image/1224-Table1-1.png", "caption": "Table 1: Comparison of PTB development set results, with the time measured in seconds-persentence. The baseline chart parser is from Stern et al. (2017b), with null-label scores unconstrained to be nonzero, replicating their paper.", "page": 4, "bbox": {"x1": 73.92, "x2": 289.44, "y1": 62.879999999999995, "y2": 150.23999999999998}}, {"filename": "../figure/image/1224-Table4-1.png", "caption": "Table 4: F1 scores comparing discourse systems. Results correspond to the accuracies in Table 3, broken down to focus on the discourse labels.", "page": 4, "bbox": {"x1": 308.64, "x2": 524.16, "y1": 216.48, "y2": 281.28}}, {"filename": "../figure/image/1224-Table2-1.png", "caption": "Table 2: Final PTB Test Results. We compare our models with other (neural) single-model end-toend trained systems.", "page": 4, "bbox": {"x1": 73.92, "x2": 289.44, "y1": 240.48, "y2": 444.0}}, {"filename": "../figure/image/1224-Table3-1.png", "caption": "Table 3: Overall test accuracies for PTB-RST discourse treebank. Starred? rows indicate a run that was decoded from the beam 200 model.", "page": 4, "bbox": {"x1": 308.64, "x2": 523.1999999999999, "y1": 62.879999999999995, "y2": 155.04}}, {"filename": "../figure/image/1224-Figure1-1.png", "caption": "Figure 1: Our shift-reduce deductive system. Here ` is the step index, c and v are prefix and inside scores. Unlike Huang and Sagae (2010) and Cross and Huang (2016), \u03be and \u03c3 are not shift/reduce scores; instead, they are the (best) label scores of the resulting span: \u03be = maxX s(j, j+1, X) and \u03c3 = maxX s(k, j,X) where X is a nonterminal symbol (could be \u2205). Here `\u2032 = `\u2212 2(j \u2212 i) + 1.", "page": 1, "bbox": {"x1": 314.88, "x2": 515.04, "y1": 64.32, "y2": 208.32}}, {"filename": "../figure/image/1224-Figure3-1.png", "caption": "Figure 3: Runtime plot of decoding the discourse treebank training set. The log-log plot on the right shows the cubic complexity of baseline chart parsing. Whereas beam search decoding maintains linear time even for sequences of thousands of words.", "page": 3, "bbox": {"x1": 309.59999999999997, "x2": 522.24, "y1": 64.8, "y2": 202.56}}, {"filename": "../figure/image/1224-Figure2-1.png", "caption": "Figure 2: Runtime plots of decoding on the training set of the Penn Treebank. The differences between the different algorithms become evident after sentences of length 40. The regression curves have been empirically fitted.", "page": 3, "bbox": {"x1": 84.47999999999999, "x2": 278.4, "y1": 64.8, "y2": 259.68}}]}