{"title": "Policy Gradient as a Proxy for Dynamic Oracles in Constituency Parsing", "abstract": "Dynamic oracles provide strong supervision for training constituency parsers with exploration, but must be custom defined for a given parser's transition system. We explore using a policy gradient method as a parser-agnostic alternative. In addition to directly optimizing for a tree-level metric such as F1, policy gradient has the potential to reduce exposure bias by allowing exploration during training; moreover, it does not require a dynamic oracle for supervision. On four constituency parsers in three languages, the method substantially outperforms static oracle likelihood training in almost all settings. For parsers where a dynamic oracle is available (including a novel oracle which we define for the transition system of Dyer et al. (2016) ), policy gradient typically recaptures a substantial fraction of the performance gain afforded by the dynamic oracle.", "text": [{"id": 0, "string": "Introduction Many recent state-of-the-art models for constituency parsing are transition based, decomposing production of each parse tree into a sequence of action decisions Cross and Huang, 2016; Liu and Zhang, 2017; , building on a long line of work in transition-based parsing (Nivre, 2003; Yamada and Matsumoto, 2003; Henderson, 2004; Zhang and Clark, 2011; Chen and Manning, 2014; Andor et al., 2016; Kiperwasser and Goldberg, 2016) ."}, {"id": 1, "string": "However, models of this type, which decompose structure prediction into sequential decisions, can be prone to two issues (Ranzato et al., 2016; Wiseman and Rush, 2016) ."}, {"id": 2, "string": "The first is exposure bias: if, at training time, the model only observes states resulting from correct past decisions, it will not be prepared to recover from its own mistakes during prediction."}, {"id": 3, "string": "Second is the loss mismatch between the action-level loss used at training and any structure-level evaluation metric, for example F1."}, {"id": 4, "string": "A large family of techniques address the exposure bias problem by allowing the model to make mistakes and explore incorrect states during training, supervising actions at the resulting states using an expert policy (Daum\u00e9 III et al., 2009; Ross et al., 2011; Choi and Palmer, 2011; Chang et al., 2015) ; these expert policies are typically referred to as dynamic oracles in parsing (Goldberg and Nivre, 2012; ."}, {"id": 5, "string": "While dynamic oracles have produced substantial improvements in constituency parsing performance (Coavoux and Crabb\u00e9, 2016; Cross and Huang, 2016; Gonz\u00e1lez and G\u00f3mez-Rodr\u00edguez, 2018) , they must be custom designed for each transition system."}, {"id": 6, "string": "To address the loss mismatch problem, another line of work has directly optimized for structurelevel cost functions (Goodman, 1996; Och, 2003) ."}, {"id": 7, "string": "Recent methods applied to models that produce output sequentially commonly use policy gradient (Auli and Gao, 2014; Ranzato et al., 2016; Shen et al., 2016) or beam search (Xu et al., 2016; Wiseman and Rush, 2016; Edunov et al., 2017) at training time to minimize a structured cost."}, {"id": 8, "string": "These methods also reduce exposure bias through exploration but do not require an expert policy for supervision."}, {"id": 9, "string": "In this work, we apply a simple policy gradient method to train four different state-of-theart transition-based constituency parsers to maximize expected F1."}, {"id": 10, "string": "We compare against training with a dynamic oracle (both to supervise exploration and provide loss-augmentation) where one is available, including a novel dynamic oracle that we define for the top-down transition system of ."}, {"id": 11, "string": "We find that while policy gradient usually outperforms standard likelihood training, it typically underperforms the dynamic oracle-based methods -which provide direct, model-aware supervision about which actions are best to take from arbitrary parser states."}, {"id": 12, "string": "However, a substantial fraction of each dynamic oracle's performance gain is often recovered using the model-agnostic policy gradient method."}, {"id": 13, "string": "In the process, we obtain new state-of-the-art results for single-model discriminative transition-based parsers trained on the English PTB (92.6 F1), French Treebank (83.5 F1), and Penn Chinese Treebank Version 5.1 (87.0 F1)."}, {"id": 14, "string": "Models The transition-based parsers we use all decompose production of a parse tree y for a sentence x into a sequence of actions (a 1 , ."}, {"id": 15, "string": "."}, {"id": 16, "string": "."}, {"id": 17, "string": "a T ) and resulting states (s 1 , ."}, {"id": 18, "string": "."}, {"id": 19, "string": "."}, {"id": 20, "string": "s T +1 )."}, {"id": 21, "string": "Actions a t are predicted sequentially, conditioned on a representation of the parser's current state s t and parameters \u03b8: p(y|x; \u03b8) = T t=1 p(a t | s t ; \u03b8) (1) We investigate four parsers with varying transition systems and methods of encoding the current state and sentence: (1) the discriminative Recurrent Neural Network Grammars (RNNG) parser of , (2) the In-Order parser of Liu and Zhang (2017) , (3) the Span-Based parser of Cross and Huang (2016) , and (4) the Top-Down parser of ."}, {"id": 22, "string": "1 We refer to the original papers for descriptions of the transition systems and model parameterizations."}, {"id": 23, "string": "Training Procedures Likelihood training without exploration maximizes Eq."}, {"id": 24, "string": "1 for trees in the training corpus, but may be prone to exposure bias and loss mismatch (Section 1)."}, {"id": 25, "string": "Dynamic oracle methods are known to improve on this training procedure for a variety of parsers (Coavoux and Crabb\u00e9, 2016; Cross and Huang, 2016; Gonz\u00e1lez and G\u00f3mez-Rodr\u00edguez, 2018) , supervising exploration during training by providing the parser with the best action to take at each explored state."}, {"id": 26, "string": "We describe how policy gradient can be applied as an oracle-free alternative."}, {"id": 27, "string": "We then compare to several variants of dynamic oracle training which focus on addressing exposure bias, loss mismatch, or both."}, {"id": 28, "string": "Policy Gradient Given an arbitrary cost function \u2206 comparing structured outputs (e.g."}, {"id": 29, "string": "negative labeled F1, for trees), we use the risk objective: R(\u03b8) = N i=1 y p(y | x (i) ; \u03b8)\u2206(y, y (i) ) which measures the model's expected cost over possible outputs y for each of the training examples (x (1) , y (1) ), ."}, {"id": 30, "string": "."}, {"id": 31, "string": "."}, {"id": 32, "string": ", (x (N ) , y (N ) )."}, {"id": 33, "string": "Minimizing a risk objective has a long history in structured prediction (Povey and Woodland, 2002; Smith and Eisner, 2006; Li and Eisner, 2009; Gimpel and Smith, 2010) but often relies on the cost function decomposing according to the output structure."}, {"id": 34, "string": "However, we can avoid any restrictions on the cost using reinforcement learning-style approaches (Xu et al., 2016; Shen et al., 2016; Edunov et al., 2017) where cost is ascribed to the entire output structure -albeit at the expense of introducing a potentially difficult credit assignment problem."}, {"id": 35, "string": "The policy gradient method we apply is a simple variant of REINFORCE (Williams, 1992) ."}, {"id": 36, "string": "We perform mini-batch gradient descent on the gradient of the risk objective: \u2207R(\u03b8) = N i=1 y p(y|x (i) )\u2206(y, y (i) )\u2207 log p(y|x (i) ; \u03b8) \u2248 N i=1 y\u2208Y(x (i) ) \u2206(y, y (i) )\u2207 log p(y|x (i) ; \u03b8) where Y(x (i) ) is a set of k candidate trees obtained by sampling from the model's distribution for sentence x (i) ."}, {"id": 37, "string": "We use negative labeled F1 for \u2206."}, {"id": 38, "string": "To reduce the variance of the gradient estimates, we standardize \u2206 using its running mean and standard deviation across all candidates used so far throughout training."}, {"id": 39, "string": "Following Shen et al."}, {"id": 40, "string": "(2016) , we also found better performance when including the gold tree y (i) in the set of k candidates Y(x (i) ), and do so for all experiments reported here."}, {"id": 41, "string": "2 Dynamic Oracle Supervision For a given parser state s t , a dynamic oracle defines an action a * (s t ) which should be taken to incrementally produce the best tree still reachable from that state."}, {"id": 42, "string": "3 Dynamic oracles provide strong supervision for training with exploration, but require custom design for a given transition system."}, {"id": 43, "string": "Cross and Huang (2016) and  defined optimal (with respect to F1) dynamic oracles for their respective transition systems, and below we define a novel dynamic oracle for the top-down system of RNNG."}, {"id": 44, "string": "In RNNG, tree production occurs in a stackbased, top-down traversal which produces a leftto-right linearized representation of the tree using three actions: OPEN a labeled constituent (which fixes the constituent's span to begin at the next word in the sentence which has not been shifted), SHIFT the next word in the sentence to add it to the current constituent, or CLOSE the current constituent (which fixes its span to end after the last word that has been shifted)."}, {"id": 45, "string": "The parser stores opened constituents on the stack, and must therefore close them in the reverse of the order that they were opened."}, {"id": 46, "string": "At a given parser state, our oracle does the following: 1."}, {"id": 47, "string": "If there are any open constituents on the stack which can be closed (i.e."}, {"id": 48, "string": "have had a word shifted since being opened), check the topmost of these (the one that has been opened most recently)."}, {"id": 49, "string": "If closing it would produce a constituent from the the gold tree that has not yet been produced (which is determined by the constituent's label, span beginning position, and the number of words currently shifted), or if the constituent could not be closed at a later position in the sentence to produce a constituent in the gold tree, return CLOSE."}, {"id": 50, "string": "the estimate of the risk objective's gradient; however since in the parsing tasks we consider, the gold tree has constant and minimal cost, augmenting with the gold is equivalent to jointly optimizing the standard likelihood and risk objectives, using an adaptive scaling factor for each objective that is dependent on the cost for the trees that have been sampled from the model."}, {"id": 51, "string": "We found that including the gold candidate in this manner outperformed initial experiments that first trained a model using likelihood training and then fine-tuned using unbiased policy gradient."}, {"id": 52, "string": "3 More generally, an oracle can return a set of such actions that could be taken from the current state, but the oracles we use select a single canonical action."}, {"id": 53, "string": "2."}, {"id": 54, "string": "Otherwise, if there are constituents in the gold tree which have not yet been opened in the parser state, with span beginning at the next unshifted word, OPEN the outermost of these."}, {"id": 55, "string": "3."}, {"id": 56, "string": "Otherwise, SHIFT the next word."}, {"id": 57, "string": "While we do not claim that this dynamic oracle is optimal with respect to F1, we find that it still helps substantially in supervising exploration (Section 5)."}, {"id": 58, "string": "Likelihood Training with Exploration Past work has differed on how to use dynamic oracles to guide exploration during oracle training Cross and Huang, 2016; ."}, {"id": 59, "string": "We use the same sample-based method of generating candidate sets Y as for policy gradient, which allows us to control the dynamic oracle and policy gradient methods to perform an equal amount of exploration."}, {"id": 60, "string": "Likelihood training with exploration then maximizes the sum of the log probabilities for the oracle actions for all states composing the candidate trees: L E (\u03b8) = N i=1 y\u2208Y(x (i) ) s\u2208y log p(a * (s) | s) where a * (s) is the dynamic oracle's action for state s. Softmax Margin Softmax margin loss (Gimpel and Smith, 2010; Auli and Lopez, 2011) addresses loss mismatch by incorporating task cost into the training loss."}, {"id": 61, "string": "Since trees are decomposed into a sequence of local action predictions, we cannot use a global cost, such as F1, directly."}, {"id": 62, "string": "As a proxy, we rely on the dynamic oracles' action-level supervision."}, {"id": 63, "string": "In all models we consider, action probabilities (Eq."}, {"id": 64, "string": "1) are parameterized by a softmax function p M L (a | s t ; \u03b8) \u221d exp(z(a, s t , \u03b8)) for some state-action scoring function z."}, {"id": 65, "string": "The softmax-margin objective replaces this by p SM M (a | s t ; \u03b8) \u221d exp(z(a, s t , \u03b8) + \u2206(a, a * t )) (2) We use \u2206(a, a * t ) = 0 if a = a * t and 1 otherwise."}, {"id": 66, "string": "This can be viewed as a \"soft\" version of the maxmargin objective used by  for training without exploration, but retains a locallynormalized model that we can use for samplingbased exploration."}, {"id": 67, "string": "Softmax Margin with Exploration Finally, we train using a combination of softmax margin loss augmentation and exploration."}, {"id": 68, "string": "We perform the same sample-based candidate generation as for policy gradient and likelihood training with exploration, but use Eq."}, {"id": 69, "string": "2 to compute the training loss for candidate states."}, {"id": 70, "string": "For those parsers that have a dynamic oracle, this provides a means of training that more directly provides both exploration and cost-aware losses."}, {"id": 71, "string": "Experiments We compare the constituency parsers listed in Section 2 using the above training methods."}, {"id": 72, "string": "Our experiments use the English PTB (Marcus et al., 1993) , French Treebank (Abeill\u00e9 et al., 2003) , and Penn Chinese Treebank (CTB) Version 5.1 (Xue et al., 2005) ."}, {"id": 73, "string": "Training To compare the training procedures as closely as possible, we train all models for a given parser in a given language from the same randomly-initialized parameter values."}, {"id": 74, "string": "We train two different versions of the RNNG model: one model using size 128 for the LSTMs and hidden states (following the original work), and a larger model with size 256."}, {"id": 75, "string": "We perform evaluation using greedy search in the Span-Based and Top-Down parsers, and beam search with beam size 10 for the RNNG and In-Order parsers."}, {"id": 76, "string": "We found that beam search improved performance for these two parsers by around 0.1-0.3 F1 on the development sets, and use it at inference time in every setting for these two parsers."}, {"id": 77, "string": "In our experiments, policy gradient typically requires more epochs of training to reach performance comparable to either of the dynamic oraclebased exploration methods."}, {"id": 78, "string": "Figure 1 gives a typical learning curve, for the Top-Down parser on English."}, {"id": 79, "string": "We found that policy gradient is also more sensitive to the number of candidates sampled per sentence than either of the other exploration methods, with best performance on the development set usually obtained with k = 10 for k \u2208 {2, 5, 10} (where k also counts the sentence's gold tree, included in the candidate set)."}, {"id": 80, "string": "See Appendix A in the supplemental material for the values of k used."}, {"id": 81, "string": "Tags, Embeddings, and Morphology We largely follow previous work for each parser in our use of predicted part-of-speech tags, pretrained word embeddings, and morphological features."}, {"id": 82, "string": "All parsers use predicted part-of-speech tags as part of their sentence representations."}, {"id": 83, "string": "For English and Chinese, we follow the setup of Cross and Huang (2016) : training the Stanford tagger (Toutanova et al., 2003) on the training set of each parsing corpus to predict development and test set tags, and using 10-way jackknifing to predict tags for the training set."}, {"id": 84, "string": "For French, we use the predicted tags and morphological features provided with the SPMRL dataset (Seddah et al., 2014) ."}, {"id": 85, "string": "We modified the publicly released code for all parsers to use predicted morphological features for French."}, {"id": 86, "string": "We follow the approach outlined by Cross and Huang (2016) and  for representing morphological features as learned embeddings, and use the same dimensions for these embeddings as in their papers."}, {"id": 87, "string": "For RNNG and In-Order, we similarly use 10-dimensional learned embeddings for each morphological feature, feeding them as LSTM inputs for each word alongside the word and part-of-speech tag embeddings."}, {"id": 88, "string": "For RNNG and the In-Order parser, we use the same word embeddings as the original papers for English and Chinese, and train 100-dimensional word embeddings for French using the structured skip-gram method of Ling et al."}, {"id": 89, "string": "(2015) on French Wikipedia."}, {"id": 90, "string": "Table 1 compares parser F1 by training procedure for each language."}, {"id": 91, "string": "Policy gradient improves upon likelihood training in 14 out of 15 cases, with improvements of up to 1.5 F1."}, {"id": 92, "string": "One of the three dynamic oracle-based training methods -either likelihood with exploration, softmax margin (SMM), or softmax margin with exploration -obtains better performance than policy gradient in 10 out of 12 cases."}, {"id": 93, "string": "This is perhaps unsurprising given the strong supervision provided by the dynamic oracles and the credit assignment problem faced by  policy gradient."}, {"id": 94, "string": "However, a substantial fraction of this performance gain is recaptured by policy gradient in most cases."}, {"id": 95, "string": "Results and Discussion While likelihood training with exploration using a dynamic oracle more directly addresses exploration bias, and softmax margin training more directly addresses loss mismatch, these two phenomena are still entangled, and the best dynamic oracle-based method to use varies."}, {"id": 96, "string": "The effectiveness of the oracle method is also likely to be influenced by the nature of the dynamic oracle available for the parser."}, {"id": 97, "string": "For example, the oracle for RNNG lacks F1 optimality guarantees, and softmax margin without exploration often underperforms likelihood for this parser."}, {"id": 98, "string": "However, exploration improves softmax margin training across all parsers and conditions."}, {"id": 99, "string": "Although results from likelihood training are mostly comparable between RNNG-128 and the larger model RNNG-256 across languages, policy gradient and likelihood training with exploration both typically yield larger improvements in the larger models, obtaining 92.6 F1 for English and 86.0 for Chinese (using likelihood training with exploration), although results are slightly higher for the policy gradient and dynamic oracle-based methods for the smaller model on French (including 83.5 with softmax margin with exploration)."}, {"id": 100, "string": "Finally, we observe that policy gradient also provides large improvements for the In-Order parser, where a dynamic oracle has not been defined."}, {"id": 101, "string": "We note that although some of these results (92.6 for English, 83.5 for French, 87.0 for Chinese) are state-of-the-art for single model, discriminative transition-based parsers, other work on constituency parsing achieves better performance through other methods."}, {"id": 102, "string": "Techniques that combine multiple models or add semi-supervised data (Vinyals et al., 2015; Choe and Charniak, 2016; Kuncoro et al., 2017; Liu and Zhang, 2017; Fried et al., 2017) are orthogonal to, and could be combined with, the singlemodel, fixed training data methods we explore."}, {"id": 103, "string": "Other recent work (Gaddy et al., 2018; Kitaev and Klein, 2018) obtains comparable or stronger performance with global chart decoders, where training uses loss augmentation provided by an oracle."}, {"id": 104, "string": "By performing model-optimal global inference, these parsers likely avoid the exposure bias problem of the sequential transition-based parsers we investigate, at the cost of requiring a chart decoding procedure for inference."}, {"id": 105, "string": "Overall, we find that although optimizing for F1 in a model-agnostic fashion with policy gradient typically underperforms the model-aware expert supervision given by the dynamic oracle training methods, it provides a simple method for consistently improving upon static oracle likelihood training, at the expense of increased training costs."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 13}, {"section": "Models", "n": "2", "start": 14, "end": 22}, {"section": "Training Procedures", "n": "3", "start": 23, "end": 27}, {"section": "Policy Gradient", "n": "3.1", "start": 28, "end": 40}, {"section": "Dynamic Oracle Supervision", "n": "3.2", "start": 41, "end": 70}, {"section": "Experiments", "n": "4", "start": 71, "end": 94}, {"section": "Results and Discussion", "n": "5", "start": 95, "end": 105}], "figures": [{"filename": "../figure/image/1206-Table1-1.png", "caption": "Table 1: Test set F1 by training procedure, and in comparison to past work using the same models. Improvements over likelihood training are indicated in parentheses, with the highest results among the training procedures compared here in bold. \u2217: training uses a dynamic oracle; \u2020: past work using a global scoring model (all models we train here are locally-normalized).", "page": 4, "bbox": {"x1": 66.72, "x2": 299.03999999999996, "y1": 62.4, "y2": 388.32}}, {"filename": "../figure/image/1206-Figure1-1.png", "caption": "Figure 1: English development set F1 by training epoch, comparing likelihood training with two exploration variants for the Top-Down parser.", "page": 3, "bbox": {"x1": 73.92, "x2": 290.88, "y1": 62.4, "y2": 144.48}}]}