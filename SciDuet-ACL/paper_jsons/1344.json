{"title": "Interpretable and Compositional Relation Learning by Joint Training with an Autoencoder", "abstract": "Embedding models for entities and relations are extremely useful for recovering missing facts in a knowledge base. Intuitively, a relation can be modeled by a matrix mapping entity vectors. However, relations reside on low dimension sub-manifolds in the parameter space of arbitrary matrices -for one reason, composition of two relations M 1 , M 2 may match a third M 3 (e.g. composition of relations currency of country and country of film usually matches currency of film budget), which imposes compositional constraints to be satisfied by the parameters (i.e. M 1 \u00b7M 2 \u2248 M 3 ). In this paper we investigate a dimension reduction technique by training relations jointly with an autoencoder, which is expected to better capture compositional constraints. We achieve state-of-the-art on Knowledge Base Completion tasks with strongly improved Mean Rank, and show that joint training with an autoencoder leads to interpretable sparse codings of relations, helps discovering compositional constraints and benefits from compositional training. Our source code is released at github.com/tianran/glimvec.", "text": [{"id": 0, "string": "Introduction Broad-coverage knowledge bases (KBs) such as Freebase (Bollacker et al., 2008) and DBPedia (Auer et al., 2007) store a large amount of facts in the form of head entity, relation, tail entity triples (e.g."}, {"id": 1, "string": "The Matrix, country of film, Australia ), which could support a wide range of reasoning and question answering applications."}, {"id": 2, "string": "The Knowledge Base Completion (KBC) task aims Figure 1 : In joint training, relation parameters (e.g."}, {"id": 3, "string": "M 1 ) receive updates from both a KB-learning objective, trying to predict entities in the KB; and a reconstruction objective from an autoencoder, trying to recover relations from low dimension codings."}, {"id": 4, "string": "to predict the missing part of an incomplete triple, such as Finding Nemo, country of film, ?"}, {"id": 5, "string": ", by reasoning from known facts stored in the KB."}, {"id": 6, "string": "As a most common approach (Wang et al., 2017) , modeling entities and relations to operate in a low dimension vector space helps KBC, for three conceivable reasons."}, {"id": 7, "string": "First, when dimension is low, entities modeled as vectors are forced to share parameters, so \"similar\" entities which participate in many relations in common get close to each other (e.g."}, {"id": 8, "string": "Australia close to US)."}, {"id": 9, "string": "This could imply that an entity (e.g."}, {"id": 10, "string": "US) \"type matches\" a relation such as country of film."}, {"id": 11, "string": "Second, relations may share parameters as well, which could transfer facts from one relation to other similar relations, for example from x, award winner, y to x, award nominated, y ."}, {"id": 12, "string": "Third, spatial positions might be used to implement composition of relations, as relations can be regarded as mappings from head to tail entities, and the composition of two maps can match a third (e.g."}, {"id": 13, "string": "the composition of currency of country and country of film matches the relation currency of film budget), which could be captured by modeling composition in a space."}, {"id": 14, "string": "However, modeling relations as mappings naturally requires more parameters -a general linear map between d-dimension vectors is represented by a matrix of d 2 parameters -which are less likely to be shared, impeding transfers of facts between similar relations."}, {"id": 15, "string": "Thus, it is desired to reduce dimensionality of relations; furthermore, the existence of a composition of two relations (assumed to be modeled by matrices M 1 , M 2 ) matching a third (M 3 ) also justifies dimension reduction, because it implies a compositional constraint M 1 \u00b7 M 2 \u2248 M 3 that can be satisfied only by a lower dimension sub-manifold in the parameter space 1 ."}, {"id": 16, "string": "Previous approaches reduce dimensionality of relations by imposing pre-designed hard constraints on the parameter space, such as constraining that relations are translations (Bordes et al., 2013) or diagonal matrices , or assuming they are linear combinations of a small number of prototypes (Xie et al., 2017) ."}, {"id": 17, "string": "However, pre-designed hard constraints do not seem to cope well with compositional constraints, because it is difficult to know a priori which two relations compose to which third relation, hence difficult to choose a pre-design; and compositional constraints are not always exact (e.g."}, {"id": 18, "string": "the composition of currency of country and headquarter location usually matches business operation currency but not always), so hard constraints are less suited."}, {"id": 19, "string": "In this paper, we investigate an alternative approach by training relation parameters jointly with an autoencoder (Figure 1 )."}, {"id": 20, "string": "During training, the autoencoder tries to reconstruct relations from low dimension codings, with the reconstruction objective back-propagating to relation parameters as well."}, {"id": 21, "string": "We show this novel technique promotes parameter sharing between different relations, and drives them toward low dimension manifolds (Sec.6.2)."}, {"id": 22, "string": "Besides, we expect the technique to cope better with compositional constraints, because it discovers low dimension manifolds posteriorly from data, and it does not impose any explicit hard constraints."}, {"id": 23, "string": "1 It is noteworthy that similar compositional constraints apply to most modeling schemes of relations, not just matrices."}, {"id": 24, "string": "Yet, joint training with an autoencoder is not simple; one has to keep a subtle balance between gradients of the reconstruction and KB-learning objectives throughout the training process."}, {"id": 25, "string": "We are not aware of any theoretical principles directly addressing this problem; but we found some important settings after extensive pre-experiments (Sec.4)."}, {"id": 26, "string": "We evaluate our system using standard KBC datasets, achieving state-of-the-art on several of them (Sec.6.1), with strongly improved Mean Rank."}, {"id": 27, "string": "We discuss detailed settings that lead to the performance (Sec.4.1), and we show that joint training with an autoencoder indeed helps discovering compositional constraints (Sec.6.2) and benefits from compositional training (Sec.6.3)."}, {"id": 28, "string": "Base Model A knowledge base (KB) is a set T of triples of the form h, r, t , where h, t \u2208 E are entities and r \u2208 R is a relation (e.g."}, {"id": 29, "string": "The Matrix, country of film, Australia )."}, {"id": 30, "string": "A relation r has its inverse r \u22121 \u2208 R so that for every h, r, t \u2208 T , we regard t, r \u22121 , h as also in the KB."}, {"id": 31, "string": "Under this assumption and given T as training data, we consider the Knowledge Base Completion (KBC) task that predicts candidates for a missing tail entity in an incomplete h, r, ?"}, {"id": 32, "string": "triple."}, {"id": 33, "string": "Most approaches tackle this problem by training a score function measuring the plausibility of triples being facts."}, {"id": 34, "string": "The model we implement in this work represents entities h, t as d-dimension vectors u h , v t respectively, and relation r as a d\u00d7d matrix M r ."}, {"id": 35, "string": "If u h , v t are one-hot vectors with dimension d = |E| corresponding to each entity, one can take M r as the adjacency matrix of entities joined by relation r, so the set of tail entities filling into h, r, ?"}, {"id": 36, "string": "is calculated by u h M r (with each nonzero entry corresponds to an answer)."}, {"id": 37, "string": "Thus, we have u h M r v t > 0 if and only if h, r, t \u2208 T ."}, {"id": 38, "string": "This motivates us to use u h M r v t as a natural parameter to model plausibility of h, r, t , even in a low dimension space with d |E|."}, {"id": 39, "string": "Thus, we define the score function as s(h, r, t) := exp(u h M r v t ) (1) for the basic model."}, {"id": 40, "string": "This is similar to the bilinear model of Nickel et al."}, {"id": 41, "string": "(2011) , except that we distinguish u h (the vector for head entities) from v t (the vector for tail entities)."}, {"id": 42, "string": "It has also been proposed in Tian et al."}, {"id": 43, "string": "(2016) , but for modeling dependency trees rather than KBs."}, {"id": 44, "string": "More generally, we consider composition of relations r 1 / ."}, {"id": 45, "string": "."}, {"id": 46, "string": "."}, {"id": 47, "string": "/r l to model paths in a KB (Guu et al., 2015) , as defined by r 1 , ."}, {"id": 48, "string": "."}, {"id": 49, "string": "."}, {"id": 50, "string": ", r l participating in a sequence of facts such that the head entity of each fact coincides with the tail of its previous."}, {"id": 51, "string": "For example, a sequence of two facts The Matrix, country of film, Australia and Australia, currency of country, Australian Dollar form a path of composition country of film / currency of country, because the head of the second fact (i.e."}, {"id": 52, "string": "Australia) coincides with the tail of the first."}, {"id": 53, "string": "Using the previous d = |E| analogue, one can verify that composition of relations is represented by multiplication of adjacency matrices, so we accordingly define s(h, r 1 / ."}, {"id": 54, "string": "."}, {"id": 55, "string": "."}, {"id": 56, "string": "/r l , t) := exp(u h M r 1 \u00b7 \u00b7 \u00b7 M r l v t ) to measure the plausibility of a path."}, {"id": 57, "string": "It is explored in Guu et al."}, {"id": 58, "string": "(2015) to learn a score function not only for single facts but also for paths."}, {"id": 59, "string": "This compositional training scheme is shown to bring valuable information about the structure of the KB and may help KBC."}, {"id": 60, "string": "In this work, we conduct experiments both with and without compositional training."}, {"id": 61, "string": "In order to learn parameters u h , v t , M r of the score function, we follow Tian et al."}, {"id": 62, "string": "(2016) using a Noise Contrastive Estimation (NCE) (Gutmann and Hyv\u00e4rinen, 2012) objective."}, {"id": 63, "string": "For each path (or triple) h, r 1 / ."}, {"id": 64, "string": "."}, {"id": 65, "string": "."}, {"id": 66, "string": ", t taken from the KB, we generate negative samples by replacing the tail entity t with some random noise t * ."}, {"id": 67, "string": "Then, we maximize L 1 := path ln s(h, r 1 / ."}, {"id": 68, "string": "."}, {"id": 69, "string": "."}, {"id": 70, "string": ", t) k + s(h, r 1 / ."}, {"id": 71, "string": "."}, {"id": 72, "string": "."}, {"id": 73, "string": ", t) + noise ln k k + s(h, r 1 / ."}, {"id": 74, "string": "."}, {"id": 75, "string": "."}, {"id": 76, "string": ", t * ) as our KB-learning objective."}, {"id": 77, "string": "Here, k is the number of noises generated for each path."}, {"id": 78, "string": "When the score function is regarded as probability, L 1 represents the log-likelihood of \" h, r 1 / ."}, {"id": 79, "string": "."}, {"id": 80, "string": "."}, {"id": 81, "string": ", t being actual path and h, r 1 / ."}, {"id": 82, "string": "."}, {"id": 83, "string": "."}, {"id": 84, "string": ", t * being noise\"."}, {"id": 85, "string": "Maximizing L 1 increases the scores of actual paths and decreases the scores of noises."}, {"id": 86, "string": "Joint Training with an Autoencoder Autoencoders learn efficient codings of highdimensional data while trying to reconstruct the original data from the coding."}, {"id": 87, "string": "By joint training relation matrices with an autoencoder, we also expect it to help reducing the dimensionality of the original data (i.e."}, {"id": 88, "string": "relation matrices)."}, {"id": 89, "string": "Formally, we define a vectorization m r for each relation matrix M r , and use it as input to the autoencoder."}, {"id": 90, "string": "m r is defined as a reshape of M r flattened into a d 2 -dimension vector, and normalized such that m r = \u221a d. We define c r := ReLU(Am r ) (2) as the coding."}, {"id": 91, "string": "Here A is a c \u00d7 d 2 matrix with c d 2 , and ReLU is the Rectified Linear Unit function (Nair and Hinton, 2010) ."}, {"id": 92, "string": "We reconstruct the input from c r by multiplying a d 2 \u00d7 c matrix B."}, {"id": 93, "string": "We want Bc r to be more similar to m r than other relations."}, {"id": 94, "string": "For this purpose, we define a similarity g(r 1 , r 2 ) := exp( 1 \u221a dc m r 1 Bc r 2 ), (3) which measures the length of Bc r 2 projected to the direction of m r 1 ."}, {"id": 95, "string": "In order to learn the parameters A, B, we adopt the Noise Contrastive Estimation scheme as in Sec.2, generate random noises r * for each relation r and maximize L 2 := r\u2208R ln g(r, r) k + g(r, r) + r * \u223cR ln k k + g(r, r * ) as our reconstruction objective."}, {"id": 96, "string": "Maximizing L 2 increases m r 's similarity with Bc r , and decreases it with Bc r * ."}, {"id": 97, "string": "During joint training, both L 1 and L 2 are simultaneously maximized, and the gradient \u2207L 2 propagates to relation matrices as well."}, {"id": 98, "string": "Since \u2207L 2 depends on A and B, and A, B interact with all relations, they promote indirect parameter sharing between different relation matrices."}, {"id": 99, "string": "In Sec.6.2, we further show that joint training drives relations toward a low dimension manifold."}, {"id": 100, "string": "Optimization Tricks Joint training with an autoencoder is not simple."}, {"id": 101, "string": "Relation matrices receive updates from both \u2207L 1 and \u2207L 2 , but if they update \u2207L 1 too much, the autoencoder has no effect; conversely, if they update \u2207L 2 too often, all relation matrices crush into one cluster."}, {"id": 102, "string": "Furthermore, an autoencoder should learn from genuine patterns of relation matrices that emerge from fitting the KB, but not the reverse -in which the autoencoder imposes arbitrary patterns to relation matrices according to random initialization."}, {"id": 103, "string": "Therefore, it is not surprising that a naive optimization of L 1 + L 2 does not work."}, {"id": 104, "string": "After extensive pre-experiments, we have found some crucial settings for successful training."}, {"id": 105, "string": "The most important \"magic\" is the scaling factor 1 \u221a dc in definition of the similarity function (3) , perhaps being combined with other settings as we discuss below."}, {"id": 106, "string": "We have tried different factors 1, 1 \u221a d , 1 \u221a c and 1 dc instead, with various combinations of d and c; but the autoencoder failed to learn meaningful codings in other settings."}, {"id": 107, "string": "When the scaling factor is too small (e.g."}, {"id": 108, "string": "1 dc ), all relations get almost the same coding; conversely if the factor is too large (e.g."}, {"id": 109, "string": "1), all codings get very close to 0."}, {"id": 110, "string": "The next important rule is to keep a balance between the updates coming from \u2207L 1 and \u2207L 2 ."}, {"id": 111, "string": "We use Stochastic Gradient Descent (SGD) for optimization, and the common practice (Bottou, 2012) is to set the learning rate as \u03b1(\u03c4 ) := \u03b7 1 + \u03b7\u03bb\u03c4 ."}, {"id": 112, "string": "(4) Here, \u03b7, \u03bb are hyper-parameters and \u03c4 is a counter of processed data points."}, {"id": 113, "string": "In this work, in order to control the updates in detail to keep a balance, we modify (4) to use a a step counter \u03c4 r for each relation r, counting \"number of updates\" instead of data points 2 ."}, {"id": 114, "string": "That is, whenever M r gets a nonzero update from a gradient calculation, \u03c4 r increases by 1."}, {"id": 115, "string": "Furthermore, we use different hyper-parameters for different \"types of updates\", namely \u03b7 1 , \u03bb 1 for updates coming from \u2207L 1 , and \u03b7 2 , \u03bb 2 for updates coming from \u2207L 2 ."}, {"id": 116, "string": "Thus, let \u2206 1 be the partial gradient of \u2207L 1 , and \u2206 2 the partial gradient of \u2207L 2 , we update M r by \u03b1 1 (\u03c4 r )\u2206 1 + \u03b1 2 (\u03c4 r )\u2206 2 at each step, where \u03b1 1 (\u03c4 r ) := \u03b7 1 1 + \u03b7 1 \u03bb 1 \u03c4 r , \u03b1 2 (\u03c4 r ) := \u03b7 2 1 + \u03b7 2 \u03bb 2 \u03c4 r ."}, {"id": 117, "string": "The rule for setting \u03b7 1 , \u03bb 1 and \u03b7 2 , \u03bb 2 is that, \u03b7 2 should be much smaller than \u03b7 1 , because \u03b7 1 , \u03b7 2 control the magnitude of learning rates at the early stage of training, with the autoencoder still largely random and \u2206 2 not making much sense; on the other hand, one has to choose \u03bb 1 and \u03bb 2 such that \u2206 1 /\u03bb 1 and \u2206 2 /\u03bb 2 are at the same scale, because the learning rates approach 1/(\u03bb 1 \u03c4 r ) and 1/(\u03bb 2 \u03c4 r ) respectively, as the training proceeds."}, {"id": 118, "string": "In this way, the autoencoder will not impose random patterns to relation matrices according to its initialization at the early stage, and a balance is kept between \u03b1 1 (\u03c4 r )\u2206 1 and \u03b1 2 (\u03c4 r )\u2206 2 later."}, {"id": 119, "string": "But how to estimate \u2206 1 and \u2206 2 ?"}, {"id": 120, "string": "It seems that we can approximately calculate their scales from initialization."}, {"id": 121, "string": "In this work, we use i.i.d."}, {"id": 122, "string": "Gaussians of variance 1/d to initialize parameters, so the initial Euclidean norms are u h \u2248 1, v t \u2248 1, M r \u2248 \u221a d, and BAm r \u2248 \u221a dc."}, {"id": 123, "string": "Thus, by calculating \u2207L 1 and \u2207L 2 using (1) and (3) , we have approximately \u2206 1 \u2248 u h v t \u2248 1, and \u2206 2 \u2248 1 \u221a dc Bc r \u2248 1 \u221a dc BAm r \u2248 1."}, {"id": 124, "string": "It suggests that, because of the scaling factor 1 \u221a dc in (3), we have \u2206 1 and \u2206 2 at the same scale, so we can set \u03bb 1 = \u03bb 2 ."}, {"id": 125, "string": "This might not be a mere coincidence."}, {"id": 126, "string": "Training the Base Model Besides the tricks for joint training, we also found settings that significantly improve the base model on KBC, as briefly discussed below."}, {"id": 127, "string": "In Sec.6.3, we will show performance gains by these settings using the FB15k-237 validation set."}, {"id": 128, "string": "Normalization It is better to normalize relation matrices to M r = \u221a d during training."}, {"id": 129, "string": "This might reduce fluctuations in entity vector updates."}, {"id": 130, "string": "Regularizer It is better to minimize M r M r \u2212 1 d tr(M r M r )I during training."}, {"id": 131, "string": "This regularizer drives M r toward an orthogonal matrix (Tian et al., 2016) and might reduce fluctuations in entity vector updates."}, {"id": 132, "string": "As a result, all relation matrices trained in this work are very close to orthogonal."}, {"id": 133, "string": "Initialization Instead of pure Gaussian, it is better to initialize matrices as (I + G)/2, where G is random."}, {"id": 134, "string": "The identity matrix I helps passing information from head to tail (Tian et al., 2016) ."}, {"id": 135, "string": "Negative Sampling Instead of a unigram distribution, it is better to use a uniform distribution for generating noises."}, {"id": 136, "string": "This is somehow counterintuitive compared to training word embeddings."}, {"id": 137, "string": "Related Works KBs have a wide range of applications (Berant et al., 2013; Hixon et al., 2015; Nickel et al., 2016a) and KBC has inspired a huge amount of research (Bordes et al., 2013; Riedel et al., 2013; Socher et al., 2013; Wang et al., 2014b,a; Xiao et al., 2016; Nguyen et al., 2016; Toutanova et al., 2016; Das et al., 2017; Hayashi and Shimbo, 2017) ."}, {"id": 138, "string": "Among the previous works, TransE (Bordes et al., 2013) is the classic method which represents a relation as a translation of the entity vector space, and is partially inspired by Mikolov et al."}, {"id": 139, "string": "(2013) 's vector arithmetic method of solving word analogy tasks."}, {"id": 140, "string": "Although competitive in KBC, it is speculated that this method is well-suited for 1to-1 relations but might be too simple to represent N -to-N relations accurately (Wang et al., 2017) ."}, {"id": 141, "string": "Thus, extensions such as TransR (Lin et al., 2015b) and STransE (Nguyen et al., 2016) are proposed to map entities into a relation-specific vector space before translation."}, {"id": 142, "string": "The ITransF model (Xie et al., 2017) further enhances this approach by imposing a hard constraint that the relation-specific maps should be linear combinations of a small number of prototypical matrices."}, {"id": 143, "string": "Our work inherits the same motivation with ITransF in terms of promoting parameter-sharing among relations."}, {"id": 144, "string": "On the other hand, the base model used in this work originates from RESCAL (Nickel et al., 2011) , in which relations are naturally represented as analogue to the adjacency matrices (Sec.2)."}, {"id": 145, "string": "Further developments include HolE (Nickel et al., 2016b) and ConvE (Dettmers et al., 2018) which improve this approach in terms of parameterefficiency, by introducing low dimension factorizations of the matrices."}, {"id": 146, "string": "We inherit the basic model of RESCAL but draw additional training techniques from Tian et al."}, {"id": 147, "string": "(2016) , and show that the base model already can achieve near state-of-the-art performance (Sec.6.1,6.3)."}, {"id": 148, "string": "This sends a message similar to Kadlec et al."}, {"id": 149, "string": "(2017) , saying that training tricks might be as important as model designs."}, {"id": 150, "string": "Nevertheless, we emphasize the novelty of this work in that the previous models mostly achieve dimension reduction by imposing some pre-designed hard constraints (Bordes et al., 2013; Trouillon et al., 2016; Nickel et al., 2016b; Xie et al., 2017; Dettmers et al., 2018) , whereas the constraints themselves are not learned from data; in contrast, our approach by jointly training an autoencoder does not impose any explicit hard constraints, so it leads to more flexible modeling."}, {"id": 151, "string": "Moreover, we additionally focus on leveraging composition in KBC."}, {"id": 152, "string": "Although this idea has been frequently explored before (Guu et al., 2015; Neelakantan et al., 2015; Lin et al., 2015a) , our discussion about the concept of compositional constraints and its connection to dimension reduction has not been addressed similarly in previous research."}, {"id": 153, "string": "In experiments, we will show (Sec.6.2,6.3) that joint training with an autoencoder indeed helps finding compositional constraints and benefits from compositional training."}, {"id": 154, "string": "Autoencoders have been used solo for learning distributed representations of syntactic trees (Socher et al., 2011) , words and images (Silberer and Lapata, 2014) , or semantic roles (Titov and Khoddam, 2015) ."}, {"id": 155, "string": "It is also used for pretraining other deep neural networks (Erhan et al., 2010) ."}, {"id": 156, "string": "However, when combined with other models, the learning of autoencoders, or more generally sparse codings (Rubinstein et al., 2010) , is usually conveyed in an alternating manner, fixing one part of the model while optimizing the other, such as in Xie et al."}, {"id": 157, "string": "(2017) ."}, {"id": 158, "string": "To our knowledge, joint training with an autoencoder is not widely used previously for reducing dimensionality."}, {"id": 159, "string": "Jointly training an autoencoder is not simple because it takes non-stationary inputs."}, {"id": 160, "string": "In this work, we modified SGD so that it shares traits with some modern optimization algorithms such as Adagrad (Duchi et al., 2011) , in that they both set different learning rates for different parameters."}, {"id": 161, "string": "While Adagrad sets them adaptively by keeping track of gradients for all parameters, our modification of SGD is more efficient and allows us to grasp a rough intuition about which parameter gets how much update."}, {"id": 162, "string": "We believe our techniques and findings in joint training with an autoencoder could be helpful to reducing dimensionality and improving interpretability in other neural network architectures as well."}, {"id": 163, "string": "Experiments We evaluate on standard KBC datasets, including WN18 and FB15k (Bordes et al., 2013) , WN18RR (Dettmers et al., 2018) and FB15k-237 (Toutanova and Chen, 2015) ."}, {"id": 164, "string": "The statistical information of these datasets are shown in Table 1."}, {"id": 165, "string": "WN18 collects word relations from WordNet (Miller, 1995) , and FB15k is taken from Freebase (Bollacker et al., 2008) ; both have filtered out low frequency entities."}, {"id": 166, "string": "However, it is reported in Toutanova and Chen (2015) that both WN18 and FB15k have information leaks because the inverses of some test triples appear in the training set."}, {"id": 167, "string": "FB15k-237 and WN18RR fix this problem by deleting such triples from training and test data."}, {"id": 168, "string": "In this work, we do evaluate on WN18 and FB15k, but our models are mainly tuned on FB15k-237."}, {"id": 169, "string": "For all datasets, we set the dimension d = 256 and c = 16, the SGD hyper-parameters \u03b7 1 = 1/64, \u03b7 2 = 2 \u221214 and \u03bb 1 = \u03bb 2 = 2 \u221214 ."}, {"id": 170, "string": "The training batch size is 32 and the triples in each batch share the same head entity."}, {"id": 171, "string": "We compare the base model (BASE) to our joint training with an autoencoder model (JOINT), and the base model with compositional training (BASE+COMP) to our joint model with compositional training (JOINT+COMP)."}, {"id": 172, "string": "When compositional training is enabled (BASE+COMP, JOINT+COMP), we use random walk to sample paths of length 1 + X, where X is drawn from a Poisson distribution of mean \u03bb = 1.0."}, {"id": 173, "string": "For any incomplete triple h, r, ?"}, {"id": 174, "string": "in KBC test, we calculate a score s(h, r, e) from (1), for every entity e \u2208 E such that h, r, e does not appear in any of the training, validation, or test sets (Bordes et al., 2013) ."}, {"id": 175, "string": "Then, the calculated scores together with s(h, r, t) for the gold triple is converted to ranks, and the rank of the gold entity t is used for evaluation."}, {"id": 176, "string": "Evaluation metrics include Mean Rank (MR), Mean Reciprocal Rank (MRR), and Hits at 10 (H10)."}, {"id": 177, "string": "Lower MR, higher MRR, and higher H10 indicate better performance."}, {"id": 178, "string": "We consult MR and MRR on validation sets to determine training epochs; we stop training when both MR and MRR have stopped improving."}, {"id": 179, "string": "KBC Results The results are shown in Table 2 ."}, {"id": 180, "string": "We found that joint training with an autoencoder mostly improves performance, and the improvement becomes more clear when compositional training is enabled (i.e., JOINT \u2265 BASE and JOINT+COMP > BASE+COMP)."}, {"id": 181, "string": "This is convincing because generally, joint training contributes with its regularizing effects, and drastic improvements are less expected 3 ."}, {"id": 182, "string": "When compositional training is enabled, 3 The source code and trained models are publicly released at https://github.com/tianran/glimvec, where profession profession \u22121 film_crew_role \u22121 film_release_region \u22121 film_language \u22121 nationality currency_of_country currency_of_company currency_of_university currency_of_film_budget 2 4 6 8 10 12 14 16 currency_of_film_budget release_region_of_film corporation_of_film producer_of_film writer_of_film the system usually achieves better MR, though not always improves in other measures."}, {"id": 183, "string": "The performance gains are more obvious on the WN18RR and FB15k-237 datasets, possibly because WN18 and FB15k contain a lot of easy instances that can be solved by a simple rule (Dettmers et al., 2018) ."}, {"id": 184, "string": "Furthermore, the numbers demonstrated by our joint and base models are among the strongest in the literature."}, {"id": 185, "string": "We have conducted re-experiments of several representative algorithms, and also compare with state-of-the-art published results."}, {"id": 186, "string": "For re-experiments, we use Lin et al."}, {"id": 187, "string": "(2015b) 's implementation 4 of TransE (Bordes et al., 2013) and TransR, which represent relations as vector translations; and Nickel et al."}, {"id": 188, "string": "(2016b) 's implementation 5 of RESCAL (Nickel et al., 2011) and HolE, where RESCAL is most similar to the BASE model and HolE is a more parameter-efficient variant."}, {"id": 189, "string": "We experimented with the default settings, and found that our models outperform most of them."}, {"id": 190, "string": "Among the published results, STransE (Nguyen et al., 2016) and ITransF (Xie et al., 2017) Table 2 : KBC results on the WN18, FB15k, WN18RR, and FB15k-237 datasets."}, {"id": 191, "string": "The first and second sectors compare our joint to the base models with and without compositional training, respectively; the third sector shows our re-experiments and the fourth shows previous published results."}, {"id": 192, "string": "Bold numbers are the best in each sector, and ( * ) indicates the best of all."}, {"id": 193, "string": "(Trouillon et al., 2016) and ConvE were previously the best results."}, {"id": 194, "string": "Our models mostly outperform them."}, {"id": 195, "string": "Other results include Kadlec et al."}, {"id": 196, "string": "(2017) 's simple but strong baseline and several recent models (Schlichtkrull et al., 2017; Shi and Weninger, 2017; Shen et al., 2017) which achieve best results on FB15k or WN18 in some measure."}, {"id": 197, "string": "Our models have comparable results."}, {"id": 198, "string": "Intuition and Insight What does the autoencoder look like?"}, {"id": 199, "string": "How does joint training affect relation matrices?"}, {"id": 200, "string": "We address these questions by analyses showing that (i) the autoencoder learns sparse and interpretable codings of relations, (ii) the joint training drives relation matrices toward a low dimension manifold, and (iii) it helps discovering compositional constraints."}, {"id": 201, "string": "Sparse Coding and Interpretability Due to the ReLU function in (2), our autoencoder learns sparse coding, with most relations having large code values at only two or three dimensions."}, {"id": 202, "string": "This sparsity makes it easy to find patterns in the model that to some extent explain the semantics of relations."}, {"id": 203, "string": "Figure 2 shows some examples."}, {"id": 204, "string": "In the first group of Figure 2 , we show a small number of relations that are almost always assigned a near one-hot coding, regardless of initialization."}, {"id": 205, "string": "These are high frequency relations joining two large categories (e.g."}, {"id": 206, "string": "film and language), which probably constitute the skeleton of a KB."}, {"id": 207, "string": "In the second group, we found the 12th dimension strongly correlates with currency; and in the third group, we found the 4th dimension strongly correlates with film."}, {"id": 208, "string": "As for the relation currency of film budget, it has large code values at both dimensions."}, {"id": 209, "string": "This kind of relation clustering also seems independent of initialization."}, {"id": 210, "string": "Intuitively, it shows that the autoencoder may discover similarities between relations and promote indirect parameter sharing among them."}, {"id": 211, "string": "Yet, as the autoencoder only reconstructs approximations of relation matrices but never constrain them to be exactly equal to the original, relation matrices with very similar codings may still differ considerably."}, {"id": 212, "string": "For example, producer of film and writer of film have codings of cosine similarity 0.973, but their relation matrices only have 6 a cosine similarity 0.338."}, {"id": 213, "string": "Low dimension manifold In order to visualize the relation matrices learned by our joint and base models, we use UMAP 7 (McInnes and Healy, 2018) to embed M r into a 2D plane 8 ."}, {"id": 214, "string": "We use relation matrices trained on FB15k-237, and compare models trained by the same number of epochs."}, {"id": 215, "string": "The results are shown in Figure 3 ."}, {"id": 216, "string": "We can see that Figure 3a and Figure 3c are mostly similar, with high frequency relations scattered randomly around a low frequency cluster, suggesting that they come from various directions of a high dimension space, with frequent relations probably being pulled further by the training updates."}, {"id": 217, "string": "On the other hand, in Figure 3b and Figure 3d we found less frequent relations being clustered with frequent ones, and multiple traces of low dimension structures."}, {"id": 218, "string": "It suggests that joint training with an autoencoder indeed drives relations toward a low dimension manifold."}, {"id": 219, "string": "In addition, Figure 3d shows different structures against Figure 3b , which we conjecture could be related to compositional constraints discovered by compositional training."}, {"id": 220, "string": "Compositional constraints In order to directly evaluate a model's ability to find compositional constraints, we extracted from FB15k-237 a list of (r 1 /r 2 , r 3 ) pairs such that r 1 /r 2 matches r 3 ."}, {"id": 221, "string": "Formally, the list is constructed as below."}, {"id": 222, "string": "For any relation r, we define a content set C(r) as the set of (h, t) pairs such that h, r, t is a fact in the KB."}, {"id": 223, "string": "Similarly, we define C(r 1 /r 2 ) t-SNE (van der Maaten and Hinton, 2008) but found UMAP more insightful."}, {"id": 224, "string": "as the set of (h, t) pairs such that h, r 1 /r 2 , t is a path."}, {"id": 225, "string": "We regard (r 1 /r 2 , r 3 ) as a compositional constraint if their content sets are similar; that is, if |C(r 1 /r 2 ) \u2229 C(r 3 )| \u2265 50 and the Jaccard similarity between C(r 1 /r 2 ) and C(r 3 ) is \u2265 0.4."}, {"id": 226, "string": "Then, after filtering out degenerated cases such as r 1 = r 3 or r 2 = r \u22121 1 , we obtained a list of 154 compositional constraints, e.g."}, {"id": 227, "string": "(currency of country/country of film, currency of film budget)."}, {"id": 228, "string": "For each compositional constraint (r 1 /r 2 , r 3 ) in the list, we take the matrices M 1 , M 2 and M 3 corresponding to r 1 , r 2 and r 3 respectively, and rank M 3 according to its cosine similarity with M 1 M 2 , among all relation matrices."}, {"id": 229, "string": "Then, we calculate MR and MRR for evaluation."}, {"id": 230, "string": "We compare the JOINT+COMP model to BASE+COMP, as well as a randomized baseline where M 2 is selected randomly from the relation matrices in JOINT+COMP instead (RANDOMM2)."}, {"id": 231, "string": "The results are shown in Table 3 ."}, {"id": 232, "string": "We have evaluated 5 different random initializations for each model, trained by the same number of epochs, and we report the mean and standard deviation."}, {"id": 233, "string": "We verify that JOINT+COMP performs better than BASE+COMP, indicating that joint training with an autoencoder indeed helps discovering compositional constraints."}, {"id": 234, "string": "Furthermore, the random baseline RANDOMM2 tests a hypothesis that joint training might be just clustering M 3 and M 1 here, to the extent that M 3 and M 1 are so close that even a random M 2 can give the correct answer; but as it turns out, JOINT+COMP largely outperforms RANDOMM2, excluding this possibility."}, {"id": 235, "string": "Thus, joint training performs better not simply because it clusters relation matrices; it learns compositions indeed."}, {"id": 236, "string": "Losses and Gains In the KBC task, where are the losses and what are the gains of different settings?"}, {"id": 237, "string": "With additional evaluations, we show (i) some crucial settings for the base model, and (ii) joint training with an autoencoder benefits more from compositional training."}, {"id": 238, "string": "Crucial settings for the base model It is noteworthy that our base model already achieves strong results."}, {"id": 239, "string": "This is due to several detailed but crucial settings as we discussed in Sec.4.1; Table 4 shows their gains on the FB15k-237 validation data."}, {"id": 240, "string": "The most dramatic improvement comes from the regularizer that drives matrices to orthogonal."}, {"id": 241, "string": "Gains with compositional training One can force a model to focus more on (longer) compositions of relations, by sampling longer paths in compositional training."}, {"id": 242, "string": "Since joint training with an autoencoder helps discovering compositional constraints, we expect it to be more helpful when the sampled paths are longer."}, {"id": 243, "string": "In this work, path lengths are sampled from a Poisson distribution, we thus vary the mean \u03bb of the Poisson to control the strength of compositional training."}, {"id": 244, "string": "The results on FB15k-237 are shown in Table 5 ."}, {"id": 245, "string": "We can see that, as \u03bb gets larger, MR improves much but MRR slightly drops."}, {"id": 246, "string": "It suggests that in FB15k-237, composition of relations might mainly help finding more appropriate candidates for a missing entity, rather than pinpointing a correct one."}, {"id": 247, "string": "Yet, joint training improves base models even more as the paths get longer, especially in MR."}, {"id": 248, "string": "It further supports our conjecture that joint training with an autoencoder may strongly interact with compositional training."}, {"id": 249, "string": "Conclusion We have investigated a dimension reduction technique which trains a KB embedding model jointly with an autoencoder."}, {"id": 250, "string": "We have developed new training techniques and achieved state-of-the-art results on several KBC tasks with strong improvements in Mean Rank."}, {"id": 251, "string": "Furthermore, we have shown that the autoencoder learns low dimension sparse codings that can be easily explained; the joint training technique drives high-dimensional data toward low  dimension manifolds; and the reduction of dimensionality may interact strongly with composition, help discovering compositional constraints and benefit from compositional training."}, {"id": 252, "string": "We believe these findings provide insightful understandings of KB embedding models and might be applied to other neural networks beyond the KBC task."}, {"id": 253, "string": "Occasionally, a KBC test set may contain entities that never appear in the training data."}, {"id": 254, "string": "Such out-ofvocabulary (OOV) entities pose a challenge to KBC systems; while some systems address this issue by explicitly learn an OOV entity vector (Dettmers et al., 2018 ), our approach is described below."}, {"id": 255, "string": "For an incomplete triple h, r, ?"}, {"id": 256, "string": "in the test, if h is OOV, we replace it with the most frequent entity that has ever appeared as a head of relation r in the training data."}, {"id": 257, "string": "If the gold tail entity is OOV, we use the zero vector for computing the score and the rank of the gold entity."}, {"id": 258, "string": "Usually, OOV entities are rare and negligible in evaluation; except for the WN18RR test data which contains about 6.7% triples with OOV entities."}, {"id": 259, "string": "Here, we also report adjusted scores on WN18RR in the setting that all triples with OOV entities are removed from the test."}, {"id": 260, "string": "The results are shown in Table 6"}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 27}, {"section": "Base Model", "n": "2", "start": 28, "end": 85}, {"section": "Joint Training with an Autoencoder", "n": "3", "start": 86, "end": 99}, {"section": "Optimization Tricks", "n": "4", "start": 100, "end": 125}, {"section": "Training the Base Model", "n": "4.1", "start": 126, "end": 136}, {"section": "Related Works", "n": "5", "start": 137, "end": 162}, {"section": "Experiments", "n": "6", "start": 163, "end": 178}, {"section": "KBC Results", "n": "6.1", "start": 179, "end": 197}, {"section": "Intuition and Insight", "n": "6.2", "start": 198, "end": 234}, {"section": "Losses and Gains", "n": "6.3", "start": 235, "end": 248}, {"section": "Conclusion", "n": "7", "start": 249, "end": 260}], "figures": [{"filename": "../figure/image/1344-Figure1-1.png", "caption": "Figure 1: In joint training, relation parameters (e.g. M1) receive updates from both a KB-learning objective, trying to predict entities in the KB; and a reconstruction objective from an autoencoder, trying to recover relations from low dimension codings.", "page": 0, "bbox": {"x1": 319.68, "x2": 513.12, "y1": 222.72, "y2": 401.28}}, {"filename": "../figure/image/1344-Table1-1.png", "caption": "Table 1: Statistical information of the KBC datasets. |E| and |R| denote the number of entities and relation types, respectively; #Train, #Valid, and #Test are the numbers of triples in the training, validation, and test sets, respectively.", "page": 5, "bbox": {"x1": 74.88, "x2": 288.0, "y1": 62.4, "y2": 125.28}}, {"filename": "../figure/image/1344-Figure2-1.png", "caption": "Figure 2: Examples of relation codings learned from FB15k-237. Each row shows a 16 dimension vector encoding a relation. Vectors are normalized such that their entries sum to 1.", "page": 5, "bbox": {"x1": 312.96, "x2": 520.8, "y1": 67.67999999999999, "y2": 225.6}}, {"filename": "../figure/image/1344-Table2-1.png", "caption": "Table 2: KBC results on the WN18, FB15k, WN18RR, and FB15k-237 datasets. The first and second sectors compare our joint to the base models with and without compositional training, respectively; the third sector shows our re-experiments and the fourth shows previous published results. Bold numbers are the best in each sector, and (\u2217) indicates the best of all.", "page": 6, "bbox": {"x1": 78.72, "x2": 519.36, "y1": 67.2, "y2": 276.0}}, {"filename": "../figure/image/1344-Figure3-1.png", "caption": "Figure 3: By UMAP, relation matrices are embedded into a 2D plane. Colors show frequencies of relations; and lighter color means more frequent.", "page": 7, "bbox": {"x1": 74.88, "x2": 288.0, "y1": 61.44, "y2": 303.36}}, {"filename": "../figure/image/1344-Table3-1.png", "caption": "Table 3: Performance at discovering compositional constraints extracted from FB15k-237", "page": 7, "bbox": {"x1": 310.56, "x2": 522.24, "y1": 62.4, "y2": 115.19999999999999}}, {"filename": "../figure/image/1344-Table6-1.png", "caption": "Table 6: Adjusted scores on WN18RR.", "page": 11, "bbox": {"x1": 76.8, "x2": 285.12, "y1": 653.28, "y2": 720.9599999999999}}, {"filename": "../figure/image/1344-Table4-1.png", "caption": "Table 4: Ablation of the four settings of the base model as described in Sec.4.1", "page": 8, "bbox": {"x1": 77.75999999999999, "x2": 284.15999999999997, "y1": 62.4, "y2": 140.16}}, {"filename": "../figure/image/1344-Table5-1.png", "caption": "Table 5: Evaluation of BASE and gains by JOINT, on FB15k-237 with different strengths of compositional training. Bold numbers are improvements.", "page": 8, "bbox": {"x1": 312.96, "x2": 520.3199999999999, "y1": 62.4, "y2": 171.35999999999999}}]}