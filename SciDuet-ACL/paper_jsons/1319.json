{"title": "Training Classifiers with Natural Language Explanations", "abstract": "Training accurate classifiers requires many labels, but each label provides only limited information (one bit for binary classification). In this work, we propose BabbleLabble, a framework for training classifiers in which an annotator provides a natural language explanation for each labeling decision. A semantic parser converts these explanations into programmatic labeling functions that generate noisy labels for an arbitrary amount of unlabeled data, which is used to train a classifier. On three relation extraction tasks, we find that users are able to train classifiers with comparable F1 scores from 5-100 faster by providing explanations instead of just labels. Furthermore, given the inherent imperfection of labeling functions, we find that a simple rule-based semantic parser suffices.", "text": [{"id": 0, "string": "Introduction The standard protocol for obtaining a labeled dataset is to have a human annotator view each example, assess its relevance, and provide a label (e.g., positive or negative for binary classification)."}, {"id": 1, "string": "However, this only provides one bit of information per example."}, {"id": 2, "string": "This invites the question: how can we get more information per example, given that the annotator has already spent the effort reading and understanding an example?"}, {"id": 3, "string": "Previous works have relied on identifying relevant parts of the input such as labeling features (Druck et al., 2009; Raghavan et al., 2005; Liang et al., 2009) , highlighting rationale phrases in Both cohorts showed signs of optic nerve toxicity due to ethambutol."}, {"id": 4, "string": "Example Label Explanation Because the words \"due to\" occur between the chemical and the disease."}, {"id": 5, "string": "Does this chemical cause this disease?"}, {"id": 6, "string": "Why do you think so?"}, {"id": 7, "string": "Labeling Function def lf(x): return (1 if \"due to\" in between(x.chemical, x.disease) else 0) Figure 1 : In BabbleLabble, the user provides a natural language explanation for each labeling decision."}, {"id": 8, "string": "These explanations are parsed into labeling functions that convert unlabeled data into a large labeled dataset for training a classifier."}, {"id": 9, "string": "text (Zaidan and Eisner, 2008; Arora and Nyberg, 2009 ), or marking relevant regions in images (Ahn et al., 2006) ."}, {"id": 10, "string": "But there are certain types of information which cannot be easily reduced to annotating a portion of the input, such as the absence of a certain word, or the presence of at least two words."}, {"id": 11, "string": "In this work, we tap into the power of natural language and allow annotators to provide supervision to a classifier via natural language explanations."}, {"id": 12, "string": "Specifically, we propose a framework in which annotators provide a natural language explanation for each label they assign to an example (see Figure 1) ."}, {"id": 13, "string": "These explanations are parsed into logical forms representing labeling functions (LFs), functions that heuristically map examples to labels (Ratner et al., 2016) ."}, {"id": 14, "string": "The labeling functions are Unlabeled Examples + Explanations Label whether person 1 is married to person 2 Labeling Functions Filters Label Matrix None of us knows what happened at Kane's home Aug. 2, but it is telling that the NHL has not suspended Kane."}, {"id": 15, "string": "False, because person 1 and person 2 in the sentence are identical."}, {"id": 16, "string": "Dr. Michael Richards and real estate and insurance businessman Gary Kirke did not attend the event."}, {"id": 17, "string": "False, because the last word of person 1 is different than the last word of person 2. x 1 x 2 then executed on many unlabeled examples, resulting in a large, weakly-supervised training set that is then used to train a classifier."}, {"id": 18, "string": "Semantic parsing of natural language into logical forms is recognized as a challenging problem and has been studied extensively (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang et al., 2011; Liang, 2016) ."}, {"id": 19, "string": "One of our major findings is that in our setting, even a simple rule-based semantic parser suffices for three reasons: First, we find that the majority of incorrect LFs can be automatically filtered out either semantically (e.g., is it consistent with the associated example?)"}, {"id": 20, "string": "or pragmatically (e.g., does it avoid assigning the same label to the entire training set?)."}, {"id": 21, "string": "Second, LFs near the gold LF in the space of logical forms are often just as accurate (and sometimes even more accurate)."}, {"id": 22, "string": "Third, techniques for combining weak supervision sources are built to tolerate some noise (Alfonseca et al., 2012; Takamatsu et al., 2012; Ratner et al., 2018) ."}, {"id": 23, "string": "The significance of this is that we can deploy the same semantic parser across tasks without task-specific training."}, {"id": 24, "string": "We show how we can tackle a real-world biomedical application with the same semantic parser used to extract instances of spouses."}, {"id": 25, "string": "Our work is most similar to that of Srivastava et al."}, {"id": 26, "string": "(2017) , who also use natural language explanations to train a classifier, but with two important differences."}, {"id": 27, "string": "First, they jointly train a task-specific semantic parser and classifier, whereas we use a simple rule-based parser."}, {"id": 28, "string": "In Section 4, we find that in our weak supervision framework, the rule-based semantic parser and the perfect parser yield nearly identical downstream performance."}, {"id": 29, "string": "Second, while they use the logical forms of explanations to produce features that are fed directly to a classifier, we use them as functions for labeling a much larger training set."}, {"id": 30, "string": "In Section 4, we show that using functions yields a 9.5 F1 improvement (26% relative improvement) over features, and that the F1 score scales with the amount of available unlabeled data."}, {"id": 31, "string": "We validate our approach on two existing datasets from the literature (extracting spouses from news articles and disease-causing chemicals from biomedical abstracts) and one real-world use case with our biomedical collaborators at Oc-camzRazor to extract protein-kinase interactions related to Parkinson's disease from text."}, {"id": 32, "string": "We find empirically that users are able to train classifiers with comparable F1 scores up to two orders of magnitude faster when they provide natural language explanations instead of individual labels."}, {"id": 33, "string": "Our code and data can be found at https:// github.com/HazyResearch/babble."}, {"id": 34, "string": "The BabbleLabble Framework The BabbleLabble framework converts natural language explanations and unlabeled data into a noisily-labeled training set (see Figure 2 )."}, {"id": 35, "string": "There are three key components: a semantic parser, a filter bank, and a label aggregator."}, {"id": 36, "string": "The semantic Figure 3 : Valid parses are found by iterating over increasingly large subspans of the input looking for matches among the right hand sides of the rules in the grammar."}, {"id": 37, "string": "Rules are either lexical (converting tokens into symbols), unary (converting one symbol into another symbol), or compositional (combining many symbols into a single higher-order symbol)."}, {"id": 38, "string": "A rule may optionally ignore unrecognized tokens in a span (denoted here with a dashed line)."}, {"id": 39, "string": "parser converts natural language explanations into a set of logical forms representing labeling functions (LFs)."}, {"id": 40, "string": "The filter bank removes as many incorrect LFs as possible without requiring ground truth labels."}, {"id": 41, "string": "The remaining LFs are applied to unlabeled examples to produce a matrix of labels."}, {"id": 42, "string": "This label matrix is passed into the label aggregator, which combines these potentially conflicting and overlapping labels into one label for each example."}, {"id": 43, "string": "The resulting labeled examples are then used to train an arbitrary discriminative model."}, {"id": 44, "string": "Explanations To create the input explanations, the user views a subset S of an unlabeled dataset D (where |S| |D|) and provides for each input x i \u2208 S a label y i and a natural language explanation e i , a sentence explaining why the example should receive that label."}, {"id": 45, "string": "The explanation e i generally refers to specific aspects of the example (e.g., in Figure 2 , the location of a specific string \"his wife\")."}, {"id": 46, "string": "Semantic Parser The semantic parser takes a natural language explanation e i and returns a set of LFs (logical forms or labeling functions) {f 1 , ."}, {"id": 47, "string": "."}, {"id": 48, "string": "."}, {"id": 49, "string": ", f k } of the form f i : X \u2192 {\u22121, 0, 1} in a binary classification setting, with 0 representing abstention."}, {"id": 50, "string": "We emphasize that the goal of this semantic parser is not to generate the single correct parse, but rather to have coverage over many potentially useful LFs."}, {"id": 51, "string": "1 1 Indeed, we find empirically that an incorrect LF nearby the correct one in the space of logical forms actually has higher end-task accuracy 57% of the time (see Section 4.2)."}, {"id": 52, "string": "We choose a simple rule-based semantic parser that can be used without any training."}, {"id": 53, "string": "Formally, the parser uses a set of rules of the form \u03b1 \u2192 \u03b2, where \u03b1 can be replaced by the token(s) in \u03b2 (see Figure 3 for example rules)."}, {"id": 54, "string": "To identify candidate LFs, we recursively construct a set of valid parses for each span of the explanation, based on the substitutions defined by the grammar rules."}, {"id": 55, "string": "At the end, the parser returns all valid parses (LFs in our case) corresponding to the entire explanation."}, {"id": 56, "string": "We also allow an arbitrary number of tokens in a given span to be ignored when looking for a matching rule."}, {"id": 57, "string": "This improves the ability of the parser to handle unexpected input, such as unknown words or typos, since the portions of the input that are parseable can still result in a valid parse."}, {"id": 58, "string": "For example, in Figure 3 , the word \"person\" is ignored."}, {"id": 59, "string": "All predicates included in our grammar (summarized in Table 1 ) are provided to annotators, with minimal examples of each in use (Appendix A)."}, {"id": 60, "string": "Importantly, all rules are domain independent (e.g., all three relation extraction tasks that we tested used the same grammar), making the semantic parser easily transferrable to new domains."}, {"id": 61, "string": "Additionally, while this paper focuses on the task of relation extraction, in principle the BabbleLabble framework can be applied to other tasks or settings by extending the grammar with the necessary primitives (e.g., adding primitives for rows and columns to enable explanations about the alignments of words in tables)."}, {"id": 62, "string": "To guide the construction of the grammar, we collected 500 explanations for the Spouse domain from workers Apply a functional primitive to each member of list/set to transform or filter the elements word distance, character distance Return the distance between two strings by words or characters left, right, between, within Return as a string the text that is left/right/within some distance of a string or between two designated strings on Amazon Mechanical Turk and added support for the most commonly used predicates."}, {"id": 63, "string": "These were added before the experiments described in Section 4."}, {"id": 64, "string": "Altogether the grammar contains 200 rule templates."}, {"id": 65, "string": "Filter Bank The input to the filter bank is a set of candidate LFs produced by the semantic parser."}, {"id": 66, "string": "The purpose of the filter bank is to discard as many incorrect LFs as possible without requiring additional labels."}, {"id": 67, "string": "It consists of two classes of filters: semantic and pragmatic."}, {"id": 68, "string": "Recall that each explanation e i is collected in the context of a specific labeled example (x i , y i )."}, {"id": 69, "string": "The semantic filter checks for LFs that are inconsistent with their corresponding example; formally, any LF f for which f (x i ) = y i is discarded."}, {"id": 70, "string": "For example, in the first explanation in Figure 2 , the word \"right\" can be interpreted as either \"immediately\" (as in \"right before\") or simply \"to the right.\""}, {"id": 71, "string": "The latter interpretation results in a function that is inconsistent with the associated example (since \"his wife\" is actually to the left of person 2), so it can be safely removed."}, {"id": 72, "string": "The pragmatic filters removes LFs that are constant, redundant, or correlated."}, {"id": 73, "string": "For example, in Figure 2 , LF 2a is constant, as it labels every example positively (since all examples contain two people from the same sentence)."}, {"id": 74, "string": "LF 3b is redundant, since even though it has a different syntax tree from LF 3a, it labels the training set identically and therefore provides no new signal."}, {"id": 75, "string": "Finally, out of all LFs from the same explanation that pass all the other filters, we keep only the most specific (lowest coverage) LF."}, {"id": 76, "string": "This prevents multiple correlated LFs from a single example from dominating."}, {"id": 77, "string": "As we show in Section 4, over three tasks, the filter bank removes 86% of incorrect parses, and the incorrect ones that remain have average endtask accuracy within 2.5% of the corresponding correct parses."}, {"id": 78, "string": "Label Aggregator The label aggregator combines multiple (potentially conflicting) suggested labels from the LFs and combines them into a single probabilistic label per example."}, {"id": 79, "string": "Concretely, if m LFs pass the filter bank and are applied to n examples, the label aggregator implements a function f : {\u22121, 0, 1} m\u00d7n \u2192 [0, 1] n ."}, {"id": 80, "string": "A naive solution would be to use a simple majority vote, but this fails to account for the fact that LFs can vary widely in accuracy and coverage."}, {"id": 81, "string": "Instead, we use data programming (Ratner et al., 2016) , which models the relationship between the true labels and the output of the labeling functions as a factor graph."}, {"id": 82, "string": "More specifically, given the true labels Y \u2208 {\u22121, 1} n (latent) and label matrix \u039b \u2208 {\u22121, 0, 1} m\u00d7n (observed) where \u039b i,j = LF i (x j ), we define two types of factors representing labeling propensity and accuracy: \u03c6 Lab i,j (\u039b, Y ) = 1{\u039b i,j = 0} (1) \u03c6 Acc i,j (\u039b, Y ) = 1{\u039b i,j = y j }."}, {"id": 83, "string": "(2) Denoting the vector of factors pertaining to a given data point x j as \u03c6 j (\u039b, Y ) \u2208 R m , define the model: p w (\u039b, Y ) = Z \u22121 w exp n j=1 w \u00b7 \u03c6 j (\u039b, Y ) , (3) They include Joan Ridsdale, a 62-year-old payroll administrator from County Durham who was hit with a \u20ac16,000 tax bill when her husband Gordon died."}, {"id": 84, "string": "Spouse Disease Protein Example Explanation True, because the phrase \"her husband\" is within three words of person 2."}, {"id": 85, "string": "Example Explanation Young women on replacement estrogens for ovarian failure after cancer therapy may also have increased risk of endometrial carcinoma and should be examined periodically."}, {"id": 86, "string": "(person 1, person 2) (chemical, disease) (protein, kinase) True, because \"risk of\" comes before the disease."}, {"id": 87, "string": "Here we show that c-Jun N-terminal kinases JNK1, JNK2 and JNK3 phosphorylate tau at many serine/threonine-prolines, as assessed by the generation of the epitopes of phosphorylation-dependent anti-tau antibodies."}, {"id": 88, "string": "Example Explanation True, because at least one of the words 'phosphorylation', 'phosphorylate', 'phosphorylated', 'phosphorylates' is found in the sentence and the number of words between the protein and kinase is smaller than 8.\""}, {"id": 89, "string": "Figure 4 : An example and explanation for each of the three datasets."}, {"id": 90, "string": "where w \u2208 R 2m is the weight vector and Z w is the normalization constant."}, {"id": 91, "string": "To learn this model without knowing the true labels Y , we minimize the negative log marginal likelihood given the observed labels \u039b: w = arg min w \u2212 log Y p w (\u039b, Y ) (4) using SGD and Gibbs sampling for inference, and then use the marginals p\u0175(Y | \u039b) as probabilistic training labels."}, {"id": 92, "string": "Intuitively, we infer accuracies of the LFs based on the way they overlap and conflict with one another."}, {"id": 93, "string": "Since noisier LFs are more likely to have high conflict rates with others, their corresponding accuracy weights in w will be smaller, reducing their influence on the aggregated labels."}, {"id": 94, "string": "Discriminative Model The noisily-labeled training set that the label aggregator outputs is used to train an arbitrary discriminative model."}, {"id": 95, "string": "One advantage of training a discriminative model on the task instead of using the label aggregator as a classifier directly is that the label aggregator only takes into account those signals included in the LFs."}, {"id": 96, "string": "A discriminative model, on the other hand, can incorporate features that were not identified by the user but are nevertheless informative."}, {"id": 97, "string": "2 Consequently, even examples for which all LFs abstained can still be classified correctly."}, {"id": 98, "string": "On the three tasks we evaluate, using the discriminative model averages 4.3 F1 points higher than using the label aggregator directly."}, {"id": 99, "string": "For the results reported in this paper, our discriminative model is a simple logistic regression classifier with generic features defined over dependency paths."}, {"id": 100, "string": "3 bigrams, and trigrams of lemmas, dependency labels, and part of speech tags found in the siblings, parents, and nodes between the entities in the dependency parse of the sentence."}, {"id": 101, "string": "We found this to perform better on average than a biLSTM, particularly for the traditional supervision baselines with small training set sizes; it also provided easily interpretable features for analysis."}, {"id": 102, "string": "Experimental Setup We evaluate the accuracy of BabbleLabble on three relation extraction tasks, which we refer to as Spouse, Disease, and Protein."}, {"id": 103, "string": "The goal of each task is to train a classifier for predicting whether the two entities in an example are participating in the relationship of interest, as described below."}, {"id": 104, "string": "Datasets Statistics for each dataset are reported in Table 2, with one example and one explanation for each given in Figure 4 and additional explanations shown in Appendix B."}, {"id": 105, "string": "In the Spouse task, annotators were shown a sentence with two highlighted names and asked to label whether the sentence suggests that the two people are spouses."}, {"id": 106, "string": "Sentences were pulled from the Signal Media dataset of news articles (Corney , 2016) ."}, {"id": 107, "string": "Ground truth data was collected from Amazon Mechanical Turk workers, accepting the majority label over three annotations."}, {"id": 108, "string": "The 30 explanations we report on were sampled randomly from a pool of 200 that were generated by 10 graduate students unfamiliar with BabbleLabble."}, {"id": 109, "string": "In the Disease task, annotators were shown a sentence with highlighted names of a chemical and a disease and asked to label whether the sentence suggests that the chemical causes the disease."}, {"id": 110, "string": "Sentences and ground truth labels came from a portion of the 2015 BioCreative chemical-disease relation dataset (Wei et al., 2015) , which contains abstracts from PubMed."}, {"id": 111, "string": "Because this task requires specialized domain expertise, we obtained explanations by having someone unfamiliar with BabbleLabble translate from Python to natural language labeling functions from an existing publication that explored applying weak supervision to this task (Ratner et al., 2018) ."}, {"id": 112, "string": "The Protein task was completed in conjunction with OccamzRazor, a neuroscience company targeting biological pathways of Parkinson's disease."}, {"id": 113, "string": "For this task, annotators were shown a sentence from the relevant biomedical literature with highlighted names of a protein and a kinase and asked to label whether or not the kinase influences the protein in terms of a physical interaction or phosphorylation."}, {"id": 114, "string": "The annotators had domain expertise but minimal programming experience, making BabbleLabble a natural fit for their use case."}, {"id": 115, "string": "Experimental Settings Text documents are tokenized with spaCy."}, {"id": 116, "string": "4 The semantic parser is built on top of the Python-based 4 https://github.com/explosion/spaCy implementation SippyCup."}, {"id": 117, "string": "5 On a single core, parsing 360 explanations takes approximately two seconds."}, {"id": 118, "string": "We use existing implementations of the label aggregator, feature library, and discriminative classifier described in Sections 2.4-2.5 provided by the open-source project Snorkel (Ratner et al., 2018) ."}, {"id": 119, "string": "Hyperparameters for all methods we report were selected via random search over thirty configurations on the same held-out development set."}, {"id": 120, "string": "We searched over learning rate, batch size, L 2 regularization, and the subsampling rate (for improving balance between classes)."}, {"id": 121, "string": "6 All reported F1 scores are the average value of 40 runs with random seeds and otherwise identical settings."}, {"id": 122, "string": "Experimental Results We evaluate the performance of BabbleLabble with respect to its rate of improvement by number of user inputs, its dependence on correctly parsed logical forms, and the mechanism by which it utilizes logical forms."}, {"id": 123, "string": "High Bandwidth Supervision In Table 3 we report the average F1 score of a classifier trained with BabbleLabble using 30 explanations or traditional supervision with the indicated number of labels."}, {"id": 124, "string": "On average, it took the same amount of time to collect 30 explanations as 60 labels."}, {"id": 125, "string": "7 We observe that in all three tasks, BabbleLabble achieves a given F1 score with far fewer user inputs than traditional supervision, by Table 4 : The number of LFs generated from 30 explanations (pre-filters), discarded by the filter bank, and remaining (post-filters), along with the percentage of LFs that were correctly parsed from their corresponding explanations."}, {"id": 126, "string": "as much as 100 times in the case of the Spouse task."}, {"id": 127, "string": "Because explanations are applied to many unlabeled examples, each individual input from the user can implicitly contribute many (noisy) labels to the learning algorithm."}, {"id": 128, "string": "We also observe, however, that once the number of labeled examples is sufficiently large, traditional supervision once again dominates, since ground truth labels are preferable to noisy ones generated by labeling functions."}, {"id": 129, "string": "However, in domains where there is much more unlabeled data available than labeled data (which in our experience is most domains), we can gain in supervision efficiency from using BabbleLabble."}, {"id": 130, "string": "Of those explanations that did not produce a correct LF, 4% were caused by the explanation referring to unsupported concepts (e.g., one explanation referred to \"the subject of the sentence,\" which our simple parser doesn't support)."}, {"id": 131, "string": "Another 2% were caused by human errors (the correct LF for the explanation was inconsistent with the example)."}, {"id": 132, "string": "The remainder were due to unrecognized paraphrases (e.g., the explanation said \"the order of appearance is X, Y\" instead of a supported phrasing like \"X comes before Y\")."}, {"id": 133, "string": "Utility of Incorrect Parses In Table 4 , we report LF summary statistics before and after filtering."}, {"id": 134, "string": "LF correctness is based on exact match with a manually generated parse for each explanation."}, {"id": 135, "string": "Surprisingly, the simple heuristic-based filter bank successfully removes over 95% of incorrect LFs in all three tasks, resulting in final LF sets that are 86% correct on average."}, {"id": 136, "string": "Furthermore, among those LFs that pass through the filter bank, we found that the average difference in end-task accuracy between correct and incorrect parses is less than 2.5%."}, {"id": 137, "string": "Intuitively, the filters are effective because it is quite difficult for an LF to be parsed from the explana-  tion, label its own example correctly (passing the semantic filter), and not label all examples in the training set with the same label or identically to another LF (passing the pragmatic filter)."}, {"id": 138, "string": "We went one step further: using the LFs that would be produced by a perfect semantic parser as starting points, we searched for \"nearby\" LFs (LFs differing by only one predicate) with higher endtask accuracy on the test set and succeeded 57% of the time (see Figure 5 for an example)."}, {"id": 139, "string": "In other words, when users provide explanations, the signals they describe provide good starting points, but they are actually unlikely to be optimal."}, {"id": 140, "string": "This observation is further supported by Table 5 , which shows that the filter bank is necessary to remove clearly irrelevant LFs, but with that in place, the simple rule-based semantic parser and a perfect parser have nearly identical average F1 scores."}, {"id": 141, "string": "Using LFs as Functions or Features Once we have relevant logical forms from userprovided explanations, we have multiple options for how to use them."}, {"id": 142, "string": "Srivastava et al."}, {"id": 143, "string": "(2017) propose using these logical forms as features in a linear classifier."}, {"id": 144, "string": "We choose instead to use them as functions for weakly supervising the creation of a larger training set via data programming (Ratner et al., 2016) ."}, {"id": 145, "string": "In Table 6 , we compare the two approaches directly, finding that the the data programming approach outperforms a feature-based one by 9.5 F1 points with the rule-based parser, and by 4.5 points with a perfect parser."}, {"id": 146, "string": "We attribute this difference primarily to the ability of data programming to utilize unlabeled data."}, {"id": 147, "string": "In Figure 6 , we show how the data programming approach improves with the number of unlabeled examples, even as the number of LFs remains constant."}, {"id": 148, "string": "We also observe qualitatively that data programming exposes the classifier to additional patterns that are correlated with our explanations but not mentioned directly."}, {"id": 149, "string": "For example, in the Disease task, two of the features weighted most def LF_1a(x): return (-1 if any(w.startswith(\"improv\") for w in left(x.person2)) else 0) Correct False, because a word starting with \"improve\" appears before the chemical."}, {"id": 150, "string": "Incorrect Explanation Labeling Function Correctness Accuracy Figure 6 : When logical forms of natural language explanations are used as functions for data programming (as they are in BabbleLabble), performance can improve with the addition of unlabeled data, whereas using them as features does not benefit from unlabeled data."}, {"id": 151, "string": "highly by the discriminative model were the presence of the trigrams \"could produce a\" or \"support diagnosis of\" between the chemical and disease, despite none of these words occurring in the explanations for that task."}, {"id": 152, "string": "In Table 6 we see a 4.3 F1 point improvement (10%) when we use the discriminative model that can take advantage of these features rather than applying the LFs directly to the test set and making predictions based on the output of the label aggregator."}, {"id": 153, "string": "Related Work and Discussion Our work has two themes: modeling natural language explanations/instructions and learning from weak supervision."}, {"id": 154, "string": "The closest body of work is on \"learning from natural language.\""}, {"id": 155, "string": "As mentioned earlier, Srivastava et al."}, {"id": 156, "string": "(2017) convert natural language explanations into classifier features (whereas we convert them into labeling functions)."}, {"id": 157, "string": "Goldwasser and Roth (2011) Table 6 : F1 scores obtained using explanations as functions for data programming (BL) or features (Feat), optionally with no discriminative model (-DM) or using a perfect parser (+PP)."}, {"id": 158, "string": "guage into concepts (e.g., the rules of a card game)."}, {"id": 159, "string": "Ling and Fidler (2017) use natural language explanations to assist in supervising an image captioning model."}, {"id": 160, "string": "Weston (2016) ; Li et al."}, {"id": 161, "string": "(2016) learn from natural language feedback in a dialogue."}, {"id": 162, "string": "Wang et al."}, {"id": 163, "string": "(2017) convert natural language definitions to rules in a semantic parser to build up progressively higher-level concepts."}, {"id": 164, "string": "We lean on the formalism of semantic parsing (Zelle and Mooney, 1996; Zettlemoyer and Collins, 2005; Liang, 2016) ."}, {"id": 165, "string": "One notable trend is to learn semantic parsers from weak supervision (Clarke et al., 2010; Liang et al., 2011) , whereas our goal is to obtain weak supervision signal from semantic parsers."}, {"id": 166, "string": "The broader topic of weak supervision has received much attention; we mention some works most related to relation extraction."}, {"id": 167, "string": "In distant supervision (Craven et al., 1999; Mintz et al., 2009) and multi-instance learning (Riedel et al., 2010; Hoffmann et al., 2011) , an existing knowledge base is used to (probabilistically) impute a training set."}, {"id": 168, "string": "Various extensions have focused on aggregating a variety of supervision sources by learning generative models from noisy labels (Alfonseca et al., 2012; Takamatsu et al., 2012; Roth and Klakow, 2013; Ratner et al., 2016; Varma et al., 2017) ."}, {"id": 169, "string": "Finally, while we have used natural language explanations as input to train models, they can also be output to interpret models (Krening et al., 2017; Lei et al., 2016) ."}, {"id": 170, "string": "More generally, from a machine learning perspective, labels are the primary asset, but they are a low bandwidth signal between annotators and the learning algorithm."}, {"id": 171, "string": "Natural language opens up a much higher-bandwidth communication channel."}, {"id": 172, "string": "We have shown promising results in relation extraction (where one explanation can be \"worth\" 100 labels), and it would be interesting to extend our framework to other tasks and more interactive settings."}, {"id": 173, "string": "Reproducibility The code, data, and experiments for this paper are available on the CodaLab platform at https: //worksheets.codalab.org/worksheets/ 0x900e7e41deaa4ec5b2fe41dc50594548/."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 33}, {"section": "The BabbleLabble Framework", "n": "2", "start": 34, "end": 42}, {"section": "Explanations", "n": "2.1", "start": 43, "end": 45}, {"section": "Semantic Parser", "n": "2.2", "start": 46, "end": 64}, {"section": "Filter Bank", "n": "2.3", "start": 65, "end": 77}, {"section": "Label Aggregator", "n": "2.4", "start": 78, "end": 93}, {"section": "Discriminative Model", "n": "2.5", "start": 94, "end": 101}, {"section": "Experimental Setup", "n": "3", "start": 102, "end": 103}, {"section": "Datasets", "n": "3.1", "start": 104, "end": 114}, {"section": "Experimental Settings", "n": "3.2", "start": 115, "end": 119}, {"section": "Experimental Results", "n": "4", "start": 120, "end": 122}, {"section": "High Bandwidth Supervision", "n": "4.1", "start": 123, "end": 132}, {"section": "Utility of Incorrect Parses", "n": "4.2", "start": 133, "end": 140}, {"section": "Using LFs as Functions or Features", "n": "4.3", "start": 141, "end": 152}, {"section": "Related Work and Discussion", "n": "5", "start": 153, "end": 173}], "figures": [{"filename": "../figure/image/1319-Figure1-1.png", "caption": "Figure 1: In BabbleLabble, the user provides a natural language explanation for each labeling decision. These explanations are parsed into labeling functions that convert unlabeled data into a large labeled dataset for training a classifier.", "page": 0, "bbox": {"x1": 310.56, "x2": 523.1999999999999, "y1": 246.72, "y2": 445.91999999999996}}, {"filename": "../figure/image/1319-Table3-1.png", "caption": "Table 3: F1 scores obtained by a classifier trained with BabbleLabble (BL) using 30 explanations or with traditional supervision (TS) using the specified number of individually labeled examples. BabbleLabble achieves the same F1 score as traditional supervision while using fewer user inputs by a factor of over 5 (Protein) to over 100 (Spouse).", "page": 5, "bbox": {"x1": 72.0, "x2": 526.0799999999999, "y1": 68.64, "y2": 167.04}}, {"filename": "../figure/image/1319-Figure2-1.png", "caption": "Figure 2: Natural language explanations are parsed into candidate labeling functions (LFs). Many incorrect LFs are filtered out automatically by the filter bank. The remaining functions provide heuristic labels over the unlabeled dataset, which are aggregated into one noisy label per example, yielding a large, noisily-labeled training set for a classifier.", "page": 1, "bbox": {"x1": 84.96, "x2": 511.2, "y1": 66.72, "y2": 256.32}}, {"filename": "../figure/image/1319-Table4-1.png", "caption": "Table 4: The number of LFs generated from 30 explanations (pre-filters), discarded by the filter bank, and remaining (post-filters), along with the percentage of LFs that were correctly parsed from their corresponding explanations.", "page": 6, "bbox": {"x1": 72.96, "x2": 289.44, "y1": 62.4, "y2": 130.07999999999998}}, {"filename": "../figure/image/1319-Table5-1.png", "caption": "Table 5: F1 scores obtained using BabbleLabble with no filter bank (BL-FB), as normal (BL), and with a perfect parser (BL+PP) simulated by hand.", "page": 6, "bbox": {"x1": 306.71999999999997, "x2": 528.0, "y1": 62.4, "y2": 130.07999999999998}}, {"filename": "../figure/image/1319-Figure3-1.png", "caption": "Figure 3: Valid parses are found by iterating over increasingly large subspans of the input looking for matches among the right hand sides of the rules in the grammar. Rules are either lexical (converting tokens into symbols), unary (converting one symbol into another symbol), or compositional (combining many symbols into a single higher-order symbol). A rule may optionally ignore unrecognized tokens in a span (denoted here with a dashed line).", "page": 2, "bbox": {"x1": 121.92, "x2": 477.12, "y1": 66.72, "y2": 204.95999999999998}}, {"filename": "../figure/image/1319-Table6-1.png", "caption": "Table 6: F1 scores obtained using explanations as functions for data programming (BL) or features (Feat), optionally with no discriminative model (-DM) or using a perfect parser (+PP).", "page": 7, "bbox": {"x1": 308.64, "x2": 523.1999999999999, "y1": 227.51999999999998, "y2": 295.2}}, {"filename": "../figure/image/1319-Figure5-1.png", "caption": "Figure 5: Incorrect LFs often still provide useful signal. On top is an incorrect LF produced for the Disease task that had the same accuracy as the correct LF. On bottom is a correct LF from the Spouse task and a more accurate incorrect LF discovered by randomly perturbing one predicate at a time as described in Section 4.2. (Person 2 is always the second person in the sentence).", "page": 7, "bbox": {"x1": 74.88, "x2": 524.16, "y1": 65.75999999999999, "y2": 148.32}}, {"filename": "../figure/image/1319-Figure6-1.png", "caption": "Figure 6: When logical forms of natural language explanations are used as functions for data programming (as they are in BabbleLabble), performance can improve with the addition of unlabeled data, whereas using them as features does not benefit from unlabeled data.", "page": 7, "bbox": {"x1": 76.32, "x2": 267.36, "y1": 229.44, "y2": 372.47999999999996}}, {"filename": "../figure/image/1319-Table1-1.png", "caption": "Table 1: Predicates in the grammar supported by BabbleLabble\u2019s rule-based semantic parser.", "page": 3, "bbox": {"x1": 72.0, "x2": 295.2, "y1": 62.4, "y2": 420.0}}, {"filename": "../figure/image/1319-Table2-1.png", "caption": "Table 2: The total number of unlabeled training examples (a pair of annotated entities in a sentence), labeled development examples (for hyperparameter tuning), labeled test examples (for assessment), and the fraction of positive labels in the test split.", "page": 4, "bbox": {"x1": 307.68, "x2": 525.12, "y1": 204.48, "y2": 271.2}}, {"filename": "../figure/image/1319-Figure4-1.png", "caption": "Figure 4: An example and explanation for each of the three datasets.", "page": 4, "bbox": {"x1": 75.84, "x2": 524.16, "y1": 64.32, "y2": 164.16}}]}