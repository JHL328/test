{"title": "SEQ 3 : Differentiable Sequence-to-Sequence-to-Sequence Autoencoder for Unsupervised Abstractive Sentence Compression", "abstract": "Neural sequence-to-sequence models are currently the dominant approach in several natural language processing tasks, but require large parallel corpora. We present a sequenceto-sequence-to-sequence autoencoder (SEQ 3 ), consisting of two chained encoder-decoder pairs, with words used as a sequence of discrete latent variables. We apply the proposed model to unsupervised abstractive sentence compression, where the first and last sequences are the input and reconstructed sentences, respectively, while the middle sequence is the compressed sentence. Constraining the length of the latent word sequences forces the model to distill important information from the input. A pretrained language model, acting as a prior over the latent sequences, encourages the compressed sentences to be human-readable. Continuous relaxations enable us to sample from categorical distributions, allowing gradient-based optimization, unlike alternatives that rely on reinforcement learning. The proposed model does not require parallel text-summary pairs, achieving promising results in unsupervised sentence compression on benchmark datasets.", "text": [{"id": 0, "string": "Introduction Neural sequence-to-sequence models (SEQ2SEQ) perform impressively well in several natural language processing tasks, such as machine translation (Sutskever et al., 2014; Bahdanau et al., 2015) or syntactic constituency parsing (Vinyals et al., 2015) ."}, {"id": 1, "string": "However, they require massive parallel training datasets (Koehn and Knowles, 2017) ."}, {"id": 2, "string": "Consequently there has been extensive work on utilizing non-parallel corpora to boost the performance of SEQ2SEQ models (Sennrich et al., 2016; G\u00fcl\u00e7ehre et al., 2015) , mostly in neural machine translation where models that require absolutely no parallel corpora have also been pro- posed (Artetxe et al., 2018; Lample et al., 2018b) ."}, {"id": 3, "string": "Unsupervised (or semi-supervised) SEQ2SEQ models have also been proposed for summarization tasks with no (or small) parallel text-summary sets, including unsupervised sentence compression."}, {"id": 4, "string": "Current models, however, barely reach lead-N baselines (Fevry and Phang, 2018; Wang and Lee, 2018) , and/or are non-differentiable (Wang and Lee, 2018; Miao and Blunsom, 2016) , thus relying on reinforcement learning, which is unstable and inefficient."}, {"id": 5, "string": "By contrast, we propose a sequence-to-sequence-to-sequence autoencoder, dubbed SEQ 3 , that can be trained end-to-end via gradient-based optimization."}, {"id": 6, "string": "SEQ 3 employs differentiable approximations for sampling from categorical distributions (Maddison et al., 2017; Jang et al., 2017) , which have been shown to outperform reinforcement learning (Havrylov and Titov, 2017) ."}, {"id": 7, "string": "Therefore it is a generic framework which can be easily extended to other tasks, e.g., machine translation and semantic parsing via task-specific losses."}, {"id": 8, "string": "In this work, as a first step, we apply SEQ 3 to unsupervised abstractive sentence compression."}, {"id": 9, "string": "SEQ 3 ( \u00a72) comprises two attentional encoderdecoder (Bahdanau et al., 2015) pairs (Fig."}, {"id": 10, "string": "1) : a compressor C and a reconstructor R. C ( \u00a72.1) receives an input text x = \u27e8x 1 , ."}, {"id": 11, "string": "."}, {"id": 12, "string": "."}, {"id": 13, "string": ", x N \u27e9 of N words, and generates a summary y = \u27e8y 1 , ."}, {"id": 14, "string": "."}, {"id": 15, "string": "."}, {"id": 16, "string": ", y M \u27e9 of M words (M<N), y being a latent variable."}, {"id": 17, "string": "R and C communicate only through the discrete words of the summary y ( \u00a72.2)."}, {"id": 18, "string": "R ( \u00a72.3) produces a sequencex = \u27e8x 1 , ."}, {"id": 19, "string": "."}, {"id": 20, "string": "."}, {"id": 21, "string": ",x N \u27e9 of N words from y, try- Figure 2 : More detailed illustration of SEQ 3 ."}, {"id": 22, "string": "The compressor (C) produces a summary from the input text, and the reconstructor (R) tries to reproduce the input from the summary."}, {"id": 23, "string": "R and C comprise an attentional encoder-decoder each, and communicate only through the (discrete) words of the summary."}, {"id": 24, "string": "The LM prior incentivizes C to produce human-readable summaries, while topic loss rewards summaries with similar topicindicating words as the input text."}, {"id": 25, "string": "ing to minimize a reconstruction loss L R = (x,x) ( \u00a72.5)."}, {"id": 26, "string": "A pretrained language model acts as a prior on y, introducing an additional loss L P (x, y) that encourages SEQ 3 to produce human-readable summaries."}, {"id": 27, "string": "A third loss L T (x, y) rewards summaries y with similar topic-indicating words as x."}, {"id": 28, "string": "Experiments ( \u00a73) on the Gigaword sentence compression dataset (Rush et al., 2015) and the DUC-2003 and DUC-2004 shared tasks (Over et al., 2007) produce promising results."}, {"id": 29, "string": "Our contributions are: (1) a fully differentiable sequence-to-sequence-to-sequence (SEQ 3 ) autoencoder that can be trained without parallel data via gradient optimization; (2) an application of SEQ 3 to unsupervised abstractive sentence compression, with additional task-specific loss functions; (3) state of the art performance in unsupervised abstractive sentence compression."}, {"id": 30, "string": "This work is a step towards exploring the potential of SEQ 3 in other tasks, such as machine translation."}, {"id": 31, "string": "Proposed Model Compressor The bottom left part of Fig."}, {"id": 32, "string": "2 illustrates the internals of the compressor C. An embedding layer projects the source sequence x to the word embeddings e s = \u27e8e s 1 , ."}, {"id": 33, "string": "."}, {"id": 34, "string": "."}, {"id": 35, "string": ", e s N \u27e9, which are then en-coded by a bidirectional RNN, producing h s = \u27e8h s 1 , ."}, {"id": 36, "string": "."}, {"id": 37, "string": "."}, {"id": 38, "string": ", h s N \u27e9."}, {"id": 39, "string": "Each h s t is the concatenation of the corresponding left-to-right and right-to-left states (outputs in LSTMs) of the bi-RNN."}, {"id": 40, "string": "h s t = [ \u2212 \u2212 \u2192 RNN s (e s t , \u2212 \u2192 h s t\u22121 ); \u2190 \u2212 \u2212 RNN s (e s t , \u2190 \u2212 h s t+1 )] To generate the summary y, we employ the attentional RNN decoder of Luong et al."}, {"id": 41, "string": "(2015) , with their global attention and input feeding."}, {"id": 42, "string": "Concretely, at each timestep (t \u2208 {1, ."}, {"id": 43, "string": "."}, {"id": 44, "string": "."}, {"id": 45, "string": ", M}) we compute a probability distribution a i over all the states h s 1 , ."}, {"id": 46, "string": "."}, {"id": 47, "string": "."}, {"id": 48, "string": ", h s N of the source encoder conditioned on the current state h c t of the compressor's decoder to produce a context vector c t ."}, {"id": 49, "string": "a i = softmax(h s i \u22ba W a h c t ), c t = N \u2211 i=1 a i h s i The matrix W a is learned."}, {"id": 50, "string": "We obtain a probability distribution for y t over the vocabulary V by combining c t and the current state h c t of the decoder."}, {"id": 51, "string": "o c t = tanh(W o [c t ; h c t ] + b o ) (1) u c t = W v o c t + b v (2) p(y t |y <t , x) = softmax(u c t ) (3) W o , b o , W v , b v are learned."}, {"id": 52, "string": "c t is also used when updating the state h c t of the decoder, along with the embedding e c t of y t and a countdown argument M \u2212 t (scaled by a learnable w d ) indicating the number of the remaining words of the summary (Fevry and Phang, 2018; Kikuchi et al., 2016) ."}, {"id": 53, "string": "h c t+1 = \u2212 \u2212 \u2192 RNN c (h c t , e c t , c t , w d (M \u2212 t)) (4) For each input x = \u27e8x 1 , ."}, {"id": 54, "string": "."}, {"id": 55, "string": "."}, {"id": 56, "string": ", x N \u27e9, we obtain a target length M for the summary y = \u27e8y 1 , ."}, {"id": 57, "string": "."}, {"id": 58, "string": "."}, {"id": 59, "string": ", y M \u27e9 by sampling (and rounding) from a uniform distribution U (\u03b1N, \u03b2N); \u03b1, \u03b2 are hyper-parameters (\u03b1 < \u03b2 < 1); we set M = 5, if the sampled M is smaller."}, {"id": 60, "string": "Sampling M, instead of using a static compression ratio, allows us to train a model capable of producing summaries with varying (e.g., user-specified) compression ratios."}, {"id": 61, "string": "Controlling the output length in encoder-decoder architectures has been explored in machine translation (Kikuchi et al., 2016) and summarization (Fan et al., 2018) ."}, {"id": 62, "string": "Differentiable Word Sampling To generate the summary, we need to sample its words y t from the categorical distributions p(y t |y <t , x), which is a non-differentiable process."}, {"id": 63, "string": "Soft-Argmax Instead of sampling y t , a simple workaround during training is to pass as input to the next timestep of C's decoder and to the corresponding timestep of R's encoder a weighted sum of all the vocabulary's (V ) word embeddings, using a peaked softmax function (Goyal et al., 2017) : e c t = |V | \u2211 i e(w i ) softmax(u c t /\u03c4 ) (5) where u c t is the unnormalized score in Eq."}, {"id": 64, "string": "2 (i.e., the logit) of each word w i and \u03c4 \u2208 (0, \u221e) is the temperature."}, {"id": 65, "string": "As \u03c4 \u2192 0 most of the probability mass in Eq."}, {"id": 66, "string": "5 goes to the most probable word, hence the operation approaches the arg max."}, {"id": 67, "string": "Gumbel-Softmax We still want to be able to perform sampling, though, as it has the benefit of adding stochasticity and facilitating exploration of the parameter space."}, {"id": 68, "string": "Hence, we use the Gumbel-Softmax (GS) reparametrization trick (Maddison et al., 2017; Jang et al., 2017) as a low variance approximation of sampling from categorical distributions."}, {"id": 69, "string": "Sampling a specific word y t from the softmax (Eq."}, {"id": 70, "string": "3) is equivalent to adding (element-wise) to the logits an independent noise sample \u03be from the Gumbel distribution 1 and taking the arg max: y t \u223c softmax(u c t ) \u2194 y t = arg max(u c t + \u03be) (6) Therefore, using the GS trick, Eq."}, {"id": 71, "string": "5 becomes: e c t = |V | \u2211 i e(w i ) softmax((u c t + \u03be)/\u03c4 ) (7) Straight-Through Both relaxations lead to mixtures of embeddings, which do not correspond to actual words."}, {"id": 72, "string": "Even though this enables the compressor to communicate with the reconstructor using continuous values, thus fully utilizing the available embedding space, ultimately our aim is to constrain them to communicate using only natural language."}, {"id": 73, "string": "In addition, an unwanted discrepancy is created between training (continuous embeddings) and test time (discrete embeddings)."}, {"id": 74, "string": "We alleviate these problems with the Straight-Through estimator (ST) (Bengio et al., 2013) ."}, {"id": 75, "string": "Specifically, in the forward pass of training we discretize\u1ebd c t by using the arg max (Eq."}, {"id": 76, "string": "6), whereas in the backward pass we compute the gradients using the GS (Eq."}, {"id": 77, "string": "7)."}, {"id": 78, "string": "This is a biased estimator due 1 \u03bei = \u2212 log(\u2212 log(xi)), xi \u223c U (0, 1) to the mismatch between the forward and backward passes, but works well in practice."}, {"id": 79, "string": "ST GS reportedly outperforms scheduled sampling (Goyal et al., 2017) and converges faster than reinforcement learning (Havrylov and Titov, 2017) ."}, {"id": 80, "string": "Reconstructor The reconstructor (upper right of Fig."}, {"id": 81, "string": "2 ) works like the compressor, but its encoder operates on the embeddings e c 1 , ."}, {"id": 82, "string": "."}, {"id": 83, "string": "."}, {"id": 84, "string": ", e c M of the words y 1 , ."}, {"id": 85, "string": "."}, {"id": 86, "string": "."}, {"id": 87, "string": ", y M of the summary (exact embeddings of the sampled words y t in the forward pass, approximate differentiable embeddings in the backward pass)."}, {"id": 88, "string": "Decoder Initialization We initialize the hidden state of each decoder using a transformation of the concatenation [ \u2212 \u2192 h s N ; \u2190 \u2212 h s 1 ] of the last hidden states (from the two directions) of its bidirectional encoder and a length vector, following Mallinson et al."}, {"id": 89, "string": "(2018) ."}, {"id": 90, "string": "The length vector for the decoder of the compressor C consists of the target summary length M, scaled by a learnable parameter w v , and the compression ratio M N ."}, {"id": 91, "string": "h c 0 = tanh(W c [ \u2212 \u2192 h s N ; \u2190 \u2212 h s 1 ; w v M ; M N ]) W c is a trainable hidden layer."}, {"id": 92, "string": "The decoder of the reconstructor R is initialized similarly."}, {"id": 93, "string": "Loss Functions Reconstruction Loss L R (x,x) is the (negative) log-likelihood assigned by the (decoder of) R to the input (correctly reconstructed) words x = \u27e8x 1 , ."}, {"id": 94, "string": "."}, {"id": 95, "string": "."}, {"id": 96, "string": ", x N \u27e9, where p R is the distribution of R. L R (x,x) = \u2212 N \u2211 i=1 log p R (x i = x i ) We do not expect L R (x,x) to decrease to zero, as there is information loss through the compression."}, {"id": 97, "string": "However, we expect it to drive the compressor to produce such sentences that will increase the likelihood of the target words in the reconstruction."}, {"id": 98, "string": "LM Prior Loss To ensure that the summaries y are readable, we pretrain an RNN language model (see Appendix) on the source texts of the full training set."}, {"id": 99, "string": "We compute the Kullback-Leibler divergence D KL between the probability distributions of the (decoder of) the compressor (p(y t |y <t , x), Eq."}, {"id": 100, "string": "3) and the language model (p LM (y t |y <t , x))."}, {"id": 101, "string": "Similar priors have been used in sentence compression (Miao and Blunsom, 2016) and agent communication (Havrylov and Titov, 2017) ."}, {"id": 102, "string": "We also use the following task-specific losses."}, {"id": 103, "string": "Topic Loss Words with high TF-IDF scores are indicative of the topic of a text (Ramos et al., 2003; Erkan and Radev, 2004) ."}, {"id": 104, "string": "To encourage the compressor to preserve in the summary y the topicindicating words of the input x, we compute the TF-IDF-weighted average v x of the word embeddings of x and the average v y of the word embeddings of y and use their cosine distance as an ad- ditional loss L T = 1 \u2212 cos(v x , v y )."}, {"id": 105, "string": "v x = N \u2211 i=1 IDF(x i ) e s i \u2211 N t=1 IDF(x t ) v y = 1 M M \u2211 i=1 e c i (Using TF-IDF in v y did not help.)"}, {"id": 106, "string": "All IDF scores are computed on the training set."}, {"id": 107, "string": "Length Penalty A fourth loss L L (not shown in Fig."}, {"id": 108, "string": "1 ) helps the (decoder of the) compressor to predict the end-of-sequence (EOS) token at the target summary length M. L L is the cross-entropy between the distributions p(y t |y <t , x) (Eq."}, {"id": 109, "string": "3) of the compressor at t = M + 1 and onward, with the one-hot distribution of the EOS token."}, {"id": 110, "string": "Modeling Details Parameter Sharing We tie the weights of layers encoding similar information, to reduce the number of trainable parameters."}, {"id": 111, "string": "First, we use a shared embedding layer for the encoders and decoders, initialized with 100-dimensional GloVe embeddings (Pennington et al., 2014) ."}, {"id": 112, "string": "Additionally, we tie the shared embedding layer with the output layers of both decoders (Press and Wolf, 2017; Inan et al., 2017) ."}, {"id": 113, "string": "Finally, we tie the encoders of the compressor and reconstructor (see Appendix)."}, {"id": 114, "string": "OOVs Out-of-vocabulary words are handled as in Fevry and Phang (2018) (see Appendix)."}, {"id": 115, "string": "Experiments Datasets We train SEQ 3 on the Gigaword sentence compression dataset (Rush et al., 2015) ."}, {"id": 116, "string": "2 It consists of pairs, each containing the first sentence of a news article (x) and the article's headline (y), a total of 3.8M/189k/1951 train/dev/test pairs."}, {"id": 117, "string": "We also test (without retraining) SEQ 3 on DUC-2003 and DUC-2004 shared tasks (Over et al., 2007) , containing 624/500 news articles each, paired with 4 reference summaries capped at 75 bytes."}, {"id": 118, "string": "Methods compared We evaluated SEQ 3 and an ablated version of SEQ 3 ."}, {"id": 119, "string": "We only used the article 2 github.com/harvardnlp/sent-summary sentences (sources) of the training pairs from Gigaword to train SEQ 3 ; our model is never exposed to target headlines (summaries) during training or evaluation, i.e., it is completely unsupervised."}, {"id": 120, "string": "Our code is publicly available."}, {"id": 121, "string": "3 We compare SEQ 3 to other unsupervised sentence compression models."}, {"id": 122, "string": "We note that the extractive model of Miao and Blunsom (2016) relies on a pre-trained attention model using at least 500K parallel sentences, which is crucial to mitigate the inefficiency of sampling-based variational inference and REINFORCE."}, {"id": 123, "string": "Therefore it is not comparable, as it is semi-supervised."}, {"id": 124, "string": "The results of the extractive model of Fevry and Phang (2018) are also not comparable, as they were obtained on a different, not publicly available test set."}, {"id": 125, "string": "We note, however, that they report that their system performs worse than the LEAD-8 baseline in ROUGE-2 and ROUGE-L on Gigaword."}, {"id": 126, "string": "The only directly comparable unsupervised model is the abstractive 'Pretrained Generator' of Wang and Lee (2018) ."}, {"id": 127, "string": "The version of 'Adversarial REINFORCE' that Wang and Lee (2018) consider unsupervised is actually weakly supervised, since its discriminator was exposed to the summaries of the same sources the rest of the model was trained on."}, {"id": 128, "string": "As baselines, we use LEAD-8 for Gigaword, which simply selects the first 8 words of the source, and PREFIX for DUC, which includes the first 75 bytes of the source article."}, {"id": 129, "string": "We also compare to supervised abstractive sentence compression methods (Tables 1-3 )."}, {"id": 130, "string": "Following previous work, we report the average F1 of ROUGE-1, ROUGE-2, ROUGE-L (Lin, 2004) ."}, {"id": 131, "string": "We implemented SEQ 3 with LSTMs (see Appendix) and during inference we perform greedy-sampling."}, {"id": 132, "string": "Results Table 1 reports the Gigaword results."}, {"id": 133, "string": "SEQ 3 outperforms the unsupervised Pretrained Generator across all metrics by a large margin."}, {"id": 134, "string": "It also surpasses LEAD-8."}, {"id": 135, "string": "If we remove the LM prior, performance drops, esp."}, {"id": 136, "string": "in ROUGE-2 and ROUGE-L."}, {"id": 137, "string": "This makes sense, since the pretrained LM rewards correct word order."}, {"id": 138, "string": "We also tried removing the topic loss, but the model failed to converge and results were extremely poor (Table 1) ."}, {"id": 139, "string": "Topic loss acts as a bootstrap mechanism, biasing the compressor to generate words that maintain the topic of the input text."}, {"id": 140, "string": "This greatly reduces variance due to sampling in early stages of training, alleviating the need to pretrain individual ABS (Rush et al., 2015) 29.55 11.32 26.42 SEASS (Zhou et al., 2017) 36.15 17.54 33.63 words-lvt5k-1sent (Nallapati et al., 2016) 36 (Rush et al., 2015) 28 (Zajic et al., 2007 ) 25.12 6.46 20.12 Woodsend et al."}, {"id": 141, "string": "(2010 22 6 17 ABS (Rush et al., 2015) 28  components, unlike works that rely on reinforcement learning (Miao and Blunsom, 2016; Wang and Lee, 2018) ."}, {"id": 142, "string": "Overall, both losses work in synergy, with the topic loss driving what and the LM prior loss driving how words should be included in the summary."}, {"id": 143, "string": "SEQ 3 behaves similarly on DUC-2003 and DUC-2004 (Tables 2-3) , although it was trained on Gigaword."}, {"id": 144, "string": "In DUC-2003, however, it does not surpass the PREFIX baseline."}, {"id": 145, "string": "Finally, Fig."}, {"id": 146, "string": "3 illustrates three randomly sampled outputs of SEQ 3 on Gigaword."}, {"id": 147, "string": "In the first one, SEQ 3 copies several words esp."}, {"id": 148, "string": "from the beginning of the input (hence the high ROUGE-L) exhibiting extractive capabilities, though still being adequately abstractive (bold words denote paraphrases)."}, {"id": 149, "string": "In the second one, SEQ 3 showcases its true abstractive power by paraphrasing and compressing multi-word expressions to single content words more heavily, still without losing the overall meaning."}, {"id": 150, "string": "In the last example, SEQ 3 progressively becomes ungrammatical though interestingly retaining some content words from the input."}, {"id": 151, "string": "Limitations and Future Work The model tends to copy the first words of the input sentence in the compressed text (Fig."}, {"id": 152, "string": "3 )."}, {"id": 153, "string": "We input: the american sailors who thwarted somali pirates flew home to the u.s. on wednesday but without their captain , who was still aboard a navy destroyer after being rescued from the hijackers ."}, {"id": 154, "string": "gold: us sailors who thwarted pirate hijackers fly home SEQ 3 : the american sailors who foiled somali pirates flew home after crew hijacked ."}, {"id": 155, "string": "input: the central election commission -lrb-cec -rrb-on monday decided that taiwan will hold another election of national assembly members on may # ."}, {"id": 156, "string": "gold: national <unk> election scheduled for may input: dave bassett resigned as manager of struggling english premier league side nottingham forest on saturday after they were knocked out of the f.a."}, {"id": 157, "string": "cup in the third round , according to local reports on saturday ."}, {"id": 158, "string": "gold: forest manager bassett quits ."}, {"id": 159, "string": "hypothesize that since the reconstructor is autoregressive, i.e., each word is conditioned on the previous one, errors occurring early in the generated sequence have cascading effects."}, {"id": 160, "string": "This inevitably encourages the compressor to select the first words of the input."}, {"id": 161, "string": "A possible workaround might be to modify SEQ 3 so that the first encoder-decoder pair would turn the inputs to longer sequences, and the second encoder-decoder would compress them trying to reconstruct the original inputs."}, {"id": 162, "string": "In future work, we plan to explore the potential of SEQ 3 in other tasks, such as unsupervised machine translation (Lample et al., 2018a; Artetxe et al., 2018) and caption generation ."}, {"id": 163, "string": "A Appendix A.1 Temperature for Gumbel-Softmax Even though the value of the temperature \u03c4 does not affect the forward pass, it greatly affects the gradient computation and therefore the learning process."}, {"id": 164, "string": "Jang et al."}, {"id": 165, "string": "(2017) propose to anneal \u03c4 during training towards zero."}, {"id": 166, "string": "Gulcehre et al."}, {"id": 167, "string": "(2017) propose to learn \u03c4 as a function of the compressor's decoder state h c t , in order to reduce hyperparameter tuning: \u03c4 (h c t ) = 1 log(1 + exp(w \u22ba \u03c4 h c t )) + 1 (8) where w \u03c4 is a trainable parameter and \u03c4 (h c t ) \u2208 (0, 1)."}, {"id": 168, "string": "Havrylov and Titov (2017) In our experiments, we had convergence problems with the learned temperature technique."}, {"id": 169, "string": "We found that the compressor preferred values close to the upper bound, which led to unstable training, forcing us to set \u03c4 0 > 1 to stabilize the training process."}, {"id": 170, "string": "Our findings align with the behavior reported by Gu et al."}, {"id": 171, "string": "(2018) ."}, {"id": 172, "string": "Consequently, we follow their choice and fix \u03c4 = 0.5, which worked well in practice."}, {"id": 173, "string": "A.2 Out of Vocabulary (OOV) Words The vocabulary of our experiments comprises the 15k most frequent words of Gigaword's training input texts (without looking at their summaries)."}, {"id": 174, "string": "To handle OOVs, we adopt the approach of Fevry and Phang (2018) , which can be thought of as a simpler form of copying compared to pointer networks (See et al., 2017) ."}, {"id": 175, "string": "We use a small set (10 in our experiments) of special OOV tokens OOV 1 , OOV 2 , ."}, {"id": 176, "string": "."}, {"id": 177, "string": "."}, {"id": 178, "string": ", OOV 10 , whose embeddings are updated during learning."}, {"id": 179, "string": "Given an input text x = \u27e8x 1 , ."}, {"id": 180, "string": "."}, {"id": 181, "string": "."}, {"id": 182, "string": ", x N \u27e9, we replace (before feeding x to SEQ 3 ) each unknown word x i with the first unused (for the particular x) OOV token, taking care to use the same OOV token for all the occurrences of the same unknown word in x."}, {"id": 183, "string": "For example, if 'John' and 'Rome' are not in the vocabulary, then \"John arrived in Rome yesterday."}, {"id": 184, "string": "While in Rome, John had fun.\""}, {"id": 185, "string": "becomes \"OOV 1 arrived in OOV 2 yesterday."}, {"id": 186, "string": "While in OOV 2 , OOV 1 had fun.\""}, {"id": 187, "string": "If a new unknown word x i is encountered in x and all the available OOV tokens have been used, x i is replaced by 'UNK', whose embedding is also updated during learning."}, {"id": 188, "string": "The OOV tokens (and 'UNK') are included in the vocabulary, and SEQ 3 learns to predict them as summary words, in effect copying the corresponding unknown words of x."}, {"id": 189, "string": "At test time, we replace the OOV tokens with the corresponding unknown words."}, {"id": 190, "string": "A.3 Reconstruction Word Drop Our model is an instance of Variational Auto-Encoders (VAE) (Kingma and Welling, 2014)."}, {"id": 191, "string": "A common problem in VAEs is that the reconstructor tends to disregard the latent variable."}, {"id": 192, "string": "We weaken the reconstructor R, in order to force it to fully utilize the latent sequence y to generatex."}, {"id": 193, "string": "To this end, we employ word dropout as in Bowman et al."}, {"id": 194, "string": "(2016) and randomly drop a percentage of the input words, thus forcing R to rely solely on y to make good reconstructions."}, {"id": 195, "string": "A.4 Implementation and Hyper-parameters We implemented SEQ 3 in PyTorch (Paszke et al., 2017) ."}, {"id": 196, "string": "All the RNNs are LSTMs (Hochreiter and Schmidhuber, 1997) ."}, {"id": 197, "string": "We use a shared encoder for the compressor and the reconstructor, consisting of a two-layer bidirectional LSTM with size 300 per direction."}, {"id": 198, "string": "We use separate decoders for the compressor and the reconstructor; each decoder is a two-layer unidirectional LSTM with size 300."}, {"id": 199, "string": "The (shared) embedding layer of the compressor and the reconstructor is initialized with 100-dimensional GloVe embeddings (Pennington et al., 2014) and is tied with the output (projec-tion) layers of the decoders and jointly finetuned during training."}, {"id": 200, "string": "We apply layer normalization (Ba et al., 2016) to the context vectors (Eq."}, {"id": 201, "string": "1) of the compressor and the reconstructor."}, {"id": 202, "string": "We apply word dropout ( \u00a7A.3) to the reconstructor with p = 0.5."}, {"id": 203, "string": "During training, the summary length M is sampled from U (0.4 N, 0.6 N) ; during testing, M = 0.5 N. The four losses are summed, \u03bbs being scalar hyper-parameters."}, {"id": 204, "string": "L = \u03bb R L R + \u03bb P L P + \u03bb T L T + \u03bb L L L We set \u03bb R = \u03bb T = 1, \u03bb L = \u03bb P = 0.1."}, {"id": 205, "string": "We use the Adam (Kingma and  optimizer, with batch size 128 and the default learning rate 0.001."}, {"id": 206, "string": "The network is trained for 5 epochs."}, {"id": 207, "string": "LM Prior The pretrained language model is a two-layer LSTM of size 1024 per layer."}, {"id": 208, "string": "It uses its own embedding layer of size 256, which is randomly initialized and updated when training the language model."}, {"id": 209, "string": "We apply dropout with p = 0.2 to the embedding layer and dropout with p = 0.5 to the LSTM layers."}, {"id": 210, "string": "We use Adam (Kingma and  with batch size 128 and the network is trained for 30 epochs."}, {"id": 211, "string": "The learning rate is set initially to 0.001 and is multiplied with \u03b3 = 0.5 every 10 epochs."}, {"id": 212, "string": "Evaluation Following Chopra et al."}, {"id": 213, "string": "(2016) , we filter out pairs with empty headlines from the test set."}, {"id": 214, "string": "We employ the PYROUGE package with \"-m -n 2 -w 1.2\" to compute ROUGE scores."}, {"id": 215, "string": "We use the provided tokenizations of the Gigaword and DUC-2003 , DUC-2004 datasets."}, {"id": 216, "string": "All hyper-parameters were tuned on the development set."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 30}, {"section": "Compressor", "n": "2.1", "start": 31, "end": 61}, {"section": "Differentiable Word Sampling", "n": "2.2", "start": 62, "end": 79}, {"section": "Reconstructor", "n": "2.3", "start": 80, "end": 87}, {"section": "Decoder Initialization", "n": "2.4", "start": 88, "end": 92}, {"section": "Loss Functions", "n": "2.5", "start": 93, "end": 109}, {"section": "Modeling Details", "n": "2.6", "start": 110, "end": 114}, {"section": "Experiments", "n": "3", "start": 115, "end": 150}, {"section": "Limitations and Future Work", "n": "4", "start": 151, "end": 216}], "figures": [{"filename": "../figure/image/1293-Table1-1.png", "caption": "Table 1: Average results on the (English) Gigaword dataset for abstractive sentence compression methods.", "page": 4, "bbox": {"x1": 80.64, "x2": 514.0799999999999, "y1": 63.839999999999996, "y2": 168.0}}, {"filename": "../figure/image/1293-Table2-1.png", "caption": "Table 2: Averaged results on the DUC-2003 dataset; the top part reports results of supervised systems.", "page": 4, "bbox": {"x1": 75.84, "x2": 284.15999999999997, "y1": 202.56, "y2": 249.12}}, {"filename": "../figure/image/1293-Figure3-1.png", "caption": "Figure 3: Good/bad example summaries on Gigaword.", "page": 4, "bbox": {"x1": 306.71999999999997, "x2": 522.24, "y1": 202.56, "y2": 428.15999999999997}}, {"filename": "../figure/image/1293-Table3-1.png", "caption": "Table 3: Averaged results on the DUC-2004 dataset; the top part reports results of supervised systems.", "page": 4, "bbox": {"x1": 76.8, "x2": 284.15999999999997, "y1": 289.44, "y2": 358.08}}, {"filename": "../figure/image/1293-Figure4-1.png", "caption": "Figure 4: Plot of Eq. 9, with different values for the upper bound \u03c40.", "page": 7, "bbox": {"x1": 78.24, "x2": 284.15999999999997, "y1": 361.44, "y2": 538.56}}, {"filename": "../figure/image/1293-Figure2-1.png", "caption": "Figure 2: More detailed illustration of SEQ3. The compressor (C) produces a summary from the input text, and the reconstructor (R) tries to reproduce the input from the summary. R and C comprise an attentional encoder-decoder each, and communicate only through the (discrete) words of the summary. The LM prior incentivizes C to produce human-readable summaries, while topic loss rewards summaries with similar topicindicating words as the input text.", "page": 1, "bbox": {"x1": 72.0, "x2": 289.44, "y1": 68.64, "y2": 271.2}}]}