{"title": "Recursive Subtree Composition in LSTM-Based Dependency Parsing", "abstract": "The need for tree structure modelling on top of sequence modelling is an open issue in neural dependency parsing. We investigate the impact of adding a tree layer on top of a sequential model by recursively composing subtree representations (composition) in a transition-based parser that uses features extracted by a BiLSTM. Composition seems superfluous with such a model, suggesting that BiLSTMs capture information about subtrees. We perform model ablations to tease out the conditions under which composition helps. When ablating the backward LSTM, performance drops and composition does not recover much of the gap. When ablating the forward LSTM, performance drops less dramatically and composition recovers a substantial part of the gap, indicating that a forward LSTM and composition capture similar information. We take the backward LSTM to be related to lookahead features and the forward LSTM to the rich history-based features both crucial for transition-based parsers. To capture history-based information, composition is better than a forward LSTM on its own, but it is even better to have a forward LSTM as part of a BiLSTM. We correlate results with language properties, showing that the improved lookahead of a backward LSTM is especially important for head-final languages.", "text": [{"id": 0, "string": "Introduction Recursive neural networks allow us to construct vector representations of trees or subtrees."}, {"id": 1, "string": "They have been used for constituency parsing by Socher et al."}, {"id": 2, "string": "(2013) and Dyer et al."}, {"id": 3, "string": "(2016) and for dependency parsing by Stenetorp (2013) and , among others."}, {"id": 4, "string": "In particular,  showed that composing representations of subtrees using recursive neural networks can be beneficial for transition-based dependency parsing."}, {"id": 5, "string": "These results were further strengthened in Kuncoro et al."}, {"id": 6, "string": "(2017) who showed, using ablation experiments, that composition is key in the Recurrent Neural Network Grammar (RNNG) generative parser by Dyer et al."}, {"id": 7, "string": "(2016) ."}, {"id": 8, "string": "In a parallel development, Kiperwasser and Goldberg (2016b) showed that using BiLSTMs for feature extraction can lead to high parsing accuracy even with fairly simple parsing architectures, and using BiLSTMs for feature extraction has therefore become very popular in dependency parsing."}, {"id": 9, "string": "It is used in the state-of-the-art parser of Dozat and Manning (2017) , was used in 8 of the 10 highest performing systems of the 2017 CoNLL shared task (Zeman et al., 2017) and 10 out of the 10 highest performing systems of the 2018 CoNLL shared task (Zeman et al., 2018) ."}, {"id": 10, "string": "This raises the question of whether features extracted with BiLSTMs in themselves capture information about subtrees, thus making recursive composition superfluous."}, {"id": 11, "string": "Some support for this hypothesis comes from the results of Linzen et al."}, {"id": 12, "string": "(2016) which indicate that LSTMs can capture hierarchical information: they can be trained to predict long-distance number agreement in English."}, {"id": 13, "string": "Those results were extended to more constructions and three additional languages by Gulordava et al."}, {"id": 14, "string": "(2018) ."}, {"id": 15, "string": "However, Kuncoro et al."}, {"id": 16, "string": "(2018) have also shown that although sequential LSTMs can learn syntactic information, a recursive neural network which explicitly models hierarchy (the RNNG model from ) is better at this: it performs better on the number agreement task from Linzen et al."}, {"id": 17, "string": "(2016) ."}, {"id": 18, "string": "To further explore this question in the context of dependency parsing, we investigate the use of recursive composition (henceforth referred to as composition) in a parser with an architecture like the one in Kiperwasser and Goldberg (2016b) ."}, {"id": 19, "string": "This allows us to explore variations of features and isolate the conditions under which composi-tion is helpful."}, {"id": 20, "string": "We hypothesise that the use of a BiLSTM for feature extraction makes it possible to capture information about subtrees and therefore makes the use of subtree composition superfluous."}, {"id": 21, "string": "We hypothesise that composition becomes useful when part of the BiLSTM is ablated, the forward or the backward LSTM."}, {"id": 22, "string": "We further hypothesise that composition is most useful when the parser has no access to information about the function of words in the context of the sentence given by POS tags."}, {"id": 23, "string": "When using POS tags, the tagger has indeed had access to the full sentence."}, {"id": 24, "string": "We additionally look at what happens when we ablate character vectors which have been shown to capture information which is partially overlapping with information from POS tags."}, {"id": 25, "string": "We experiment with a wider variety of languages than  in order to explore whether the usefulness of different model variants vary depending on language type."}, {"id": 26, "string": "K&G Transition-Based Parsing We define the parsing architecture introduced by Kiperwasser and Goldberg (2016b) at a high level of abstraction and henceforth refer to it as K&G."}, {"id": 27, "string": "A K&G parser is a greedy transition-based parser."}, {"id": 28, "string": "1 For an input sentence of length n with words w 1 , ."}, {"id": 29, "string": "."}, {"id": 30, "string": "."}, {"id": 31, "string": ", w n , a sequence of vectors x 1:n is created, where the vector x i is a vector representation of the word w i ."}, {"id": 32, "string": "We refer to these as type vectors, as they are the same for all occurrences of a word type."}, {"id": 33, "string": "Type vectors are then passed through a feature function which learns representations of words in the context of the sentence."}, {"id": 34, "string": "x i = e(w i ) v i = f (x 1:n , i) We refer to the vector v i as a token vector, as it is different for different tokens of the same word type."}, {"id": 35, "string": "In Kiperwasser and Goldberg (2016b) , the feature function used is a BiLSTM."}, {"id": 36, "string": "As is usual in transition-based parsing, parsing involves taking transitions from an initial configuration to a terminal one."}, {"id": 37, "string": "Parser configurations are represented by a stack, a buffer and set of dependency arcs (Nivre, 2008) ."}, {"id": 38, "string": "For each configuration c, the feature extractor concatenates the token representations of core elements from the stack and buffer."}, {"id": 39, "string": "These token vectors are passed to a classifier, typically a Multilayer Perceptron (MLP)."}, {"id": 40, "string": "The MLP scores transitions together with the arc labels for transitions that involve adding an arc."}, {"id": 41, "string": "Both the word type vectors and the BiLSTMs are trained together with the model."}, {"id": 42, "string": "looked at the impact of using a recursive composition function in their parser, which is also a transition-based parser but with an architecture different from K&G."}, {"id": 43, "string": "They make use of a variant of the LSTM called a stack LSTM."}, {"id": 44, "string": "A stack LSTM has push and pop operations which allow passing through states in a tree structure rather than sequentially."}, {"id": 45, "string": "Stack LSTMs are used to represent the stack, the buffer, and the sequence of past parsing actions performed for a configuration."}, {"id": 46, "string": "Composing Subtree Representations The words of the sentence are represented by vectors of the word types, together with a vector representing the word's POS tag."}, {"id": 47, "string": "In the initial configuration, the vectors of all words are in the buffer and the stack is empty."}, {"id": 48, "string": "The representation of the buffer is the end state of a backward LSTM over the word vectors."}, {"id": 49, "string": "As parsing evolves, the word vectors are popped from the buffer, pushed to and popped from the stack and the representations of stack and buffer get updated."}, {"id": 50, "string": "define a recursive composition function and compose tree representations incrementally, as dependents get attached to their head."}, {"id": 51, "string": "The composed representation c is built by concatenating the vector h of the head with the vector of the dependent d, as well as a vector r representing the label paired with the direction of the arc."}, {"id": 52, "string": "That concatenated vector is passed through an affine transformation and then through a tanh non-linear activation."}, {"id": 53, "string": "c = tanh(W [h; d; r] + b) They create two versions of the parser."}, {"id": 54, "string": "In the first version, when a dependent is attached to a head, the word vector of the head is replaced by a composed vector of the head and dependent."}, {"id": 55, "string": "In the second version, they simply keep the vector of the head when attaching a dependent to a head."}, {"id": 56, "string": "They observe that the version with composition is substantially better than the version without, by 1.3 LAS points for English (on the Penn Treebank (PTB) test set) and 2.1 for Chinese (on the Chinese Treebank (CTB) test set)."}, {"id": 57, "string": "Their parser uses POS tag information."}, {"id": 58, "string": "POS tags help to disambiguate between different functional uses of a word and in this way give information about the use of the word in context."}, {"id": 59, "string": "We hypothesise that the effect of using a recursive composition function is stronger when not making use of POS tags."}, {"id": 60, "string": "Composition in a K&G Parser The parsing architectures of the stack LSTM parser (S-LSTM) and K&G are different but have some similarities."}, {"id": 61, "string": "2 In both cases, the configuration is represented by vectors obtained by LSTMs."}, {"id": 62, "string": "In K&G, it is represented by the token vectors of top items of the stack and the first item of the buffer."}, {"id": 63, "string": "In the S-LSTM, it is represented by the vector representations of the entire stack, buffer and sequence of past transitions."}, {"id": 64, "string": "Both types of parsers learn vector representations of word types which are passed to an LSTM."}, {"id": 65, "string": "In K&G, they are passed to an LSTM in a feature extraction step that happens before parsing."}, {"id": 66, "string": "The LSTM in this case is used to learn vectors that have information about the context of each word, a token vector."}, {"id": 67, "string": "In the S-LSTM, word type vectors are passed to Stack LSTMs as parsing evolves."}, {"id": 68, "string": "In this case, LSTMs are used to learn vector representations of the stack and buffer (as well as one which learns a representation of the parsing action history)."}, {"id": 69, "string": "When composition is not used in the S-LSTM, word vectors represent word types."}, {"id": 70, "string": "When composition is used, as parsing evolves, the stack and buffer vectors get updated with information about the subtrees they contain, so that they gradually become contextualised."}, {"id": 71, "string": "In this sense, those vectors become more like token vectors in K&G."}, {"id": 72, "string": "More specifically, as explained in the previous section, when a dependent is attached to its head, the composition function is applied to the vectors of head and dependent and the vector of the head is replaced by this composed vector."}, {"id": 73, "string": "We cannot apply composition on type vectors in the K&G architecture, since they are not used after the feature extraction step and hence cannot influence the representation of the configuration."}, {"id": 74, "string": "Instead, we apply composition on the token vectors."}, {"id": 75, "string": "We embed those composed representations in the same space as the token vectors."}, {"id": 76, "string": "In K&G, like in the S-LSTM, we can create a composition function and compose the representation of subtrees as parsing evolves."}, {"id": 77, "string": "We create two versions of the parser, one where word tokens are represented by their token vector."}, {"id": 78, "string": "The other where they are represented by their token vector and the vector of their subtree c i , which is initially just a copy of the token vector (v i = f (x 1:n , i)\u2022c i )."}, {"id": 79, "string": "When a dependent word d is attached to a word h with a relation and direction r, c i is computed with the same composition function as in the S-LSTM defined in the previous section, repeated below."}, {"id": 80, "string": "3 This composition function is a simple recurrent cell."}, {"id": 81, "string": "Simple RNNs have known shortcomings which have been addressed by using LSTMs, as proposed by Hochreiter and Schmidhuber (1997) ."}, {"id": 82, "string": "A natural extension to this composition function is therefore to replace it with an LSTM cell."}, {"id": 83, "string": "We also try this variant."}, {"id": 84, "string": "We construct LSTMs for subtrees."}, {"id": 85, "string": "We initialise a new LSTM for each new subtree that is formed, that is, when a dependent d is attached to a head h which does not have any dependent yet."}, {"id": 86, "string": "Each time we attach a dependent to a head, we construct a vector which is a concatenation of h, d and r. We pass this vector to the LSTM of h. c is the output state of the LSTM after passing through that vector."}, {"id": 87, "string": "We denote those models with +rc for the one using an ungated recurrent cell and with +lc for the one using an LSTM cell."}, {"id": 88, "string": "c = tanh(W [h; d; r] + b) c = LSTM([h; d; r]) As results show (see \u00a7 5), neither type of composition seems useful when used with the K&G parsing model, which indicates that BiLSTMs capture information about subtrees."}, {"id": 89, "string": "To further investigate this and in order to isolate the conditions under which composition is helpful, we perform different model ablations and test the impact of recursive composition on these ablated models."}, {"id": 90, "string": "First, we ablate parts of the BiLSTMs: we ablate either the forward or the backward LSTM."}, {"id": 91, "string": "We therefore build parsers with 3 different feature functions f (x, i) over the word type vectors x i in the sentence x: a BiLSTM (bi) (our baseline), a backward LSTM (bw) (i.e., ablating the forward LSTM) and a forward LSTM (f w) (i.e., ablating the backward LSTM): bi(x, i) = BILSTM(x 1:n , i) bw(x, i) = LSTM(x n:1 , i) f w(x, i) = LSTM(x 1:n , i) K&G parsers with unidirectional LSTMs are, in some sense, more similar to the S-LSTM than those with a BiLSTM, since the S-LSTM only uses unidirectional LSTMs."}, {"id": 92, "string": "We hypothesise that composition will help the parser using unidirectional LSTMs in the same way it helps an S-LSTM."}, {"id": 93, "string": "We additionally experiment with the vector representing the word at the input of the LSTM."}, {"id": 94, "string": "The most complex representation consists of a concatenation of an embedding of the word type e(w i ), an embedding of the (predicted) POS tag of w i , p(w i ) and a character representation of the word obtained by running a BiLSTM over the characters ch 1:m of w i (BiLSTM(ch 1:m ))."}, {"id": 95, "string": "x i = e(w i ) \u2022 p(w i ) \u2022 BiLSTM(ch 1:m ) Without a POS tag embedding, the word vector is a representation of the word type."}, {"id": 96, "string": "With POS information, we have some information about the word in the context of the sentence and the tagger has had access to the full sentence."}, {"id": 97, "string": "The representation of the word at the input of the BiLSTM is therefore more contextualised and it can be expected that a recursive composition function will be less helpful than when POS information is not used."}, {"id": 98, "string": "Character information has been shown to be useful for dependency parsing first by ."}, {"id": 99, "string": "and Smith et al."}, {"id": 100, "string": "(2018b) among others have shown that POS and character information are somewhat complementary."}, {"id": 101, "string": "used similar character vectors in the S-LSTM parser but did not look at the impact of composition when using these vectors."}, {"id": 102, "string": "Here, we experiment with ablating either or both of the character and POS vectors."}, {"id": 103, "string": "We look at the impact of using composition on the full model as well as these ablated models."}, {"id": 104, "string": "We hypothesise that composition is most helpful when those vectors are not used, since they give information about the functional use of the word in context."}, {"id": 105, "string": "Parser We use UUParser, a variant of the K&G transition-based parser that employs the arc-hybrid transition system from Kuhlmann et al."}, {"id": 106, "string": "(2011) extended with a SWAP transition and a Static-Dynamic oracle, as described in de Lhoneux et al."}, {"id": 107, "string": "(2017b) 4 ."}, {"id": 108, "string": "The SWAP transition is used to allow the construction of non-projective dependency trees (Nivre, 2009) ."}, {"id": 109, "string": "We use default hyperparameters."}, {"id": 110, "string": "When using POS tags, we use the universal POS tags from the UD treebanks which are coarsegrained and consistent across languages."}, {"id": 111, "string": "Those POS tags are predicted by UDPipe (Straka et al., 2016) both for training and parsing."}, {"id": 112, "string": "This parser obtained the 7th best LAS score on average in the 2018 CoNLL shared task (Zeman et al., 2018) , about 2.5 LAS points below the best system, which uses an ensemble system as well as ELMo embeddings, as introduced by Peters et al."}, {"id": 113, "string": "(2018) ."}, {"id": 114, "string": "Note, however, that we use a slightly impoverished version of the model used for the shared task which is described in Smith et al."}, {"id": 115, "string": "(2018a) : we use a less accurate POS tagger (UDPipe) and we do not make use of multi-treebank models."}, {"id": 116, "string": "In addition, Smith et al."}, {"id": 117, "string": "(2018a) use the three top items of the stack as well as the first item of the buffer to represent the configuration, while we only use the two top items of the stack and the first item of the buffer."}, {"id": 118, "string": "Smith et al."}, {"id": 119, "string": "(2018a) also use an extended feature set as introduced by Kiperwasser and Goldberg (2016b) where they also use the rightmost and leftmost children of the items of the stack and buffer that they consider."}, {"id": 120, "string": "We do not use that extended feature set."}, {"id": 121, "string": "This is to keep the parser settings as simple as possible and avoid adding confounding factors."}, {"id": 122, "string": "It is still a near-SOTA model."}, {"id": 123, "string": "We evaluate parsing models on the development sets and report the average of the 5 best results in 30 epochs and 5 runs with different random seeds."}, {"id": 124, "string": "Data We test our models on a sample of treebanks from Universal Dependencies v2.1 (Nivre et al., 2017) ."}, {"id": 125, "string": "We follow the criteria from de Lhoneux et al."}, {"id": 126, "string": "(2017c) to select our sample: we ensure typological variety, we ensure variety of domains, we verify the quality of the treebanks, and we use one treebank with a large amount of non-projective arcs."}, {"id": 127, "string": "However, unlike them, we do not use extremely small treebanks."}, {"id": 128, "string": "Our selection is the same as theirs but we remove the tiny treebanks and replace them with 3 others."}, {"id": 129, "string": "Our final set is: Ancient Greek (PROIEL), Basque, Chinese, Czech, English, Finnish, French, Hebrew and Japanese."}, {"id": 130, "string": "Results First, we look at the effect of our different recursive composition functions on the full model (i.e., the model using a BiLSTM for feature extraction as well as both character and POS tag information)."}, {"id": 131, "string": "As can be seen from Figure 1 , recursive composition using an LSTM cell (+lc) is generally better than recursive composition with a recurrent cell (+rc), but neither technique reliably improves the accuracy of a BiLSTM parser."}, {"id": 132, "string": "Ablating the forward and backward LSTMs Second, we only consider the models using character and POS information and look at the effect of ablating parts of the BiLSTM on the different languages."}, {"id": 133, "string": "The results can be seen in Figure 2 ."}, {"id": 134, "string": "As expected, the BiLSTM parser performs considerably better than both unidirectional LSTM parsers, and the backward LSTM is considerably better than the forward LSTM, on average."}, {"id": 135, "string": "It is, however, interesting to note that using a forward LSTM is much more hurtful for some languages than others: it is especially hurtful for Chinese and Japanese."}, {"id": 136, "string": "This can be explained by language properties: the right-headed languages suffer more from ablating the backward LSTM than other languages."}, {"id": 137, "string": "We observe a correlation between how hurtful a forward model is compared to the baseline and the percentage of right-headed content dependency relations  (R = \u22120.838, p < .01), see Figure 3 ."}, {"id": 138, "string": "5 There is no significant correlation between how hurtful ablating the forward LSTM is and the percentage of left-headed content dependency relations (p > .05) indicating that its usefulness is not dependent on language properties."}, {"id": 139, "string": "We hypothesise that dependency length or sentence length can play a role but we also find no correlation between how hurtful it is to ablate the forward LSTM and average dependency or sentence length in treebanks."}, {"id": 140, "string": "It is finally also interesting to note that the backward LSTM performance is close to the BiLSTMs performance for some languages (Japanese and French)."}, {"id": 141, "string": "5 The reason we only consider content dependency relations is that the UD scheme focuses on dependency relations between content words and treats function words as features of content words to maximise parallelism across languages (de Marneffe et al., 2014) ."}, {"id": 142, "string": "We now look at the effect of using recursive composition on these ablated models."}, {"id": 143, "string": "Results are given in Figure 4 ."}, {"id": 144, "string": "First of all, we observe unsurprisingly that composition using an LSTM cell is much better than using a simple recurrent cell."}, {"id": 145, "string": "Second, both types of composition help the backward LSTM case, but neither reliably helps the bi models."}, {"id": 146, "string": "Finally, the recurrent cell does not help the forward LSTM case but the LSTM cell does to some extent."}, {"id": 147, "string": "It is interesting to note that using composition, especially using an LSTM cell, bridges a substantial part of the gap between the bw and the bi models."}, {"id": 148, "string": "These results can be related to the literature on transition-based dependency parsing."}, {"id": 149, "string": "Transitionbased parsers generally rely on two types of features: history-based features over the emerging dependency tree and lookahead features over the buffer of remaining input."}, {"id": 150, "string": "The former are based on a hierarchical structure, the latter are purely sequential."}, {"id": 151, "string": "McDonald and Nivre (2007) and Mc-Donald and Nivre (2011) have shown that historybased features enhance transition-based parsers as long as they do not suffer from error propagation."}, {"id": 152, "string": "However, Nivre (2006) has also shown that lookahead features are absolutely crucial given the greedy left-to-right parsing strategy."}, {"id": 153, "string": "In the model architectures considered here, the backward LSTM provides an improved lookahead."}, {"id": 154, "string": "Similarly to the lookahead in statistical parsing, it is sequential."}, {"id": 155, "string": "The difference is that it gives information about upcoming words with unbounded length."}, {"id": 156, "string": "The forward LSTM in this model architecture provides history-based information but unlike in statistical parsing, that information is built sequentially rather than hierarchically: the forward LSTM passes through the sentence in the linear order of the sentence."}, {"id": 157, "string": "In our results, we see that lookahead features are more important than the history-based ones."}, {"id": 158, "string": "It hurts parsing accuracy more to ablate the backward LSTM than to ablate the forward one."}, {"id": 159, "string": "This is expected given that some history-based information is still available through the top tokens on the stack, while the lookahead information is almost lost completely without the backward LSTM."}, {"id": 160, "string": "A composition function gives hierarchical information about the history of parsing actions."}, {"id": 161, "string": "It makes sense that it helps the backward LSTM model most since that model has no access to any information about parsing history."}, {"id": 162, "string": "It helps the forward LSTM slightly which indicates that there can be gains from using structured information about parsing history rather than sequential information."}, {"id": 163, "string": "We could then expect that composition should help the BiLSTM model which, how- Figure 5 : LAS of baseline, using char and/or POS tags to construct word representations ever, is not the case."}, {"id": 164, "string": "This might be because the BiLSTM constructs information about parsing history and lookahead into a unique representation."}, {"id": 165, "string": "In any case, this indicates that BiLSTMs are powerful feature extractors which seem to capture useful information about subtrees."}, {"id": 166, "string": "Ablating POS and character information Next, we look at the effect of the different word representation methods on the different languages, as represented in Figure 5 ."}, {"id": 167, "string": "As is consistent with the literature de Lhoneux et al., 2017a; Smith et al., 2018b) , using characterbased word representations and/or POS tags consistently improves parsing accuracy but has a different impact in different languages and the benefits of both methods are not cumulative: using the two combined is not much better than using either on its own."}, {"id": 168, "string": "In particular, character models are an efficient way to obtain large improvements in morphologically rich languages."}, {"id": 169, "string": "We look at the impact of recursive compositions on all combinations of ablated models, see Table 1 ."}, {"id": 170, "string": "We only look at the impact of using an LSTM cell rather than a recurrent cell since it was a better technique across the board (see previous section)."}, {"id": 171, "string": "Looking first at BiLSTMs, it seems that composition does not reliably help parsing accuracy, regardless of access to POS and character information."}, {"id": 172, "string": "This indicates that the vectors obtained from the BiLSTM already contain information that would otherwise be obtained by using composition."}, {"id": 173, "string": "Turning to results with either the forward or the backward LSTM ablated, we see the expected pattern."}, {"id": 174, "string": "Composition helps more when the model lacks POS tags, indicating that there is some redundancy between these two methods of building contextual information."}, {"id": 175, "string": "Composition helps recover a substantial part of the gap of the model with a backward LSTM with or without POS tag."}, {"id": 176, "string": "It recovers a much less substantial part of the gap in other cases which means that, although there is some redundancy between these different methods of building contextual information, they are still complementary and a recursive composition function cannot fully compensate for the lack of a backward LSTM or POS and/or character information."}, {"id": 177, "string": "There are some language idiosyncracies in the results."}, {"id": 178, "string": "While composition helps recover most of the gap for the backward LSTM models without POS and/or character information for Czech and English, it does it to a much smaller extent for Basque and Finnish."}, {"id": 179, "string": "We hypothesise that arc depth might impact the usefulness of composition, since more depth means more matrix multiplications with the composition function."}, {"id": 180, "string": "However, we find no correlation between average arc depth of the treebanks and usefulness of composition."}, {"id": 181, "string": "It is an open question why composition helps some languages more than others."}, {"id": 182, "string": "Note that we are not the first to use composition over vectors obtained from a BiLSTM in the context of dependency parsing, as this was done by Qi and Manning (2017) ."}, {"id": 183, "string": "The difference is that they compose vectors before scoring transitions."}, {"id": 184, "string": "It was also done by Kiperwasser and Goldberg (2016a) who showed that using BiLSTM vectors for words in their Tree LSTM parser is helpful but they did not compare this to using BiLSTM vectors without the Tree LSTM."}, {"id": 185, "string": "Recurrent and recursive LSTMs in the way they have been considered in this paper are two ways of constructing contextual information and making it available for local decisions in a greedy parser."}, {"id": 186, "string": "The strength of recursive LSTMs is that they can build this contextual information using hierarchical context rather than linear context."}, {"id": 187, "string": "A possible weakness is that this makes the model sensitive to error propagation: a wrong attachment leads to using the wrong contextual information."}, {"id": 188, "string": "It is therefore possible that the benefits and drawbacks of using this method cancel each other out in the context of BiLSTMs."}, {"id": 189, "string": "Ensemble To investigate further the information captured by BiLSTMs, we ensemble the 6 versions of the models with POS and character information with the different feature extractors (bi, bw, f w) with (+lc) and without composition."}, {"id": 190, "string": "We use the (unweighted) reparsing technique of Sagae and Lavie (2006) 6 and ignoring labels."}, {"id": 191, "string": "As can be seen from the UAS scores in Table 2 , the ensemble (full) largely outperforms the parser using only a BiLSTM, indicating that the information obtained from the different models is complementary."}, {"id": 192, "string": "To investigate the contribution of each of the 6 models, we ablate each one by one."}, {"id": 193, "string": "As can be seen from Table 2 , ablating either of the BiLSTM models or the backward LSTM using composition, results in the least effective of the ablated models, further strengthening the conclusion that BiL-STMs are powerful feature extractors."}, {"id": 194, "string": "Conclusion We investigated the impact of composing the representation of subtrees in a transition-based parser."}, {"id": 195, "string": "We observed that composition does not reliably  help a parser that uses a BiLSTM for feature extraction, indicating that vectors obtained from the BiLSTM might capture subtree information, which is consistent with the results of Linzen et al."}, {"id": 196, "string": "(2016) ."}, {"id": 197, "string": "However, we observe that, when ablating the backward LSTM, performance drops and recursive composition does not help to recover much of this gap."}, {"id": 198, "string": "We hypothesise that this is because the backward LSTM primarily improves the lookahead for the greedy parser."}, {"id": 199, "string": "When ablating the forward LSTM, performance drops to a smaller extent and recursive composition recovers a substantial part of the gap."}, {"id": 200, "string": "This indicates that a forward LSTM and a recursive composition function capture similar information, which we take to be related to the rich history-based features crucial for a transition-based parser."}, {"id": 201, "string": "To capture this infor-mation, a recursive composition function is better than a forward LSTM on its own, but it is even better to have a forward LSTM as part of a BiLSTM."}, {"id": 202, "string": "We further find that recursive composition helps more when POS tags are ablated from the model, indicating that POS tags and a recursive composition function are partly redundant ways of constructing contextual information."}, {"id": 203, "string": "Finally, we correlate results with language properties, showing that the improved lookahead of a backward LSTM is especially important for head-final languages."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 25}, {"section": "K&G Transition-Based Parsing", "n": "2", "start": 26, "end": 45}, {"section": "Composing Subtree Representations", "n": "3", "start": 46, "end": 59}, {"section": "Composition in a K&G Parser", "n": "4", "start": 60, "end": 128}, {"section": "Results", "n": "5", "start": 129, "end": 131}, {"section": "Ablating the forward and backward LSTMs", "n": "5.1", "start": 132, "end": 165}, {"section": "Ablating POS and character information", "n": "5.2", "start": 166, "end": 188}, {"section": "Ensemble", "n": "5.3", "start": 189, "end": 193}, {"section": "Conclusion", "n": "6", "start": 194, "end": 203}], "figures": [{"filename": "../figure/image/1284-Figure4-1.png", "caption": "Figure 4: LAS of models using a BiLSTM (bi), backward LSTM (bw) and forward LSTM (fw), without recursive composition, with a recurrent cell (+rc) and with a LSTM cell (+lc). Bar charts truncated at 50 for visualization purposes.", "page": 5, "bbox": {"x1": 76.8, "x2": 520.3199999999999, "y1": 61.44, "y2": 309.12}}, {"filename": "../figure/image/1284-Figure1-1.png", "caption": "Figure 1: LAS of models using a BiLSTM (bi) without composition, with a recurrent cell (+rc) and with an LSTM cell (+lc). Bar charts truncated at 50 for visualization purposes.", "page": 4, "bbox": {"x1": 72.0, "x2": 295.2, "y1": 229.44, "y2": 407.03999999999996}}, {"filename": "../figure/image/1284-Figure3-1.png", "caption": "Figure 3: Correlation between how hurtful it is to ablate the backward LSTM and right-headedness of languages.", "page": 4, "bbox": {"x1": 306.71999999999997, "x2": 525.12, "y1": 269.76, "y2": 444.0}}, {"filename": "../figure/image/1284-Figure2-1.png", "caption": "Figure 2: LAS of models using a BiLSTM (bi), backward LSTM (bw) and forward LSTM (fw).", "page": 4, "bbox": {"x1": 314.88, "x2": 518.4, "y1": 61.44, "y2": 223.2}}, {"filename": "../figure/image/1284-Table1-1.png", "caption": "Table 1: LAS for bi, bw and fw, without and with composition (+lc) with an LSTM. Difference > 0.5 with +lc in bold.", "page": 7, "bbox": {"x1": 104.64, "x2": 493.44, "y1": 63.36, "y2": 332.15999999999997}}, {"filename": "../figure/image/1284-Table2-1.png", "caption": "Table 2: UAS ensemble (full) and ablated experiments.", "page": 7, "bbox": {"x1": 321.59999999999997, "x2": 510.24, "y1": 385.91999999999996, "y2": 480.96}}, {"filename": "../figure/image/1284-Figure5-1.png", "caption": "Figure 5: LAS of baseline, using char and/or POS tags to construct word representations", "page": 6, "bbox": {"x1": 79.67999999999999, "x2": 283.2, "y1": 61.44, "y2": 231.35999999999999}}]}