{"title": "for Computational Linguistics Multiple Word Alignment with Profile Hidden Markov Models", "abstract": "Profile hidden Markov models (Profile HMMs) are specific types of hidden Markov models used in biological sequence analysis. We propose the use of Profile HMMs for word-related tasks. We test their applicability to the tasks of multiple cognate alignment and cognate set matching, and find that they work well in general for both tasks. On the latter task, the Profile HMM method outperforms average and minimum edit distance. Given the success for these two tasks, we further discuss the potential applications of Profile HMMs to any task where consideration of a set of words is necessary.", "text": [{"id": 0, "string": "Introduction In linguistics, it is often necessary to align words or phonetic sequences."}, {"id": 1, "string": "Covington (1996) uses alignments of cognate pairs for the historical linguistics task of comparative reconstruction and Nerbonne and Heeringa (1997) use alignments to compute relative distances between words from various Dutch dialects."}, {"id": 2, "string": "Algorithms for aligning pairs of words have been proposed by Covington (1996) and Kondrak (2000) ."}, {"id": 3, "string": "However, it is often necessary to align multiple words."}, {"id": 4, "string": "Covington (1998) proposed a method to align multiple words based on a handcrafted scale of similarity between various classes of phonemes, again for the purpose of comparative reconstruction of languages."}, {"id": 5, "string": "Profile hidden Markov models (Profile HMMs) are specific types of hidden Markov models used in biological sequence analysis, where they have yielded success for the matching of given sequences to sequence families as well as to multiple sequence alignment (Durbin et al., 1998) ."}, {"id": 6, "string": "In this paper, we show that Profile HMMs can be adapted to the task of aligning multiple words."}, {"id": 7, "string": "We apply them to sets of multilingual cognates and show that they produce good alignments."}, {"id": 8, "string": "We also use them for the related task of matching words to established cognate sets, useful for a situation where it is not immediately obvious to which cognate set a word should be matched."}, {"id": 9, "string": "The accuracy on the latter task exceeds the accuracy of a method based on edit distance."}, {"id": 10, "string": "Profile HMMs could also potentially be used for the computation of word similarity when a word must be compared not to another word but to another set of words, taking into account properties of all constituent words."}, {"id": 11, "string": "The use of Profile HMMs for multiple sequence alignment also presents applications to the acquisition of mapping dictionaries (Barzilay and Lee, 2002) and sentence-level paraphrasing (Barzilay and Lee, 2003) ."}, {"id": 12, "string": "This paper is organized as follows: we first describe the uses of Profile HMMs in computational biology, their structure, and then discuss their applications to word-related tasks."}, {"id": 13, "string": "We then discuss our data set and describe the tasks that we test and their experimental setups and results."}, {"id": 14, "string": "We conclude with a summary of the results and a brief discussion of potential future work."}, {"id": 15, "string": "Profile hidden Markov models In computational biology, it is often necessary to deal with multiple sequences, including DNA and protein sequences."}, {"id": 16, "string": "For such biological sequence analysis, Profile HMMs are applied to the common tasks of simultaneously aligning multiple related sequences to each other, aligning a new sequence to an already-aligned family of sequences, and evaluating a new sequence for membership in a family of sequences."}, {"id": 17, "string": "Profile HMMs consist of several types of states: match states, insert states, delete states, as well as a begin and end state."}, {"id": 18, "string": "For each position in a Profile HMM, there is one match state, one insert state, and one delete state."}, {"id": 19, "string": "A Profile HMM can thus be visualized as a series of columns, where each column represents a position in the sequence (see Figure 1 )."}, {"id": 20, "string": "Any arbitrary sequence can then be represented as a traversal of states from column to column."}, {"id": 21, "string": "Match states form the core of the model; each match state is represented by a set of emission probabilities for each symbol in the output alphabet."}, {"id": 22, "string": "These probabilities indicate the distribution of values for a given position in a sequence."}, {"id": 23, "string": "Each match state can probabilistically transition to the next (i.e."}, {"id": 24, "string": "next-column) match and delete states as well as the current (i.e."}, {"id": 25, "string": "current-column) insert state."}, {"id": 26, "string": "Insert states represent possible values that can be inserted at a given position in a sequence (before a match emission or deletion)."}, {"id": 27, "string": "They are represented in the same manner as match states, with each output symbol having an associated probability."}, {"id": 28, "string": "Insert states are used to account for symbols that have been inserted to a given position that might not otherwise have occurred \"naturally\" via a match state."}, {"id": 29, "string": "Insert states can probabilistically transition to the next match and delete states as well as the current insert state (i.e."}, {"id": 30, "string": "itself)."}, {"id": 31, "string": "Allowing insert states to transition to themselves enables the consideration of multiplesymbol inserts."}, {"id": 32, "string": "MMIIIM AG...C A-AG.C AG.AA---AAAC AG...C Figure 2 : A small DNA multiple alignment from (Durbin et al., 1998, p. 123)."}, {"id": 33, "string": "Similarly, delete states represent symbols that have been removed from a given position."}, {"id": 34, "string": "For a sequence to use a delete state for a given position indicates that a given character position in the model has no corresponding characters in the given sequence."}, {"id": 35, "string": "Hence, delete states are by nature silent and thus have no emission probabilities for the output symbols."}, {"id": 36, "string": "This is an important distinction from match states and insert states."}, {"id": 37, "string": "Each delete state can probabilistically transition to the next match and delete states as well as the current insert state."}, {"id": 38, "string": "Figure 2 shows a small example of a set of DNA sequences."}, {"id": 39, "string": "The match columns and insert columns are marked with the letters M and I respectively in the first line."}, {"id": 40, "string": "Where a word has a character in a match column, it is a match state emission; when there is instead a gap, it is a delete state occurrence."}, {"id": 41, "string": "Any characters in insert columns are insert state emissions, and gaps in insert columns represent simply that the particular insert state was not used for the sequence in question."}, {"id": 42, "string": "Durbin et al."}, {"id": 43, "string": "(1998) describe the uses of Profile HMMs for tasks in biological sequence analysis."}, {"id": 44, "string": "Firstly, a Profile HMM must be constructed."}, {"id": 45, "string": "If a Profile HMM is to be constructed from a set of aligned sequences, it is necessary to designate certain columns as match columns and others as insert column."}, {"id": 46, "string": "The simple heuristic that we adopt is to label those columns match states for which half or more of the sequences have a symbol present (rather than a gap)."}, {"id": 47, "string": "Other columns are labelled insert states."}, {"id": 48, "string": "Then the probability a kl of state k transitioning to state l can be estimated by counting the number of times A kl that the transition is used in the alignment: a kl = A kl l A kl Similarly, the probability e k (a) of state k emitting symbol a is estimated by counting the number of times E k (a) that the emission is used in the alignment: e k (a) = E k (a) a E k (a ) There is the danger that some probabilities may be set to zero, so it is essential to add pseudocounts."}, {"id": 49, "string": "The pseudocount methods that we explore are described in section 3."}, {"id": 50, "string": "If a Profile HMM is to be constructed from a set of unaligned sequences, an initial model is generated after which it can be trained to the sequences using the Baum-Welch algorithm."}, {"id": 51, "string": "The length of the model must be chosen, and is usually set to the average length of the unaligned sequences."}, {"id": 52, "string": "To generate the initial model, which amounts to setting the transition and emission probabilities to some initial values, the probabilities are sampled from Dirichlet distributions."}, {"id": 53, "string": "Once a Profile HMM has been constructed, it can be used to evaluate a given sequence for membership in the family."}, {"id": 54, "string": "This is done via a straightforward application of the forward algorithm (to get the full probability of the given sequence) or the Viterbi algorithm (to get the alignment of the sequence to the family)."}, {"id": 55, "string": "For the alignment of multiple unaligned sequences, a Profile HMM is constructed and trained as described above and then each sequence can be aligned using the Viterbi algorithm."}, {"id": 56, "string": "It should also be noted that Profile HMMs are generalizations of Pair HMMs, which have been used for cognate identification and word similarity (Mackay and Kondrak, 2005) between pairs of words."}, {"id": 57, "string": "Unlike Pair HMMs, Profile HMMs are position-specific; this is what allows their application to multiple sequences but also means that each Profile HMM must be trained to a given set of sequences, whereas Pair HMMs can be trained over a very large data set of pairs of words."}, {"id": 58, "string": "Adapting Profile HMMs to words Using Profile HMMs for biological sequences involves defining an alphabet and working with related sequences consisting of symbols from that alphabet."}, {"id": 59, "string": "One could perform tasks with cognates sets in a similar manner; cognates are, after all, related words, and words are nothing more than sequences of symbols from an alphabet."}, {"id": 60, "string": "Thus Profile HMMs present potential applications to similar tasks for cognate sets."}, {"id": 61, "string": "We apply Profile HMMs to the multiple alignment of cognate sets, which is done in the same manner as multiple sequence alignment for biological sequences described above."}, {"id": 62, "string": "We also test Profile HMMs for determining the correct cognate set to which a word belongs when given a variety of cognate sets for the same meaning; this is done in a similar manner to the sequence membership evaluation task described above."}, {"id": 63, "string": "Although there are a number of Profile HMM packages available (e.g."}, {"id": 64, "string": "HMMER), we decided to develop an implementation from scratch in order to achieve greater control over various adjustable parameters."}, {"id": 65, "string": "1 We investigated the following parameters: Favouring match states When constructing a Profile HMM from unaligned sequences, the choice of initial model probabilities can have a significant effect on results."}, {"id": 66, "string": "It may be sensible to favour match states compared to other states when constructing the initial model; since the transition probabilities are sampled from a Dirichlet distribution, the option of favouring match states assigns the largest returned probability to the transition to a match state."}, {"id": 67, "string": "Pseudocount method We implemented three pseudocount methods from (Durbin et al., 1998) ."}, {"id": 68, "string": "In the following equations, e j (a) is the probability of state j emitting character a. c ja represents the observed counts of state j emitting symbol a."}, {"id": 69, "string": "A is the weight given to the pseudocounts."}, {"id": 70, "string": "Constant value A constant value AC is added to each count."}, {"id": 71, "string": "This is a generalization of Laplace's rule, where C = 1 A ."}, {"id": 72, "string": "e j (a) = c ja + AC a c ja + A Background frequency Pseudocounts are added in proportion to the background frequency q a , which is the frequency of occurrence of character a. e j (a) = c ja + Aq a a c ja + A Substitution matrix (Durbin et al., 1998 ) Given a matrix s(a, b) that gives the logodds similarity of characters a and b, we can determine the conditional probability of a character b given character a: P (b|a) = q b e s(a,b) Then we define f ja to be the probability derived from the counts: f ja = c ja a c ja Then the pseudocount values are set to: \u03b1 ja = A b f jb P (a|b) Finally, the pseudocount values are added to the real counts as above: e j (a) = c ja + \u03b1 ja a c ja + \u03b1 ja Pseudocount weight The weight that the pseudocounts are given (A in the above equations)."}, {"id": 73, "string": "Smoothing during Baum-Welch The problem has many local optima and it is therefore easy for the Baum-Welch algorithm to get stuck around one of these."}, {"id": 74, "string": "In order to avoid local optima, we tested the option of adding pseudocounts during Baum-Welch (i.e."}, {"id": 75, "string": "between iterations) rather than after it."}, {"id": 76, "string": "This serves as a form of noise injection, effectively bumping Baum-Welch away from local optima."}, {"id": 77, "string": "Data for experiments Our data come from the Comparative Indoeuropean Data Corpus (Dyen et al., 1992) ."}, {"id": 78, "string": "The data consist of words in 95 languages in the Indoeuropean family organized into word lists corresponding to one of 200 meanings."}, {"id": 79, "string": "Each word is represented in the English alphabet."}, {"id": 80, "string": "Figure 3 shows a sample from the original corpus data."}, {"id": 81, "string": "We manually converted the data into disjoint sets of cognate words, where each cognate set contains only one word from each language."}, {"id": 82, "string": "We also removed words that were not cognate with any other words."}, {"id": 83, "string": "On average, there were 4.37 words per cognate set."}, {"id": 84, "string": "The smallest cognate set had two words (since  we excluded those words that were not cognate with any other words), and the largest had 84 words."}, {"id": 85, "string": "There were on average 10.92 cognate sets in a meaning."}, {"id": 86, "string": "The lowest number of cognate sets in a meaning was 1, and the largest number was 22."}, {"id": 87, "string": "Multiple cognate alignment Similar to their use for multiple sequence alignment of sequences in a family, we test Profile HMMs for the task of aligning cognates."}, {"id": 88, "string": "As described above, an initial model is generated."}, {"id": 89, "string": "We use the aforementioned heuristic of setting the initial model length to the average length of the sequences."}, {"id": 90, "string": "The transition probabilities are sampled from a uniform-parameter Dirichlet distribution, with each parameter having a value of 5.0."}, {"id": 91, "string": "The insert-state emission probabilities are set to the background frequencies and the match-state emission probabilities are sampled from a Dirichlet distribution with parameters set in proportion to the background frequency."}, {"id": 92, "string": "The model is Figure 4 : The alignment generated via the Profile HMM method for some cognates."}, {"id": 93, "string": "These were aligned together, but we show them in two columns to preserve space."}, {"id": 94, "string": "MIIMIIMI MIIMIIMI D--E--N- D--E--NY Z--E--N- DZ-E--N- DZIE--N- D--A--N- DI-E--NA D--E--IZ D--I--A- D--Y--DD D--I--E- Z-----U- Z--U--E- Z-----I- J--O--UR D-----I- DJ-O--U- G--IORNO trained to the cognate set via the Baum-Welch algorithm, and then each word in the set is aligned to the model using the Viterbi algorithm."}, {"id": 95, "string": "The words are added to the training via a summation; therefore, the order in which the words are considered has no effect, in contrast to iterative pairwise methods."}, {"id": 96, "string": "The setting of the parameter values is discussed in section 6."}, {"id": 97, "string": "Results To evaluate Profile HMMs for multiple cognate alignment, we analyzed the alignments generated for a number of cognate sets."}, {"id": 98, "string": "We found that increasing the pseudocount weight to 100 improved the quality of the alignments by effectively biasing the model towards similar characters according to the substitution matrix."}, {"id": 99, "string": "Figure 4 shows the Profile HMM alignment for a cognate set of words with the meaning \"day.\""}, {"id": 100, "string": "As with Figure 2 , the alignment's first line is a guide label used to indicate which columns are match columns and which are insert columns; note that consecutive insert columns represent the same insert state and so are not aligned by the Profile HMM."}, {"id": 101, "string": "While there were some duplicate words (i.e."}, {"id": 102, "string": "words that had identical English orthographic representations but came from different languages), we do not show them here for brevity."}, {"id": 103, "string": "In this example, we see that the Profile HMM manages to identify those columns that are more highly conserved as match states."}, {"id": 104, "string": "The ability to identify characters that are similar and align them correctly can be attributed to the provided substitution matrix."}, {"id": 105, "string": "Note that the characters in the insert columns should not be treated as aligned even though they represent emissions from the same insert state (this highlights the difference between match and insert states)."}, {"id": 106, "string": "For example, Y, A, Z, D, R, and O are all placed in a single insert column even though they cannot be traced to a single phoneme in a protoform of the cognate set."}, {"id": 107, "string": "Particularly infrequent characters are more likely to be put together than separated even if they are phonetically dissimilar."}, {"id": 108, "string": "There is some difficulty, also evident from other alignments we generated, in isolating phonemes represented by pairs of characters (digraphs) as singular entities."}, {"id": 109, "string": "In the given example, this means that the dz in dzien was modelled as a match state and then an insert state."}, {"id": 110, "string": "This is, however, an inherent difficulty in using data represented only with the English alphabet, which could potentially be addressed if the data were instead represented in a standard phonetic notation such as IPA."}, {"id": 111, "string": "Cognate set matching Evaluating alignments in a principled way is difficult because of the lack of a gold standard."}, {"id": 112, "string": "To adjust for this, we also evaluate Profile HMMs for the task of matching a word to the correct cognate set from a list of cognate sets with the same meaning as the given word, similar to the evaluation of a biological sequence for membership in a family."}, {"id": 113, "string": "This is realized by removing one word at a time from each word list and then using the resulting cognate sets within the meaning as possible targets."}, {"id": 114, "string": "A model is generated from each possible target and a log-odds score is computed for the word using the forward algorithm."}, {"id": 115, "string": "The scores are then sorted and the highest score is taken to be the cognate set to which the given word belongs."}, {"id": 116, "string": "The accuracy is then the fraction of times the correct cognate set is identified."}, {"id": 117, "string": "To determine the best parameter values, we used a development set of 10 meanings (roughly 5% of the data)."}, {"id": 118, "string": "For the substitution matrix pseudocount method, we used a log-odds similarity matrix derived from Pair HMM training (Mackay and Kondrak, 2005) ."}, {"id": 119, "string": "The best results were achieved with favouring of match states enabled, substitutionmatrix-based pseudocount, pseudocount weight of 0.5, and pseudocounts added during Baum-Welch."}, {"id": 120, "string": "Results We employed two baselines to generate scores between a given word and cognate set."}, {"id": 121, "string": "The first baseline uses the average edit distance of the test word and the words in the given cognate set as the score of the word against the set."}, {"id": 122, "string": "The second baseline is similar but uses the minimum edit distance between the test word and any word in the given cognate set as the score of the word against the entire set."}, {"id": 123, "string": "For example, in the example set given in Figure 4 , the average edit distance between zen and all other words in the set is 2.58 (including the hidden duplicate words) and the minimum edit distance is 1."}, {"id": 124, "string": "All other candidate sets are similarly scored and the one with the lowest score is considered to be the correct cluster with ties broken randomly."}, {"id": 125, "string": "With the parameter settings described in the previous section, the Profile HMM method correctly identifies the corresponding cognate set with an accuracy of 93.2%, a substantial improvement over the average edit distance baseline, which obtains an accuracy of 77.0%."}, {"id": 126, "string": "Although the minimum edit distance baseline also yields an impressive accuracy of 91.0%, its score is based on a single word in the candidate set, and so would not be appropriate for cases where consideration of the entire set is necessary."}, {"id": 127, "string": "Furthermore, the baseline benefits from the frequent presence of duplicate words in the cognate sets."}, {"id": 128, "string": "Profile HMMs are more robust, thanks to the presence of identical or similar characters in corresponding positions."}, {"id": 129, "string": "Conclusions Profile HMMs present an approach for working with sets of words."}, {"id": 130, "string": "We tested their use for two cognaterelated tasks."}, {"id": 131, "string": "The method produced good-quality multiple cognate alignments, and we believe that they could be further improved with phonetically transcribed data."}, {"id": 132, "string": "For the task of matching words to correct cognate sets, we achieved an improvement over the average edit distance and minimum edit distance baselines."}, {"id": 133, "string": "Since Profile HMM training is highly sensitive to the choice of initial model, we would like to explore more informed methods of constructing the initial model."}, {"id": 134, "string": "Similarly, for building models from unaligned sequences, the addition of domain knowl-edge would likely prove beneficial."}, {"id": 135, "string": "We also plan to investigate better pseudocount methods, as well as the possibility of using n-grams as output symbols."}, {"id": 136, "string": "By simultaneously considering an entire set of related words, Profile HMMs provide a distinct advantage over iterative pairwise methods."}, {"id": 137, "string": "The success on our tasks of multiple alignment and cognate set matching suggests applicability to similar tasks involving words, such as named entity recognition across potentially multi-lingual corpora."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 14}, {"section": "Profile hidden Markov models", "n": "2", "start": 15, "end": 57}, {"section": "Adapting Profile HMMs to words", "n": "3", "start": 58, "end": 76}, {"section": "Data for experiments", "n": "4", "start": 77, "end": 86}, {"section": "Multiple cognate alignment", "n": "5", "start": 87, "end": 96}, {"section": "Results", "n": "5.1", "start": 97, "end": 110}, {"section": "Cognate set matching", "n": "6", "start": 111, "end": 119}, {"section": "Results", "n": "6.1", "start": 120, "end": 128}, {"section": "Conclusions", "n": "7", "start": 129, "end": 137}], "figures": [{"filename": "../figure/image/1043-Figure4-1.png", "caption": "Figure 4: The alignment generated via the Profile HMM method for some cognates. These were aligned together, but we show them in two columns to preserve space.", "page": 4, "bbox": {"x1": 116.64, "x2": 254.39999999999998, "y1": 57.12, "y2": 171.35999999999999}}, {"filename": "../figure/image/1043-Figure2-1.png", "caption": "Figure 2: A small DNA multiple alignment from (Durbin et al., 1998, p. 123).", "page": 1, "bbox": {"x1": 408.47999999999996, "x2": 444.96, "y1": 57.12, "y2": 123.36}}, {"filename": "../figure/image/1043-Figure1-1.png", "caption": "Figure 1: A prototypical Profile HMM of length L. Mi is the ith match state, Ii is the ith insert state, and Di is the ith delete state. Delete states are silent and are used to indicate gaps in a sequence.", "page": 1, "bbox": {"x1": 105.6, "x2": 265.44, "y1": 58.559999999999995, "y2": 169.44}}, {"filename": "../figure/image/1043-Figure3-1.png", "caption": "Figure 3: An excerpt from the original corpus data. The first two numbers denote the meaning and the language, respectively.", "page": 3, "bbox": {"x1": 312.96, "x2": 528.48, "y1": 57.599999999999994, "y2": 350.88}}]}