{"title": "Semantic Parsing via Staged Query Graph Generation: Question Answering with Knowledge Base", "abstract": "We propose a novel semantic parsing framework for question answering using a knowledge base. We define a query graph that resembles subgraphs of the knowledge base and can be directly mapped to a logical form. Semantic parsing is reduced to query graph generation, formulated as a staged search problem. Unlike traditional approaches, our method leverages the knowledge base in an early stage to prune the search space and thus simplifies the semantic matching problem. By applying an advanced entity linking system and a deep convolutional neural network model that matches questions and predicate sequences, our system outperforms previous methods substantially, and achieves an F 1 measure of 52.5% on the WEBQUESTIONS dataset.", "text": [{"id": 0, "string": "Introduction Organizing the world's facts and storing them in a structured database, large-scale knowledge bases (KB) like DBPedia (Auer et al., 2007) and Freebase (Bollacker et al., 2008) have become important resources for supporting open-domain question answering (QA)."}, {"id": 1, "string": "Most state-of-the-art approaches to KB-QA are based on semantic parsing, where a question (utterance) is mapped to its formal meaning representation (e.g., logical form) and then translated to a KB query."}, {"id": 2, "string": "The answers to the question can then be retrieved simply by executing the query."}, {"id": 3, "string": "The semantic parse also provides a deeper understanding of the question, which can be used to justify the answer to users, as well as to provide easily interpretable information to developers for error analysis."}, {"id": 4, "string": "However, most traditional approaches for semantic parsing are largely decoupled from the knowledge base, and thus are faced with several challenges when adapted to applications like QA."}, {"id": 5, "string": "For instance, a generic meaning representation may have the ontology matching problem when the logical form uses predicates that differ from those defined in the KB (Kwiatkowski et al., 2013) ."}, {"id": 6, "string": "Even when the representation language is closely related to the knowledge base schema, finding the correct predicates from the large vocabulary in the KB to relations described in the utterance remains a difficult problem (Berant and Liang, 2014) ."}, {"id": 7, "string": "Inspired by (Yao and Van Durme, 2014; Bao et al., 2014) , we propose a semantic parsing framework that leverages the knowledge base more tightly when forming the parse for an input question."}, {"id": 8, "string": "We first define a query graph that can be straightforwardly mapped to a logical form in \u03bbcalculus and is semantically closely related to \u03bb-DCS (Liang, 2013) ."}, {"id": 9, "string": "Semantic parsing is then reduced to query graph generation, formulated as a search problem with staged states and actions."}, {"id": 10, "string": "Each state is a candidate parse in the query graph representation and each action defines a way to grow the graph."}, {"id": 11, "string": "The representation power of the semantic parse is thus controlled by the set of legitimate actions applicable to each state."}, {"id": 12, "string": "In particular, we stage the actions into three main steps: locating the topic entity in the question, finding the main relationship between the answer and the topic entity, and expanding the query graph with additional constraints that describe properties the answer needs to have, or relationships between the answer and other entities in the question."}, {"id": 13, "string": "One key advantage of this staged design is that through grounding partially the utterance to some entities and predicates in the KB, we make the search far more efficient by focusing on the promising areas in the space that most likely lead to the correct query graph, before the full parse is determined."}, {"id": 14, "string": "For example, after linking \"Fam-ily Guy\" in the question \"Who first voiced Meg on Family Guy?\""}, {"id": 15, "string": "to FamilyGuy (the TV show) in the knowledge base, the procedure needs only to examine the predicates that can be applied to FamilyGuy instead of all the predicates in the KB."}, {"id": 16, "string": "Resolving other entities also becomes easy, as given the context, it is clear that Meg refers to MegGriffin (the character in Family Guy)."}, {"id": 17, "string": "Our design divides this particular semantic parsing problem into several sub-problems, such as entity linking and relation matching."}, {"id": 18, "string": "With this integrated framework, best solutions to each subproblem can be easily combined and help produce the correct semantic parse."}, {"id": 19, "string": "For instance, an advanced entity linking system that we employ outputs candidate entities for each question with both high precision and recall."}, {"id": 20, "string": "In addition, by leveraging a recently developed semantic matching framework based on convolutional networks, we present better relation matching models using continuous-space representations instead of pure lexical matching."}, {"id": 21, "string": "Our semantic parsing approach improves the state-of-the-art result on the WEBQUESTIONS dataset (Berant et al., 2013) to 52.5% in F 1 , a 7.2% absolute gain compared to the best existing method."}, {"id": 22, "string": "The rest of this paper is structured as follows."}, {"id": 23, "string": "Sec."}, {"id": 24, "string": "2 introduces the basic notion of the graph knowledge base and the design of our query graph."}, {"id": 25, "string": "Sec."}, {"id": 26, "string": "3 presents our search-based approach for generating the query graph."}, {"id": 27, "string": "The experimental results are shown in Sec."}, {"id": 28, "string": "4, and the discussion of our approach and the comparisons to related work are in Sec."}, {"id": 29, "string": "5."}, {"id": 30, "string": "Finally, Sec."}, {"id": 31, "string": "6 concludes the paper."}, {"id": 32, "string": "Background In this work, we aim to learn a semantic parser that maps a natural language question to a logical form query q, which can be executed against a knowledge base K to retrieve the answers."}, {"id": 33, "string": "Our approach takes a graphical view of both K and q, and reduces semantic parsing to mapping questions to query graphs."}, {"id": 34, "string": "We describe the basic design below."}, {"id": 35, "string": "Knowledge base The knowledge base K considered in this work is a collection of subject-predicate-object triples (e 1 , p, e 2 ), where e 1 , e 2 \u2208 E are the entities (e.g., FamilyGuy or MegGriffin) and p \u2208 P is a binary predicate like character."}, {"id": 36, "string": "A knowledge base in this form is often called a knowledge graph because of its straightforward graphical representation -each entity is a node and two related entities are linked by a directed edge labeled by the predicate, from the subject to the object entity."}, {"id": 37, "string": "To compare our approach to existing methods, we use Freebase, which is a large database with more than 46 million topics and 2.6 billion facts."}, {"id": 38, "string": "In Freebase's design, there is a special entity category called compound value type (CVT), which is not a real-world entity, but is used to collect multiple fields of an event or a special relationship."}, {"id": 39, "string": "Fig."}, {"id": 40, "string": "1 shows a small subgraph of Freebase related to the TV show Family Guy."}, {"id": 41, "string": "Nodes are the entities, including some dates and special CVT entities 1 ."}, {"id": 42, "string": "A directed edge describes the relation between two entities, labeled by the predicate."}, {"id": 43, "string": "Query graph Given the knowledge graph, executing a logicalform query is equivalent to finding a subgraph that can be mapped to the query and then resolving the binding of the variables."}, {"id": 44, "string": "To capture this intuition, we describe a restricted subset of \u03bb-calculus in a graph representation as our query graph."}, {"id": 45, "string": "Our query graph consists of four types of nodes: grounded entity (rounded rectangle), existential variable (circle), lambda variable (shaded circle), aggregation function (diamond)."}, {"id": 46, "string": "Grounded entities are existing entities in the knowledge base K. Existential variables and lambda variables are un- grounded entities."}, {"id": 47, "string": "In particular, we would like to retrieve all the entities that can map to the lambda variables in the end as the answers."}, {"id": 48, "string": "Aggregation function is designed to operate on a specific entity, which typically captures some numerical properties."}, {"id": 49, "string": "Just like in the knowledge graph, related nodes in the query graph are connected by directed edges, labeled with predicates in K. To demonstrate this design, Fig."}, {"id": 50, "string": "2 shows one possible query graph for the question \"Who first voiced Meg on Family Guy?\""}, {"id": 51, "string": "using Freebase."}, {"id": 52, "string": "The two entities, MegGriffin and FamilyGuy are represented by two rounded rectangle nodes."}, {"id": 53, "string": "The circle node y means that there should exist an entity describing some casting relations like the character, actor and the time she started the role 2 ."}, {"id": 54, "string": "The shaded circle node x is also called the answer node, and is used to map entities retrieved by the query."}, {"id": 55, "string": "The diamond node arg min constrains that the answer needs to be the earliest actor for this role."}, {"id": 56, "string": "Equivalently, the logical form query in \u03bb-calculus without the aggregation function is: \u03bbx.\u2203y.cast(FamilyGuy, y) \u2227 actor(y, x) \u2227 character(y, MegGriffin) Running this query graph against K as in Fig."}, {"id": 57, "string": "1 will match both LaceyChabert and MilaKunis before applying the aggregation function, but only LaceyChabert is the correct answer as she started this role earlier (by checking the from property of the grounded CVT node)."}, {"id": 58, "string": "Our query graph design is inspired by (Reddy et al., 2014) , but with some key differences."}, {"id": 59, "string": "The nodes and edges in our query graph closely resemble the exact entities and predicates from the knowledge base."}, {"id": 60, "string": "As a result, the graph can be straightforwardly translated to a logical form query that is directly executable."}, {"id": 61, "string": "In contrast, the query graph in (Reddy et al., 2014) is mapped from the CCG parse of the question, and needs further transformations before mapping to subgraphs 2 y should be grounded to a CVT entity in this case."}, {"id": 62, "string": "Figure 3 : The legitimate actions to grow a query graph."}, {"id": 63, "string": "See text for detail."}, {"id": 64, "string": "f S e S p S c A e A p A a /A c A a /A c of the target knowledge base to retrieve answers."}, {"id": 65, "string": "Semantically, our query graph is more related to simple \u03bb-DCS (Berant et al., 2013; Liang, 2013) , which is a syntactic simplification of \u03bb-calculus when applied to graph databases."}, {"id": 66, "string": "A query graph can be viewed as the tree-like graph pattern of a logical form in \u03bb-DCS."}, {"id": 67, "string": "For instance, the path from the answer node to an entity node can be described using a series of join operations in \u03bb-DCS."}, {"id": 68, "string": "Different paths of the tree graph are combined via the intersection operators."}, {"id": 69, "string": "Staged Query Graph Generation We focus on generating query graphs with the following properties."}, {"id": 70, "string": "First, the tree graph consists of one entity node as the root, referred as the topic entity."}, {"id": 71, "string": "Second, there exists only one lambda variable x as the answer node, with a directed path from the root to it, and has zero or more existential variables in-between."}, {"id": 72, "string": "We call this path the core inferential chain of the graph, as it describes the main relationship between the answer and topic entity."}, {"id": 73, "string": "Variables can only occur in this chain, and the chain only has variable nodes except the root."}, {"id": 74, "string": "Finally, zero or more entity or aggregation nodes can be attached to each variable node, including the answer node."}, {"id": 75, "string": "These branches are the additional constraints that the answers need to satisfy."}, {"id": 76, "string": "For example, in Fig."}, {"id": 77, "string": "2 , FamilyGuy is the root and FamilyGuy \u2192 y \u2192 x is the core inferential chain."}, {"id": 78, "string": "The branch y \u2192 MegGriffin specifies the character and y \u2192 arg min constrains that the answer needs to be the earliest actor for this role."}, {"id": 79, "string": "Given a question, we formalize the query graph generation process as a search problem, with staged states and actions."}, {"id": 80, "string": "Let S = {\u03c6, S e , S p , S c } be the set of states, where each state could be an empty graph (\u03c6), a singlenode graph with the topic entity (S e ), a core inferential chain (S p ), or a more complex query graph with additional constraints (S c )."}, {"id": 81, "string": "Let A = {A e , A p , A c , A a } be the set of actions."}, {"id": 82, "string": "An action grows a given graph by adding some edges and nodes."}, {"id": 83, "string": "In particular, A e picks an entity node; A p determines the core inferential chain; A c and A a add constraints and aggregation nodes, respectively."}, {"id": 84, "string": "Given a state, the valid action set can be defined by the finite state diagram in Fig."}, {"id": 85, "string": "3 ."}, {"id": 86, "string": "Notice that the order of possible actions is chosen for the convenience of implementation."}, {"id": 87, "string": "In principle, we could choose a different order, such as matching the core inferential chain first and then resolving the topic entity linking."}, {"id": 88, "string": "However, since we will consider multiple hypotheses during search, the order of the staged actions can simply be viewed as a different way to prune the search space or to bias the exploration order."}, {"id": 89, "string": "We define the reward function on the state space using a log-linear model."}, {"id": 90, "string": "The reward basically estimates the likelihood that a query graph correctly parses the question."}, {"id": 91, "string": "Search is done using the best-first strategy with a priority queue, which is formally defined in Appendix A."}, {"id": 92, "string": "In the following subsections, we use a running example of finding the semantic parse of question q ex = \"Who first voiced Meg of Family Guy?\""}, {"id": 93, "string": "to describe the sequence of actions."}, {"id": 94, "string": "Linking Topic Entity Starting from the initial state s 0 , the valid actions are to create a single-node graph that corresponds to the topic entity found in the given question."}, {"id": 95, "string": "For instance, possible topic entities in q ex can either be FamilyGuy or MegGriffin, shown in Fig."}, {"id": 96, "string": "4 ."}, {"id": 97, "string": "We use an entity linking system that is designed for short and noisy text (Yang and Chang, 2015) ."}, {"id": 98, "string": "For each entity e in the knowledge base, the system first prepares a surface-form lexicon that lists all possible ways that e can be mentioned in text."}, {"id": 99, "string": "This lexicon is created using various data sources, such as names and aliases of the entities, the anchor text in Web documents and the Wikipedia redirect table."}, {"id": 100, "string": "Given a question, it considers all the consecutive word sequences that have occurred in the lexicon as possible mentions, paired with their possible entities."}, {"id": 101, "string": "Each pair is then scored by a statistical model based on its frequency counts in the surface-form lexicon."}, {"id": 102, "string": "To tolerate potential mistakes of the entity linking system, as well as exploring more possible query graphs, up to 10 topranked entities are considered as the topic entity."}, {"id": 103, "string": "The linking score will also be used as a feature for the reward function."}, {"id": 104, "string": "Identifying Core Inferential Chain Given a state s that corresponds to a single-node graph with the topic entity e, valid actions to extend this graph is to identify the core inferential chain; namely, the relationship between the topic entity and the answer."}, {"id": 105, "string": "For example, Fig."}, {"id": 106, "string": "5 shows three possible chains that expand the single-node graph in s 1 ."}, {"id": 107, "string": "Because the topic entity e is given, we only need to explore legitimate predicate sequences that can start from e. Specifically, to restrict the search space, we explore all paths of length 2 when the middle existential variable can be grounded to a CVT node and paths of length 1 if not."}, {"id": 108, "string": "We also consider longer predicate sequences if the combinations are observed in training data 3 ."}, {"id": 109, "string": "Analogous to the entity linking problem, where the goal is to find the mapping of mentions to entities in K, identifying the core inferential chain is to map the natural utterance of the question to the correct predicate sequence."}, {"id": 110, "string": "For question \"Who first voiced Meg on [Family Guy]?\""}, {"id": 111, "string": "we need to measure the likelihood that each of the sequences in {cast-actor, writer-start, genre} correctly captures the relationship between Family Guy and Who."}, {"id": 112, "string": "We reduce this problem to measuring semantic similarity using neural networks."}, {"id": 113, "string": "Figure 6 : The architecture of the convolutional neural networks (CNN) used in this work."}, {"id": 114, "string": "The CNN model maps a variable-length word sequence (e.g., a pattern or predicate sequence) to a low-dimensional vector in a latent semantic space."}, {"id": 115, "string": "See text for the description of each layer."}, {"id": 116, "string": "Deep Convolutional Neural Networks To handle the huge variety of the semantically equivalent ways of stating the same question, as well as the mismatch of the natural language utterances and predicates in the knowledge base, we propose using Siamese neural networks (Bromley et al., 1993) for identifying the core inferential chain."}, {"id": 117, "string": "For instance, one of our constructions maps the question to a pattern by replacing the entity mention with a generic symbol <e> and then compares it with a candidate chain, such as \"who first voiced meg on <e>\" vs. cast-actor."}, {"id": 118, "string": "The model consists of two neural networks, one for the pattern and the other for the inferential chain."}, {"id": 119, "string": "Both are mapped to k-dimensional vectors as the output of the networks."}, {"id": 120, "string": "Their semantic similarity is then computed using some distance function, such as cosine."}, {"id": 121, "string": "This continuous-space representation approach has been proposed recently for semantic parsing and question answering (Bordes et al., 2014a; Yih et al., 2014) and has shown better results compared to lexical matching approaches (e.g., word-alignment models)."}, {"id": 122, "string": "In this work, we adapt a convolutional neural network (CNN) framework (Shen et al., 2014b; Shen et al., 2014a; Gao et al., 2014) to this matching problem."}, {"id": 123, "string": "The network architecture is illustrated in Fig."}, {"id": 124, "string": "6 ."}, {"id": 125, "string": "The CNN model first applies a word hashing technique (Huang et al., 2013) that breaks a word into a vector of letter-trigrams (x t \u2192 f t in Fig."}, {"id": 126, "string": "6 )."}, {"id": 127, "string": "For example, the bag of letter-trigrams of the word \"who\" are #-w-h, w-h-o, h-o-# after adding the Figure 7 : Extending an inferential chain with constraints and aggregation functions."}, {"id": 128, "string": "word boundary symbol #."}, {"id": 129, "string": "Then, it uses a convolutional layer to project the letter-trigram vectors of words within a context window of 3 words to a local contextual feature vector (f t \u2192 h t ), followed by a max pooling layer that extracts the most salient local features to form a fixed-length global feature vector (v)."}, {"id": 130, "string": "The global feature vector is then fed to feed-forward neural network layers to output the final non-linear semantic features (y), as the vector representation of either the pattern or the inferential chain."}, {"id": 131, "string": "Training the model needs positive pairs, such as a pattern like \"who first voiced meg on <e>\" and an inferential chain like cast-actor."}, {"id": 132, "string": "These pairs can be extracted from the full semantic parses when provided in the training data."}, {"id": 133, "string": "If the correct semantic parses are latent and only the pairs of questions and answers are available, such as the case in the WEBQUESTIONS dataset, we can still hypothesize possible inferential chains by traversing the paths in the knowledge base that connect the topic entity and the answer."}, {"id": 134, "string": "Sec."}, {"id": 135, "string": "4.1 will illustrate this data generation process in detail."}, {"id": 136, "string": "Our model has two advantages over the embedding approach (Bordes et al., 2014a) ."}, {"id": 137, "string": "First, the word hashing layer helps control the dimensionality of the input space and can easily scale to large vocabulary."}, {"id": 138, "string": "The letter-trigrams also capture some sub-word semantics (e.g., words with minor typos have almost identical letter-trigram vectors), which makes it especially suitable for questions from real-world users, such as those issued to a search engine."}, {"id": 139, "string": "Second, it uses a deeper architecture with convolution and max-pooling layers, which has more representation power."}, {"id": 140, "string": "Augmenting Constraints & Aggregations A graph with just the inferential chain forms the simplest legitimate query graph and can be executed against the knowledge base K to retrieve the answers; namely, all the entities that x can be grounded to."}, {"id": 141, "string": "For instance, the graph in s 3 in Fig."}, {"id": 142, "string": "7 will retrieve all the actors who have been on FamilyGuy."}, {"id": 143, "string": "Although this set of entities obviously contains the correct answer to the question (assuming the topic entity FamilyGuy is correct), it also includes incorrect entities that do not satisfy additional constraints implicitly or explicitly mentioned in the question."}, {"id": 144, "string": "To further restrict the set of answer entities, the graph with only the core inferential chain can be expanded by two types of actions: A c and A a ."}, {"id": 145, "string": "A c is the set of possible ways to attach an entity to a variable node, where the edge denotes one of the valid predicates that can link the variable to the entity."}, {"id": 146, "string": "For instance, in Fig."}, {"id": 147, "string": "7 , s 6 is created by attaching MegGriffin to y with the predicate character."}, {"id": 148, "string": "This is equivalent to the last conjunctive term in the corresponding \u03bb-expression: \u03bbx.\u2203y.cast(FamilyGuy, y) \u2227 actor(y, x) \u2227 character(y, MegGriffin)."}, {"id": 149, "string": "Sometimes, the constraints are described over the entire answer set through the aggregation function, such as the word \"first\" in our example question q ex ."}, {"id": 150, "string": "This is handled similarly by actions A a , which attach an aggregation node on a variable node."}, {"id": 151, "string": "For example, the arg min node of s 7 in Fig."}, {"id": 152, "string": "7 chooses the grounding with the smallest from attribute of y."}, {"id": 153, "string": "The full possible constraint set can be derived by first issuing the core inferential chain as a query to the knowledge base to find the bindings of variables y's and x, and then enumerating all neighboring nodes of these entities."}, {"id": 154, "string": "This, however, often results in an unnecessarily large constraint pool."}, {"id": 155, "string": "In this work, we employ simple rules to retain only the nodes that have some possibility to be legitimate constraints."}, {"id": 156, "string": "For instance, a constraint node can be an entity that also appears in the question (detected by our entity linking component), or an aggregation constraint can only be added if certain keywords like \"first\" or \"latest\" occur in the question."}, {"id": 157, "string": "The complete set of these rules can be found in Appendix B."}, {"id": 158, "string": "Learning the reward function Given a state s, the reward function \u03b3(s) basically judges whether the query graph represented by s is the correct semantic parse of the input question q."}, {"id": 159, "string": "We use a log-linear model to learn the reward function."}, {"id": 160, "string": "Below we describe the features and the learning process."}, {"id": 161, "string": "Features The features we designed essentially match specific portions of the graph to the question, and generally correspond to the staged actions described previously, including: Topic Entity The score returned by the entity linking system is directly used as a feature."}, {"id": 162, "string": "Core Inferential Chain We use similarity scores of different CNN models described in Sec."}, {"id": 163, "string": "3.2.1 to measure the quality of the core inferential chain."}, {"id": 164, "string": "PatChain compares the pattern (replacing the topic entity with an entity symbol) and the predicate sequence."}, {"id": 165, "string": "QuesEP concatenates the canonical name of the topic entity and the predicate sequence, and compares it with the question."}, {"id": 166, "string": "This feature conceptually tries to verify the entity linking suggestion."}, {"id": 167, "string": "These two CNN models are learned using pairs of the question and the inferential chain of the parse in the training data."}, {"id": 168, "string": "In addition to the in-domain similarity features, we also train a ClueWeb model using the Freebase annotation of ClueWeb corpora (Gabrilovich et al., 2013) ."}, {"id": 169, "string": "For two entities in a sentence that can be linked by one or two predicates, we pair the sentences and predicates to form a parallel corpus to train the CNN model."}, {"id": 170, "string": "Constraints & Aggregations When a constraint node is present in the graph, we use some simple features to check whether there are words in the question that can be associated with the constraint entity or property."}, {"id": 171, "string": "Examples of such features include whether a mention in the question can be linked to this entity, and the percentage of the words in the name of the constraint entity appear in the question."}, {"id": 172, "string": "Similarly, we check the existence of some keywords in a pre-compiled list, such as \"first\", \"current\" or \"latest\" as features for aggregation nodes such as arg min."}, {"id": 173, "string": "The complete list of these simple word matching features can also be found in Appendix B."}, {"id": 174, "string": "Overall The number of the answer entities retrieved when issuing the query to the knowledge base and the number of nodes in the query graph are both included as features."}, {"id": 175, "string": "(1) EntityLinkingScore(FamilyGuy, Family Guy ) = 0.9 (2) PatChain( who first voiced meg on <e> , cast-actor) = 0.7 (3) QuesEP(q, family guy cast-actor ) = 0.6 (4) ClueWeb( who first voiced meg on <e> , cast-actor) = 0.2 (5) ConstraintEntityWord( Meg Griffin , q) = 0.5 (6) ConstraintEntityInQ( Meg Griffin , q) = 1 (7) AggregationKeyword(argmin, q) = 1 (8) NumNodes(s) = 5 (9) NumAns(s) = 1 s Figure 8 : Active features of a query graph s. (1) is the entity linking score of the topic entity."}, {"id": 176, "string": "(2)-(4) are different model scores of the core chain."}, {"id": 177, "string": "(5) indicates 50% of the words in \"Meg Griffin\" appear in the question q."}, {"id": 178, "string": "(6) is 1 when the mention \"Meg\" in q is correctly linked to MegGriffin by the entity linking component."}, {"id": 179, "string": "(8) is the number of nodes in s. The knowledge base returns only 1 entity when issuing this query, so (9) is 1."}, {"id": 180, "string": "To illustrate our feature design, Fig."}, {"id": 181, "string": "8 presents the active features of an example query graph."}, {"id": 182, "string": "Learning In principle, once the features are extracted, the model can be trained using any standard off-theshelf learning algorithm."}, {"id": 183, "string": "Instead of treating it as a binary classification problem, where only the correct query graphs are labeled as positive, we view it as a ranking problem."}, {"id": 184, "string": "Suppose we have several candidate query graphs for each question 4 ."}, {"id": 185, "string": "Let g a and g b be the query graphs described in states s a and s b for the same question q, and the entity sets A a and A b be those retrieved by executing g a and g b , respectively."}, {"id": 186, "string": "Suppose that A is the labeled answers to q."}, {"id": 187, "string": "We first compute the precision, recall and F 1 score of A a and A b , compared with the gold answer set A."}, {"id": 188, "string": "We then rank s a and s b by their F 1 scores 5 ."}, {"id": 189, "string": "The intuition behind is that even if a query is not completely correct, it is still preferred than some other totally incorrect queries."}, {"id": 190, "string": "In this work, we use a one-layer neural network model based on lambda-rank (Burges, 2010) for training the ranker."}, {"id": 191, "string": "Experiments We first introduce the dataset and evaluation metric, followed by the main experimental results and some analysis."}, {"id": 192, "string": "Data & evaluation metric We use the WEBQUESTIONS dataset (Berant et al., 2013) , which consists of 5,810 question/answer pairs."}, {"id": 193, "string": "These questions were collected using Google Suggest API and the answers were obtained from Freebase with the help of Amazon MTurk."}, {"id": 194, "string": "The questions are split into training and testing sets, which contain 3,778 questions (65%) and 2,032 questions (35%), respectively."}, {"id": 195, "string": "This dataset has several unique properties that make it appealing and was used in several recent papers on semantic parsing and question answering."}, {"id": 196, "string": "For instance, although the questions are not directly sampled from search query logs, the selection process was still biased to commonly asked questions on a search engine."}, {"id": 197, "string": "The distribution of this question set is thus closer to the \"real\" information need of search users than that of a small number of human editors."}, {"id": 198, "string": "The system performance is basically measured by the ratio of questions that are answered correctly."}, {"id": 199, "string": "Because there can be more than one answer to a question, precision, recall and F 1 are computed based on the system output for each individual question."}, {"id": 200, "string": "The average F 1 score is reported as the main evaluation metric 6 ."}, {"id": 201, "string": "Because this dataset contains only question and answer pairs, we use essentially the same search procedure to simulate the semantic parses for training the CNN models and the overall reward function."}, {"id": 202, "string": "Candidate topic entities are first generated using the same entity linking system for each question in the training data."}, {"id": 203, "string": "Paths on the Freebase knowledge graph that connect a candidate entity to at least one answer entity are identified as the core inferential chains 7 ."}, {"id": 204, "string": "If an inferentialchain query returns more entities than the correct answers, we explore adding constraint and aggregation nodes, until the entities retrieved by the query graph are identical to the labeled answers, or the F 1 score cannot be increased further."}, {"id": 205, "string": "Negative examples are sampled from of the incorrect candidate graphs generated during the search process."}, {"id": 206, "string": "Method Prec."}, {"id": 207, "string": "Rec."}, {"id": 208, "string": "F1 (Berant et al., 2013) 48.0 41.3 35.7 (Bordes et al., 2014b) --29.7 (Yao and Van Durme, 2014) --33.0 (Berant and Liang, 2014) 40.5 46.6 39.9 (Bao et al., 2014) --37.5 (Bordes et al., 2014a) --39.2 (Yang et al., 2014) --41.3 (Wang et al., 2014) --45.3 Our approach -STAGG 52.8 60.7 52.5 Table 1 : The results of our approach compared to existing work."}, {"id": 209, "string": "The numbers of other systems are either from the original papers or derived from the evaluation script, when the output is available."}, {"id": 210, "string": "In the end, we produce 17,277 query graphs with none-zero F 1 scores from the training set questions and about 1.7M completely incorrect ones."}, {"id": 211, "string": "For training the CNN models to identify the core inferential chain (Sec."}, {"id": 212, "string": "3.2.1), we only use 4,058 chain-only query graphs that achieve F 1 = 0.5 to form the parallel question and predicate sequence pairs."}, {"id": 213, "string": "The hyper-parameters in CNN, such as the learning rate and the numbers of hidden nodes at the convolutional and semantic layers were chosen via cross-validation."}, {"id": 214, "string": "We reserved 684 pairs of patterns and inference-chains from the whole training examples as the held-out set, and the rest as the initial training set."}, {"id": 215, "string": "The optimal hyper-parameters were determined by the performance of models trained on the initial training set when applied to the held-out data."}, {"id": 216, "string": "We then fixed the hyper-parameters and retrained the CNN models using the whole training set."}, {"id": 217, "string": "The performance of CNN is insensitive to the hyperparameters as long as they are in a reasonable range (e.g., 1000 \u00b1 200 nodes in the convolutional layer, 300 \u00b1 100 nodes in the semantic layer, and learning rate 0.05 \u223c 0.005) and the training process often converges after \u223c 800 epochs."}, {"id": 218, "string": "When training the reward function, we created up to 4,000 examples for each question that contain all the positive query graphs and randomly selected negative examples."}, {"id": 219, "string": "The model is trained as a ranker, where example query graphs are ranked by their F 1 scores."}, {"id": 220, "string": "Results Tab."}, {"id": 221, "string": "1 shows the results of our system, STAGG (Staged query graph generation), compared to existing work 8 ."}, {"id": 222, "string": "As can be seen from the table, our 8 We do not include results of (Reddy et al., 2014) system outperforms the previous state-of-the-art method by a large margin -7.2% absolute gain."}, {"id": 223, "string": "Given the staged design of our approach, it is thus interesting to examine the contributions of each component."}, {"id": 224, "string": "Because topic entity linking is the very first stage, the quality of the entities found in the questions, both in precision and recall, affects the final results significantly."}, {"id": 225, "string": "To get some insight about how our topic entity linking component performs, we also experimented with applying Freebase Search API to suggest entities for possible mentions in a question."}, {"id": 226, "string": "As can be observed in Tab."}, {"id": 227, "string": "2, to cover most of the training questions, we only need half of the number of suggestions when using our entity linking component, compared to Freebase API."}, {"id": 228, "string": "Moreover, they also cover more entities that were selected as the topic entities in the original dataset."}, {"id": 229, "string": "Starting from those 9,147 entities output by our component, answers of 3,453 questions (91.4%) can be found in their neighboring nodes."}, {"id": 230, "string": "When replacing our entity linking component with the results from Freebase API, we also observed a significant performance degradation."}, {"id": 231, "string": "The overall system performance drops from 52.5% to 48.4% in F 1 (Prec = 49.8%, Rec = 55.7%), which is 4.1 points lower."}, {"id": 232, "string": "Next we test the system performance when the query graph has just the core inferential chain."}, {"id": 233, "string": "Tab."}, {"id": 234, "string": "3 summarizes the results."}, {"id": 235, "string": "When only the PatChain CNN model is used, the performance is already very strong, outperforming all existing work."}, {"id": 236, "string": "Adding the other CNN models boosts the performance further, reaching 51.8% and is only slightly lower than the full system performance."}, {"id": 237, "string": "This may be due to two reasons."}, {"id": 238, "string": "First, the questions from search engine users are often short and a large portion of them simply ask about properties of an entity."}, {"id": 239, "string": "Examining the query graphs generated for training set questions, we found that 1,888 directly comparable to results from other work."}, {"id": 240, "string": "On these 570 questions, our system achieves 67.0% in F1."}, {"id": 241, "string": "(50.0%) can be answered exactly (i.e., F 1 = 1) using a chain-only query graph."}, {"id": 242, "string": "Second, even if the correct parse requires more constraints, the less constrained graph still gets a partial score, as its results cover the correct answers."}, {"id": 243, "string": "Error Analysis Although our approach substantially outperforms existing methods, the room for improvement seems big."}, {"id": 244, "string": "After all, the accuracy for the intended application, question answering, is still low and only slightly above 50%."}, {"id": 245, "string": "We randomly sampled 100 questions that our system did not generate the completely correct query graphs, and categorized the errors."}, {"id": 246, "string": "About one third of errors are in fact due to label issues and are not real mistakes."}, {"id": 247, "string": "This includes label error (2%), incomplete labels (17%, e.g., only one song is labeled as the answer to \"What songs did Bob Dylan write?\")"}, {"id": 248, "string": "and acceptable answers (15%, e.g., \"Time in China\" vs. \"UTC+8\")."}, {"id": 249, "string": "8% of the errors are due to incorrect entity linking; however, sometimes the mention is inherently ambiguous (e.g., AFL in \"Who founded the AFL?\""}, {"id": 250, "string": "could mean either \"American Football League\" or \"American Federation of Labor\")."}, {"id": 251, "string": "35% of the errors are because of the incorrect inferential chains; 23% are due to incorrect or missing constraints."}, {"id": 252, "string": "Related Work and Discussion Several semantic parsing methods use a domainindependent meaning representation derived from the combinatory categorial grammar (CCG) parses (e.g., (Cai and Yates, 2013; Kwiatkowski et al., 2013; Reddy et al., 2014) )."}, {"id": 253, "string": "In contrast, our query graph design matches closely the graph knowledge base."}, {"id": 254, "string": "Although not fully demonstrated in this paper, the query graph can in fact be fairly expressive."}, {"id": 255, "string": "For instance, negations can be handled by adding tags to the constraint nodes indicating that certain conditions cannot be satisfied."}, {"id": 256, "string": "Our graph generation method is inspired by (Yao and Van Durme, 2014; Bao et al., 2014) ."}, {"id": 257, "string": "Unlike traditional semantic parsing approaches, it uses the knowledge base to help prune the search space when forming the parse."}, {"id": 258, "string": "Similar ideas have also been explored in (Poon, 2013) ."}, {"id": 259, "string": "Empirically, our results suggest that it is crucial to identify the core inferential chain, which matches the relationship between the topic entity in the question and the answer."}, {"id": 260, "string": "Our CNN models can be analogous to the embedding approaches (Bordes et al., 2014a; Yang et al., 2014) , but are more sophisticated."}, {"id": 261, "string": "By allowing parameter sharing among different question-pattern and KB predicate pairs, the matching score of a rare or even unseen pair in the training data can still be predicted precisely."}, {"id": 262, "string": "This is due to the fact that the prediction is based on the shared model parameters (i.e., projection matrices) that are estimated using all training pairs."}, {"id": 263, "string": "Conclusion In this paper, we present a semantic parsing framework for question answering using a knowledge base."}, {"id": 264, "string": "We define a query graph as the meaning representation that can be directly mapped to a logical form."}, {"id": 265, "string": "Semantic parsing is reduced to query graph generation, formulated as a staged search problem."}, {"id": 266, "string": "With the help of an advanced entity linking system and a deep convolutional neural network model that matches questions and predicate sequences, our system outperforms previous methods substantially on the WEBQUESTIONS dataset."}, {"id": 267, "string": "In the future, we would like to extend our query graph to represent more complicated questions, and explore more features and models for matching constraints and aggregation functions."}, {"id": 268, "string": "Applying other structured-output prediction methods to graph generation will also be investigated."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 31}, {"section": "Background", "n": "2", "start": 32, "end": 34}, {"section": "Knowledge base", "n": "2.1", "start": 35, "end": 42}, {"section": "Query graph", "n": "2.2", "start": 43, "end": 68}, {"section": "Staged Query Graph Generation", "n": "3", "start": 69, "end": 93}, {"section": "Linking Topic Entity", "n": "3.1", "start": 94, "end": 103}, {"section": "Identifying Core Inferential Chain", "n": "3.2", "start": 104, "end": 115}, {"section": "Deep Convolutional Neural Networks", "n": "3.2.1", "start": 116, "end": 139}, {"section": "Augmenting Constraints & Aggregations", "n": "3.3", "start": 140, "end": 157}, {"section": "Learning the reward function", "n": "3.4", "start": 158, "end": 160}, {"section": "Features", "n": "3.4.1", "start": 161, "end": 181}, {"section": "Learning", "n": "3.4.2", "start": 182, "end": 189}, {"section": "Experiments", "n": "4", "start": 190, "end": 191}, {"section": "Data & evaluation metric", "n": "4.1", "start": 192, "end": 219}, {"section": "Results", "n": "4.2", "start": 220, "end": 242}, {"section": "Error Analysis", "n": "4.3", "start": 243, "end": 251}, {"section": "Related Work and Discussion", "n": "5", "start": 252, "end": 262}, {"section": "Conclusion", "n": "6", "start": 263, "end": 268}], "figures": [{"filename": "../figure/image/1072-Figure1-1.png", "caption": "Figure 1: Freebase subgraph of Family Guy", "page": 1, "bbox": {"x1": 322.56, "x2": 515.04, "y1": 81.6, "y2": 264.0}}, {"filename": "../figure/image/1072-Figure8-1.png", "caption": "Figure 8: Active features of a query graph s. (1) is the entity linking score of the topic entity. (2)- (4) are different model scores of the core chain. (5) indicates 50% of the words in \u201cMeg Griffin\u201d appear in the question q. (6) is 1 when the mention \u201cMeg\u201d in q is correctly linked to MegGriffin by the entity linking component. (8) is the number of nodes in s. The knowledge base returns only 1 entity when issuing this query, so (9) is 1.", "page": 6, "bbox": {"x1": 73.92, "x2": 287.52, "y1": 67.2, "y2": 233.76}}, {"filename": "../figure/image/1072-Figure3-1.png", "caption": "Figure 3: The legitimate actions to grow a query graph. See text for detail.", "page": 2, "bbox": {"x1": 312.96, "x2": 517.92, "y1": 73.44, "y2": 110.39999999999999}}, {"filename": "../figure/image/1072-Figure2-1.png", "caption": "Figure 2: Query graph that represents the question \u201cWho first voiced Meg on Family Guy?\u201d", "page": 2, "bbox": {"x1": 86.88, "x2": 276.0, "y1": 80.64, "y2": 133.92}}, {"filename": "../figure/image/1072-Table1-1.png", "caption": "Table 1: The results of our approach compared to existing work. The numbers of other systems are either from the original papers or derived from the evaluation script, when the output is available.", "page": 7, "bbox": {"x1": 87.84, "x2": 274.08, "y1": 65.75999999999999, "y2": 169.92}}, {"filename": "../figure/image/1072-Table2-1.png", "caption": "Table 2: Statistics of entity linking results on training set questions. Both methods cover roughly the same number of questions, but Freebase API suggests twice the number of entities output by our entity linking system and covers fewer topic entities labeled in the original data.", "page": 7, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 65.75999999999999, "y2": 100.32}}, {"filename": "../figure/image/1072-Figure4-1.png", "caption": "Figure 4: Two possible topic entity linking actions applied to an empty graph, for question \u201cWho first voiced [Meg] on [Family Guy]?\u201d", "page": 3, "bbox": {"x1": 104.64, "x2": 258.24, "y1": 71.52, "y2": 144.0}}, {"filename": "../figure/image/1072-Figure5-1.png", "caption": "Figure 5: Candidate core inferential chains start from the entity FamilyGuy.", "page": 3, "bbox": {"x1": 307.68, "x2": 526.0799999999999, "y1": 67.67999999999999, "y2": 147.35999999999999}}, {"filename": "../figure/image/1072-Table3-1.png", "caption": "Table 3: The system results when only the inferential-chain query graphs are generated. We started with the PatChain CNN model and then added QuesEP and ClueWeb sequentially. See Sec. 3.4 for the description of these models.", "page": 8, "bbox": {"x1": 111.83999999999999, "x2": 251.04, "y1": 65.75999999999999, "y2": 109.92}}, {"filename": "../figure/image/1072-Figure6-1.png", "caption": "Figure 6: The architecture of the convolutional neural networks (CNN) used in this work. The CNN model maps a variable-length word sequence (e.g., a pattern or predicate sequence) to a low-dimensional vector in a latent semantic space. See text for the description of each layer.", "page": 4, "bbox": {"x1": 82.56, "x2": 282.24, "y1": 76.8, "y2": 208.79999999999998}}, {"filename": "../figure/image/1072-Figure7-1.png", "caption": "Figure 7: Extending an inferential chain with constraints and aggregation functions.", "page": 4, "bbox": {"x1": 308.64, "x2": 526.0799999999999, "y1": 68.64, "y2": 199.2}}]}