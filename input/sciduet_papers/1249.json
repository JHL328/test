{"title": "Simplified Abugidas", "abstract": "An abugida is a writing system where the consonant letters represent syllables with a default vowel and other vowels are denoted by diacritics. We investigate the feasibility of recovering the original text written in an abugida after omitting subordinate diacritics and merging consonant letters with similar phonetic values. This is crucial for developing more efficient input methods by reducing the complexity in abugidas. Four abugidas in the southern Brahmic family, i.e., Thai, Burmese, Khmer, and Lao, were studied using a newswire 20, 000-sentence dataset. We compared the recovery performance of a support vector machine and an LSTMbased recurrent neural network, finding that the abugida graphemes could be recovered with 94% -97% accuracy at the top-1 level and 98% -99% at the top-4 level, even after omitting most diacritics (10 -30 types) and merging the remaining 30 -50 characters into 21 graphemes.", "text": [{"id": 0, "string": "Introduction Writing systems are used to record utterances in a wide range of languages and can be organized into the hierarchy shown in Fig."}, {"id": 1, "string": "1 ."}, {"id": 2, "string": "The symbols in a writing system generally represent either speech sounds (phonograms) or semantic units (logograms) ."}, {"id": 3, "string": "Phonograms can be either segmental or syllabic, with segmental systems being more phonetic because they use separate symbols (i.e., letters) to represent consonants and vowels."}, {"id": 4, "string": "Segmental systems can be further subdivided depending on their representation of vowels."}, {"id": 5, "string": "Alphabets (e.g., the Latin, Cyrillic, and Greek scripts) are the most common and treat vowel and consonant let- ters equally."}, {"id": 6, "string": "In contrast, abjads (e.g., the Arabic and Hebrew scripts) do not write most vowels explicitly."}, {"id": 7, "string": "The third type, abugidas, also called alphasyllabary, includes features from both segmental and syllabic systems."}, {"id": 8, "string": "In abugidas, consonant letters represent syllables with a default vowel, and other vowels are denoted by diacritics."}, {"id": 9, "string": "Abugidas thus denote vowels less explicitly than alphabets but more explicitly than abjads, while being less phonetic than alphabets, but more phonetic than syllabaries."}, {"id": 10, "string": "Since abugidas combine segmental and syllabic systems, they typically have more symbols than conventional alphabets."}, {"id": 11, "string": "In this study, we investigate how to simplify and recover abugidas, with the aim of developing a more efficient method of encoding abugidas for input."}, {"id": 12, "string": "Alphabets generally do not have a large set of symbols, making them easy to map to a traditional keyboard, and logogram and syllabic systems need specially designed input methods because of their large variety of symbols."}, {"id": 13, "string": "Traditional input methods for abugidas are similar to those for alphabets, mapping two or three different symbols onto each key and requiring users to type each character and diacritic exactly."}, {"id": 14, "string": "In contrast, we are able to substantially simplify inputting abugidas by encoding them in a lossy (or \"fuzzy\") way."}, {"id": 15, "string": "TH \u0e30 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 \u0e31 MY \u102d \u102d \u102d \u102d \u1031\u102d \u102d \u102d \u102d \u102d KM \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17be\u17b7 \u17be\u17b7 \u17be\u17b7 \u17be\u17b7 \u17c2\u17b7 \u17c3\u17b7 \u17be\u17b7 \u17be\u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 LO \u0eb0 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u0ebd \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 \u17b7 OMITTED I II I II I II I II MN K G U C J I Y T D N L P B M W R S H Q A E TH \u0e01\u0e02\u0e03 \u0e04\u0e05\u0e06 \u0e07 \u0e08\u0e09 \u0e0a\u0e0b\u0e0c \u0e0d \u0e22 \u0e0e\u0e0f\u0e10\u0e14\u0e15\u0e16 \u0e11\u0e12\u0e17\u0e18 \u0e13\u0e19 \u0e25\u0e26\u0e2c \u0e1a\u0e1b\u0e1c\u0e1d \u0e1e\u0e1f\u0e20 \u0e21 \u0e27 \u0e23\u0e24 \u0e28\u0e29\u0e2a \u0e2b\u0e2c \u0e2d \u0e45 \u0e40 \u0e41 \u0e42 \u0e43 \u0e44 MY \u1000\u1001 \u1002\u1003 \u1004 \u1005\u1006 \u1007\u1008 \u1009 \u100a \u101a \u102d \u100b\u100c\u1010\u1011 \u100d\u100e\u1012\u1013 \u100f\u1014 \u101c\u1020 \u1015\u1016 \u1017\u1018 \u1019 \u101d \u102d \u101b \u103c\u102d \u101e\u103f \u101f \u102d \u1021 \u102d \u102d \u102d \u102d KM \u1780\u1781 \u1782\u1783 \u1784 \u1785\u1786 \u1787\u1788 \u1789 \u1799 \u178a\u178b\u178f\u1790 \u178c\u178d\u1791\u1792 \u178e\u1793 \u179b\u17a1 \u1794\u1795 \u1796\u1797 \u1798 \u179c \u179a \u179d\u179e\u179f \u17a0 \u17a2 \u17b7 \u17d2 LO \u0e81\u0e82 \u0e84 \u0e87 \u0e88 \u0e8a \u0e8d \u0ea2 \u0e94\u0e95\u0e96 \u0e97 \u0e99 \u0ea5 \u0e9a\u0e9b\u0e9c\u0e9d \u0e9e\u0e9f \u0ea1 \u0ea7 \u0ea3 \u0eaa \u0eab\u0eae \u0ead \u0ec0 \u0ec1 \u0ec2 \u0ec3 \u0ec4 APP."}, {"id": 16, "string": "DENTAL PALATE PRE-V. DE-V. PLOSIVE NAS."}, {"id": 17, "string": "MERGED R-LIKE S-LIKE H-LIKE LONG-A ZERO-C. LABIAL PLOSIVE NAS."}, {"id": 18, "string": "APP."}, {"id": 19, "string": "PLOSIVE NAS."}, {"id": 20, "string": "GUTTURAL PLOSIVE NAS."}, {"id": 21, "string": "APP."}, {"id": 22, "string": "Figure 3 : Merging and omission for Thai (TH), Burmese (MY), Khmer (KM), and Lao (LO) scripts."}, {"id": 23, "string": "The MN row lists the mnemonics assigned to graphemes in our experiment."}, {"id": 24, "string": "In this study, the mnemonics can be assigned arbitrarily, and we selected Latin letters related to the real pronunciation wherever possible."}, {"id": 25, "string": "Fig."}, {"id": 26, "string": "2 gives an overview of this study, showing examples in Khmer."}, {"id": 27, "string": "We simplify abugidas by omitting vowel diacritics and merging consonant letters with identical or similar phonetic values, as shown in (a)."}, {"id": 28, "string": "This simplification is intuitive, both orthographically and phonetically."}, {"id": 29, "string": "To resolve the ambiguities introduced by the simplification, we use data-driven methods to recover the original texts, as shown in (b)."}, {"id": 30, "string": "We conducted experiments on four southern Brahmic scripts, i.e., Thai, Burmese, Khmer, and Lao scripts, with a unified framework, using data from the Asian Language Treebank (ALT) (Riza et al., 2016) ."}, {"id": 31, "string": "The experiments show that the abugidas can be recovered satisfactorily by a recurrent neural network (RNN) using long short-term memory (LSTM) units, even when nearly all of the diacritics (10 -30 types) have been omitted and the remaining 30 -50 characters have been merged into 21 graphemes."}, {"id": 32, "string": "Thai gave the best performance, with 97% top-1 accuracy for graphemes and over 99% top-4 accuracy."}, {"id": 33, "string": "Lao, which gave the worst performance, still achieved the top-1 and top-4 accuracies of around 94% and 98%, respectively."}, {"id": 34, "string": "The Burmese and Khmer results, which lay in-between the other two, were also investigated by manual evaluation."}, {"id": 35, "string": "Related Work Some optimized keyboard layout have been proposed for specific abugidas (Ouk et al., 2008) ."}, {"id": 36, "string": "Most studies on input methods have focused on Chinese and Japanese characters, where thousands of symbols need to be encoded and recovered."}, {"id": 37, "string": "For Chinese characters, Chen and Lee (2000) made an early attempt to apply statistical methods to sentence-level processing, using a hidden Markov model."}, {"id": 38, "string": "Others have examined max-entropy models, support vector machines (SVMs), conditional random fields (CRFs), and machine translation techniques (Wang et al., 2006; Jiang et al., 2007; Li et al., 2009; Yang et al., 2012) ."}, {"id": 39, "string": "Similar methods have also been developed for character conversion in Japanese (Tokunaga et al., 2011) ."}, {"id": 40, "string": "This study takes a similar approach to the research on Chinese and Japanese, transforming a less informative encoding into strings in a natural and redundant writing system."}, {"id": 41, "string": "Furthermore, our study can be considered as a specific lossy compression scheme on abugida textual data."}, {"id": 42, "string": "Unlike images or audio, the lossy text compression has received little attention as it may cause difficulties with reading (Witten et al., 1994) ."}, {"id": 43, "string": "However, we handle this issue within an input method framework, where the simplified encoding is not read directly."}, {"id": 44, "string": "Simplified Abugidas We designed simplification schemes for several different scripts within a unified framework based on phonetics and conventional usages, without considering many language specific features."}, {"id": 45, "string": "Our primary aim was to investigate the feasibility of reducing the complexity of abugidas and to establish methods of recovering the texts."}, {"id": 46, "string": "We will consider language-specific optimization in a future work, via both data-and user-driven studies."}, {"id": 47, "string": "The simplification scheme is shown in Fig."}, {"id": 48, "string": "3 ."}, {"id": 49, "string": "1 Generally, the merges are based on the common distribution of consonant phonemes in most natural languages, as well as the etymology of the characters in each abugida."}, {"id": 50, "string": "Specifically, three or four graphemes are preserved for the different articulation locations (i.e., guttural, palate, dental, and labial), that two for plosives, one for nasal (NAS."}, {"id": 51, "string": "), and one for approximant (APP.)"}, {"id": 52, "string": "if present."}, {"id": 53, "string": "Additional consonants such as trills (R-LIKE), fricatives (S-/H-LIKE), and empty (ZERO-C.) are also assigned their own graphemes."}, {"id": 54, "string": "Although the simplification omits most diacritics, three types are retained, i.e., one basic mark common to nearly all Brahmic abugidas (LONG-A), the preposed vowels in Thai and Lao (PRE-V.), and the vowel-depressors (and/or consonant-stackers) in Burmese and Khmer (DE-V.)."}, {"id": 55, "string": "We assigned graphemes to these because we found they informed the spelling and were intuitive when typing."}, {"id": 56, "string": "The net result was the omission of 18 types of diacritics in Thai, 9 in Burmese, 27 in Khmer, and 18 in Lao, and the merging of the remaining 53 types of characters in Thai, 43 in Burmese, 37 in Khmer, and 33 in Lao, into a unified set of 21 graphemes."}, {"id": 57, "string": "The simplification thus substantially reduces the number of graphemes, and represents a straightforward benchmark for further languagespecific refinement to build on."}, {"id": 58, "string": "Recovery Methods The recovery process can be formalized as a sequential labeling task, that takes the simplified encoding as input, and outputs the writing units, composed of merged and omitted character(s) in the original abugidas, corresponding to each simplified grapheme."}, {"id": 59, "string": "Although structured learning methods such as CRF (Lafferty et al., 2001) have been widely used, we found that searching for the label sequences in the output space was too costly, because of the number of labels to be recovered."}, {"id": 60, "string": "2 Instead, we adopted non-structured point-wise prediction methods using a linear SVM (Cortes and Vapnik, 1995) and an LSTM-based RNN (Hochreiter and Schmidhuber, 1997) ."}, {"id": 61, "string": "Fig."}, {"id": 62, "string": "4 shows the overall structure of the RNN."}, {"id": 63, "string": "After many experimentations, a general \"shallow and broad\" configuration was adopted."}, {"id": 64, "string": "Specifically, simplified grapheme bi-grams are first embedded into 128-dimensional vectors 3 and then encoded in one layer of a bi-directional LSTM, resulting in a final representation consisting of a 512-dimensional vector that concatenates two 256-dimensional vectors from the two directions."}, {"id": 65, "string": "The number of dimensions used here is large because we found that higher-dimensional vectors were more effective than the deeper structures for this task, as memory capacity was more important than classification ability."}, {"id": 66, "string": "For the same reason, the representations obtained from the LSTM layer are transformed linearly before the softmax function is applied, as we found that non-linear transformations, which are commonly used for final classification, did not help for this task."}, {"id": 67, "string": "Experiments and Evaluation We used raw textual data from the ALT, 4 comprising around 20, 000 sentences translated from English."}, {"id": 68, "string": "The data were divided into training, development, and test sets as specified by the project."}, {"id": 69, "string": "5 For the SVM experiments, we used the offthe-shelf LIBLINEAR library (Fan et al., 2008) wrapped by the KyTea toolkit."}, {"id": 70, "string": "6 Table 1 gives the recovery accuracies, demonstrating that recovery is not a difficult classification task, given well represented contextual features."}, {"id": 71, "string": "In general, using up to 5-gram features before/after the simplified grapheme yielded the best results for the baseline, except with Burmese, where 7-gram features brought a small additional improvement."}, {"id": 72, "string": "Because Burmese texts use relatively more spaces than the other three scripts, longer contexts help more."}, {"id": 73, "string": "Meanwhile, Lao produced the worst results, possibly because the omission and merging process was harsh: Lao is the most phonetic of the four scripts, with the least redundant spellings."}, {"id": 74, "string": "The LSTM-based RNN was implemented using DyNet (Neubig et al., 2017) , and it was trained using Adam (Kingma and Ba, 2014) with an initial learning rate of 10 \u22123 ."}, {"id": 75, "string": "If the accuracy decreased on the development set, the learning rate was halved, and learning was terminated when there was no improvement on the development set for three iterations."}, {"id": 76, "string": "We did not use dropout (Srivastava et al., 2014) but instead a voting ensemble over a set of differently initialized models trained in parallel, which is both more effective and faster."}, {"id": 77, "string": "As shown in Table 2 , the RNN outperformed SVM on all scripts in terms of top-1 accuracy."}, {"id": 78, "string": "A more lenient evaluation, i.e., top-n accuracy, showed a satisfactory coverage of around 98% (Khmer and Lao) to 99% (Thai and Burmese) considering only the top four results."}, {"id": 79, "string": "Fig."}, {"id": 80, "string": "5 shows the effect of changing the size of the training dataset by repeatedly halving it until it was one-eighth of its original size, demonstrating that the RNN outperformed SVM regardless of training data size."}, {"id": 81, "string": "The LSTM-based RNN should thus be a substantially better solution than the SVM for this task."}, {"id": 82, "string": "We also investigated Burmese and Khmer further using manual evaluation."}, {"id": 83, "string": "The results of RNN @1 \u229516 in Table 2 were evaluated by native speakers, who examined the output writing units corresponding to each input simplified grapheme and classified the errors using four levels: 0) acceptable, i.e., alternative spelling, 1) clear and easy to identify the correct result, 2) confusing but possible to identify the correct result, and 3) incomprehensible."}, {"id": 84, "string": "Table 3 shows the error distribution."}, {"id": 85, "string": "For Burmese, most of the errors are at levels 1 and 2, and Khmer has a wider distribution."}, {"id": 86, "string": "For both scripts, around 50% of the errors are serious (level 2 or 3), but the distributions suggest that they have different characteristics."}, {"id": 87, "string": "We are currently conducting a case study on these errors for further language-specific improvements."}, {"id": 88, "string": "Conclusion and Future Work In this study, a scheme was used to substantially simplify four abugidas, omitting most diacritics and merging the remaining characters."}, {"id": 89, "string": "An SVM and an LSTM-based RNN were then used to recover the original texts, showing that the simplified abugidas could be recovered well."}, {"id": 90, "string": "This illustrates the feasibility of encoding abugidas less redundantly, which could help with the development of more efficient input methods."}, {"id": 91, "string": "As for the future work, we are planning to include language-specific optimizations in the design of the simplification scheme and to improve"}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 34}, {"section": "Related Work", "n": "2", "start": 35, "end": 43}, {"section": "Simplified Abugidas", "n": "3", "start": 44, "end": 57}, {"section": "Recovery Methods", "n": "4", "start": 58, "end": 66}, {"section": "Experiments and Evaluation", "n": "5", "start": 67, "end": 87}, {"section": "Conclusion and Future Work", "n": "6", "start": 88, "end": 91}], "figures": [{"filename": "../figure/image/1249-Figure4-1.png", "caption": "Figure 4: Structure of the RNN used in this study.", "page": 2, "bbox": {"x1": 312.0, "x2": 519.36, "y1": 65.28, "y2": 167.51999999999998}}, {"filename": "../figure/image/1249-Figure3-1.png", "caption": "Figure 3: Merging and omission for Thai (TH), Burmese (MY), Khmer (KM), and Lao (LO) scripts. The MN row lists the mnemonics assigned to graphemes in our experiment. In this study, the mnemonics can be assigned arbitrarily, and we selected Latin letters related to the real pronunciation wherever possible.", "page": 1, "bbox": {"x1": 72.0, "x2": 525.12, "y1": 61.44, "y2": 192.0}}, {"filename": "../figure/image/1249-Table1-1.png", "caption": "Table 1: Top-1 recovery accuracy for the SVM. Here, \u201cDev\u00b1m\u201d represents the results for the development set when using N -gram (N \u2208 [1,m]) features within m-grapheme windows of the simplified encodings, and \u201cTest\u201d represents the test set results when using the feature set that gave the best development set results. \u201cLeng.\u201d shows the ratio of the number of characters in the simplified encodings compared with the original strings.", "page": 3, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 62.879999999999995, "y2": 151.2}}, {"filename": "../figure/image/1249-Table2-1.png", "caption": "Table 2: Top-n accuracy on the test set for the LSTM-based RNN with an m-model ensemble (RNN@n\u2295m). Here, \u2020 and \u2021 mean the RNN outperformed the SVM with statistical significance at p < 10\u22122 and p < 10\u22123 level, respectively, measured by bootstrap re-sampling.", "page": 3, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 291.84, "y2": 408.0}}, {"filename": "../figure/image/1249-Figure5-1.png", "caption": "Figure 5: Top-1 accuracy on the test set (y-axis) for different training data sizes (x-axis, number of graphemes after simplification, logarithmic).", "page": 3, "bbox": {"x1": 309.59999999999997, "x2": 519.84, "y1": 510.24, "y2": 593.76}}, {"filename": "../figure/image/1249-Table3-1.png", "caption": "Table 3: Recovery error distribution.", "page": 3, "bbox": {"x1": 307.68, "x2": 522.24, "y1": 658.56, "y2": 704.16}}, {"filename": "../figure/image/1249-Figure1-1.png", "caption": "Figure 1: Hierarchy of writing systems.", "page": 0, "bbox": {"x1": 310.08, "x2": 522.24, "y1": 226.07999999999998, "y2": 258.24}}, {"filename": "../figure/image/1249-Figure2-1.png", "caption": "Figure 2: Overview of the approach in this study.", "page": 0, "bbox": {"x1": 308.15999999999997, "x2": 524.16, "y1": 287.52, "y2": 372.0}}]}