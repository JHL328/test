{"title": "A robust self-learning method for fully unsupervised cross-lingual mappings of word embeddings", "abstract": "Recent work has managed to learn crosslingual word embeddings without parallel data by mapping monolingual embeddings to a shared space through adversarial training. However, their evaluation has focused on favorable conditions, using comparable corpora or closely-related languages, and we show that they often fail in more realistic scenarios. This work proposes an alternative approach based on a fully unsupervised initialization that explicitly exploits the structural similarity of the embeddings, and a robust self-learning algorithm that iteratively improves this solution. Our method succeeds in all tested scenarios and obtains the best published results in standard datasets, even surpassing previous supervised systems. Our implementation is released as an open source project at https://github. com/artetxem/vecmap.", "text": [{"id": 0, "string": "Introduction Cross-lingual embedding mappings have shown to be an effective way to learn bilingual word embeddings (Mikolov et al., 2013; ."}, {"id": 1, "string": "The underlying idea is to independently train the embeddings in different languages using monolingual corpora, and then map them to a shared space through a linear transformation."}, {"id": 2, "string": "This allows to learn high-quality cross-lingual representations without expensive supervision, opening new research avenues like unsupervised neural machine translation (Artetxe et al., 2018b; ."}, {"id": 3, "string": "While most embedding mapping methods rely on a small seed dictionary, adversarial training has recently produced exciting results in fully unsu-pervised settings (Zhang et al., 2017a,b; ."}, {"id": 4, "string": "However, their evaluation has focused on particularly favorable conditions, limited to closely-related languages or comparable Wikipedia corpora."}, {"id": 5, "string": "When tested on more realistic scenarios, we find that they often fail to produce meaningful results."}, {"id": 6, "string": "For instance, none of the existing methods works in the standard English-Finnish dataset from Artetxe et al."}, {"id": 7, "string": "(2017) , obtaining translation accuracies below 2% in all cases (see Section 5)."}, {"id": 8, "string": "On another strand of work, Artetxe et al."}, {"id": 9, "string": "(2017) showed that an iterative self-learning method is able to bootstrap a high quality mapping from very small seed dictionaries (as little as 25 pairs of words)."}, {"id": 10, "string": "However, their analysis reveals that the self-learning method gets stuck in poor local optima when the initial solution is not good enough, thus failing for smaller training dictionaries."}, {"id": 11, "string": "In this paper, we follow this second approach and propose a new unsupervised method to build an initial solution without the need of a seed dictionary, based on the observation that, given the similarity matrix of all words in the vocabulary, each word has a different distribution of similarity values."}, {"id": 12, "string": "Two equivalent words in different languages should have a similar distribution, and we can use this fact to induce the initial set of word pairings (see Figure 1 )."}, {"id": 13, "string": "We combine this initialization with a more robust self-learning method, which is able to start from the weak initial solution and iteratively improve the mapping."}, {"id": 14, "string": "Coupled together, we provide a fully unsupervised crosslingual mapping method that is effective in realistic settings, converges to a good solution in all cases tested, and sets a new state-of-the-art in bilingual lexicon extraction, even surpassing previous supervised methods."}, {"id": 15, "string": "Figure 1 : Motivating example for our unsupervised initialization method, showing the similarity distributions of three words (corresponding to the smoothed density estimates from the normalized square root of the similarity matrices as defined in Section 3.2)."}, {"id": 16, "string": "Equivalent translations (two and due) have more similar distributions than non-related words (two and cane -meaning dog)."}, {"id": 17, "string": "This observation is used to build an initial solution that is later improved through self-learning."}, {"id": 18, "string": "Related work Cross-lingual embedding mapping methods work by independently training word embeddings in two languages, and then mapping them to a shared space using a linear transformation."}, {"id": 19, "string": "Most of these methods are supervised, and use a bilingual dictionary of a few thousand entries to learn the mapping."}, {"id": 20, "string": "Existing approaches can be classified into regression methods, which map the embeddings in one language using a leastsquares objective (Mikolov et al., 2013; Shigeto et al., 2015; , canonical methods, which map the embeddings in both languages to a shared space using canonical correlation analysis and extensions of it (Faruqui and Dyer, 2014; Lu et al., 2015) , orthogonal methods, which map the embeddings in one or both languages under the constraint of the transformation being orthogonal (Xing et al., 2015; Artetxe et al., 2016; Zhang et al., 2016; Smith et al., 2017) , and margin methods, which map the embeddings in one language to maximize the margin between the correct translations and the rest of the candidates ."}, {"id": 21, "string": "Artetxe et al."}, {"id": 22, "string": "(2018a) showed that many of them could be generalized as part of a multi-step framework of linear transformations."}, {"id": 23, "string": "A related research line is to adapt these methods to the semi-supervised scenario, where the training dictionary is much smaller and used as part of a bootstrapping process."}, {"id": 24, "string": "While similar ideas where already explored for traditional count-based vector space models (Peirsman and Pad\u00f3, 2010; Vuli\u0107 and Moens, 2013) , Artetxe et al."}, {"id": 25, "string": "(2017) brought this approach to pre-trained low-dimensional word embeddings, which are more widely used nowadays."}, {"id": 26, "string": "More concretely, they proposed a selflearning approach that alternates the mapping and dictionary induction steps iteratively, obtaining results that are comparable to those of supervised methods when starting with only 25 word pairs."}, {"id": 27, "string": "A practical approach for reducing the need of bilingual supervision is to design heuristics to build the seed dictionary."}, {"id": 28, "string": "The role of the seed lexicon in learning cross-lingual embedding mappings is analyzed in depth by Vuli\u0107 and Korhonen (2016) , who propose using document-aligned corpora to extract the training dictionary."}, {"id": 29, "string": "A more common approach is to rely on shared words and cognates (Peirsman and Pad\u00f3, 2010; Smith et al., 2017) , while Artetxe et al."}, {"id": 30, "string": "(2017) go further and restrict themselves to shared numerals."}, {"id": 31, "string": "However, while these approaches are meant to eliminate the need of bilingual data in practice, they also make strong assumptions on the writing systems of languages (e.g."}, {"id": 32, "string": "that they all use a common alphabet or Arabic numerals)."}, {"id": 33, "string": "Closer to our work, a recent line of fully unsupervised approaches drops these assumptions completely, and attempts to learn cross-lingual embedding mappings based on distributional information alone."}, {"id": 34, "string": "For that purpose, existing methods rely on adversarial training."}, {"id": 35, "string": "This was first proposed by Miceli Barone (2016), who combine an encoder that maps source language embeddings into the target language, a decoder that reconstructs the source language embeddings from the mapped embeddings, and a discriminator that discriminates between the mapped embeddings and the true target language embed-dings."}, {"id": 36, "string": "Despite promising, they conclude that their model \"is not competitive with other cross-lingual representation approaches\"."}, {"id": 37, "string": "Zhang et al."}, {"id": 38, "string": "(2017a) use a very similar architecture, but incorporate additional techniques like noise injection to aid training and report competitive results on bilingual lexicon extraction."}, {"id": 39, "string": "drop the reconstruction component, regularize the mapping to be orthogonal, and incorporate an iterative refinement process akin to self-learning, reporting very strong results on a large bilingual lexicon extraction dataset."}, {"id": 40, "string": "Finally, Zhang et al."}, {"id": 41, "string": "(2017b) adopt the earth mover's distance for training, optimized through a Wasserstein generative adversarial network followed by an alternating optimization procedure."}, {"id": 42, "string": "However, all this previous work used comparable Wikipedia corpora in most experiments and, as shown in Section 5, face difficulties in more challenging settings."}, {"id": 43, "string": "Proposed method Let X and Z be the word embedding matrices in two languages, so that their ith row X i * and Z i * denote the embeddings of the ith word in their respective vocabularies."}, {"id": 44, "string": "Our goal is to learn the linear transformation matrices W X and W Z so the mapped embeddings XW X and ZW Z are in the same cross-lingual space."}, {"id": 45, "string": "At the same time, we aim to build a dictionary between both languages, encoded as a sparse matrix D where D ij = 1 if the jth word in the target language is a translation of the ith word in the source language."}, {"id": 46, "string": "Our proposed method consists of four sequential steps: a pre-processing that normalizes the embeddings ( \u00a73.1), a fully unsupervised initialization scheme that creates an initial solution ( \u00a73.2), a robust self-learning procedure that iteratively improves this solution ( \u00a73.3), and a final refinement step that further improves the resulting mapping through symmetric re-weighting ( \u00a73.4)."}, {"id": 47, "string": "Embedding normalization Our method starts with a pre-processing that length normalizes the embeddings, then mean centers each dimension, and then length normalizes them again."}, {"id": 48, "string": "The first two steps have been shown to be beneficial in previous work (Artetxe et al., 2016) , while the second length normalization guarantees the final embeddings to have a unit length."}, {"id": 49, "string": "As a result, the dot product of any two embeddings is equivalent to their cosine similarity and directly related to their Euclidean distance 1 , and can be taken as a measure of their similarity."}, {"id": 50, "string": "Fully unsupervised initialization The underlying difficulty of the mapping problem in its unsupervised variant is that the word embedding matrices X and Z are unaligned across both axes: neither the ith vocabulary item X i * and Z i * nor the jth dimension of the embeddings X * j and Z * j are aligned, so there is no direct correspondence between both languages."}, {"id": 51, "string": "In order to overcome this challenge and build an initial solution, we propose to first construct two alternative representations X \u2032 and Z \u2032 that are aligned across their jth dimension X \u2032 * j and Z \u2032 * j , which can later be used to build an initial dictionary that aligns their respective vocabularies."}, {"id": 52, "string": "Our approach is based on a simple idea: while the axes of the original embeddings X and Z are different in nature, both axes of their corresponding similarity matrices M X = XX T and M Z = ZZ T correspond to words, which can be exploited to reduce the mismatch to a single axis."}, {"id": 53, "string": "More concretely, assuming that the embedding spaces are perfectly isometric, the similarity matrices M X and M Z would be equivalent up to a permutation of their rows and columns, where the permutation in question defines the dictionary across both languages."}, {"id": 54, "string": "In practice, the isometry requirement will not hold exactly, but it can be assumed to hold approximately, as the very same problem of mapping two embedding spaces without supervision would otherwise be hopeless."}, {"id": 55, "string": "Based on that, one could try every possible permutation of row and column indices to find the best match between M X and M Z , but the resulting combinatorial explosion makes this approach intractable."}, {"id": 56, "string": "In order to overcome this problem, we propose to first sort the values in each row of M X and M Z , resulting in matrices sorted(M X ) and sorted(M Z ) 2 ."}, {"id": 57, "string": "Under the strict isometry condition, equivalent words would get the exact same vector across languages, and thus, given a word and its row in sorted(M X ), one could apply nearest neighbor retrieval over the rows of sorted(M Z ) to find its corresponding translation."}, {"id": 58, "string": "On a final note, given the singular value decomposition X = U SV T , the similarity matrix is M X = U S 2 U T ."}, {"id": 59, "string": "As such, its square root \u221a M X = U SU T is closer in nature to the original embeddings, and we also find it to work better in practice."}, {"id": 60, "string": "We thus compute sorted( \u221a M X ) and sorted( \u221a M Z ) and normalize them as described in Section 3.1, yielding the two matrices X \u2032 and Z \u2032 that are later used to build the initial solution for self-learning (see Section 3.3)."}, {"id": 61, "string": "In practice, the isometry assumption is strong enough so the above procedure captures some cross-lingual signal."}, {"id": 62, "string": "In our English-Italian experiments, the average cosine similarity across the gold standard translation pairs is 0.009 for a random solution, 0.582 for the optimal supervised solution, and 0.112 for the mapping resulting from this initialization."}, {"id": 63, "string": "While the latter is far from being useful on its own (the accuracy of the resulting dictionary is only 0.52%), it is substantially better than chance, and it works well as an initial solution for the self-learning method described next."}, {"id": 64, "string": "Robust self-learning Previous work has shown that self-learning can learn high-quality bilingual embedding mappings starting with as little as 25 word pairs (Artetxe et al., 2017) ."}, {"id": 65, "string": "In this method, training iterates through the following two steps until convergence: 1."}, {"id": 66, "string": "Compute the optimal orthogonal mapping maximizing the similarities for the current dictionary D: arg max W X ,W Z i j D ij ((X i * W X ) \u00b7 (Z j * W Z )) An optimal solution is given by W X = U and W Z = V , where U SV T = X T DZ is the singular value decomposition of X T DZ."}, {"id": 67, "string": "2."}, {"id": 68, "string": "Compute the optimal dictionary over the similarity matrix of the mapped embeddings XW X W T Z Z T ."}, {"id": 69, "string": "This typically uses nearest neighbor retrieval from the source language into the target language, so D ij = 1 if j = argmax k (X i * W X ) \u00b7 (Z k * W Z ) and D ij = 0 otherwise."}, {"id": 70, "string": "The underlying optimization objective is independent from the initial dictionary, and the algorithm is guaranteed to converge to a local optimum of it."}, {"id": 71, "string": "However, the method does not work if starting from a completely random solution, as it tends to get stuck in poor local optima in that case."}, {"id": 72, "string": "For that reason, we use the unsupervised initialization procedure at Section 3.2 to build an initial solution."}, {"id": 73, "string": "However, simply plugging in both methods did not work in our preliminary experiments, as the quality of this initial method is not good enough to avoid poor local optima."}, {"id": 74, "string": "For that reason, we next propose some key improvements in the dictionary induction step to make self-learning more robust and learn better mappings: \u2022 Stochastic dictionary induction."}, {"id": 75, "string": "In order to encourage a wider exploration of the search space, we make the dictionary induction stochastic by randomly keeping some elements in the similarity matrix with probability p and setting the remaining ones to 0."}, {"id": 76, "string": "As a consequence, the smaller the value of p is, the more the induced dictionary will vary from iteration to iteration, thus enabling to escape poor local optima."}, {"id": 77, "string": "So as to find a fine-grained solution once the algorithm gets into a good region, we increase this value during training akin to simulated annealing, starting with p = 0.1 and doubling this value every time the objective function at step 1 above does not improve more than \u01eb = 10 \u22126 for 50 iterations."}, {"id": 78, "string": "\u2022 Frequency-based vocabulary cutoff."}, {"id": 79, "string": "The size of the similarity matrix grows quadratically with respect to that of the vocabularies."}, {"id": 80, "string": "This does not only increase the cost of computing it, but it also makes the number of possible solutions grow exponentially 3 , presumably making the optimization problem harder."}, {"id": 81, "string": "Given that less frequent words can be expected to be noisier, we propose to restrict the dictionary induction process to the k most frequent words in each language, where we find k = 20, 000 to work well in practice."}, {"id": 82, "string": "\u2022 CSLS retrieval."}, {"id": 83, "string": "showed that nearest neighbor suffers from the hubness problem."}, {"id": 84, "string": "This phenomenon is known to occur as an effect of the curse of dimensionality, and causes a few points (known as hubs) to be nearest neighbors of many other points (Radovanovi\u0107 et al., 2010a,b) ."}, {"id": 85, "string": "Among the existing solutions to penalize the similarity score of hubs, we adopt the Cross-domain Similarity Local Scaling (CSLS) from ."}, {"id": 86, "string": "Given two mapped embeddings x and y, the idea of CSLS is to compute r T (x) and r S (y), the average cosine similarity of x and y for their k nearest neighbors in the other language, respectively."}, {"id": 87, "string": "Having done that, the corrected score CSLS(x, y) = 2 cos(x, y) \u2212 r T (x) \u2212 r S (y)."}, {"id": 88, "string": "Following the authors, we set k = 10."}, {"id": 89, "string": "\u2022 Bidirectional dictionary induction."}, {"id": 90, "string": "When the dictionary is induced from the source into the target language, not all target language words will be present in it, and some will occur multiple times."}, {"id": 91, "string": "We argue that this might accentuate the problem of local optima, as repeated words might act as strong attractors from which it is difficult to escape."}, {"id": 92, "string": "In order to mitigate this issue and encourage diversity, we propose inducing the dictionary in both directions and taking their corresponding concatenation, so D = D X\u2192Z + D Z\u2192X ."}, {"id": 93, "string": "In order to build the initial dictionary, we compute X \u2032 and Z \u2032 as detailed in Section 3.2 and apply the above procedure over them."}, {"id": 94, "string": "As the only difference, this first solution does not use the stochastic zeroing in the similarity matrix, as there is no need to encourage diversity (X \u2032 and Z \u2032 are only used once), and the threshold for vocabulary cutoff is set to k = 4, 000, so X \u2032 and Z \u2032 can fit in memory."}, {"id": 95, "string": "Having computed the initial dictionary, X \u2032 and Z \u2032 are discarded, and the remaining iterations are performed over the original embeddings X and Z. Symmetric re-weighting As part of their multi-step framework, Artetxe et al."}, {"id": 96, "string": "(2018a) showed that re-weighting the target language embeddings according to the crosscorrelation in each component greatly improved the quality of the induced dictionary."}, {"id": 97, "string": "Given the singular value decomposition U SV T = X T DZ, this is equivalent to taking W X = U and W Z = V S, where X and Z are previously whitened applying the linear transformations (X T X) \u2212 1 2 and (Z T Z) \u2212 1 2 , and later de-whitened applying U T (X T X) 1 2 U and V T (Z T Z) 1 2 V ."}, {"id": 98, "string": "However, re-weighting also accentuates the problem of local optima when incorporated into self-learning as, by increasing the relevance of dimensions that best match for the current solution, it discourages to explore other regions of the search space."}, {"id": 99, "string": "For that reason, we propose using it as a final step once self-learning has converged to a good solution."}, {"id": 100, "string": "Unlike Artetxe et al."}, {"id": 101, "string": "(2018a) , we apply re-weighting symmetrically in both languages, taking W X = U S 1 2 and W Z = V S 1 2 ."}, {"id": 102, "string": "This approach is neutral in the direction of the mapping, and gives good results as shown in our experiments."}, {"id": 103, "string": "Experimental settings Following common practice, we evaluate our method on bilingual lexicon extraction, which measures the accuracy of the induced dictionary in comparison to a gold standard."}, {"id": 104, "string": "As discussed before, previous evaluation has focused on favorable conditions."}, {"id": 105, "string": "In particular, existing unsupervised methods have almost exclusively been tested on Wikipedia corpora, which is comparable rather than monolingual, exposing a strong cross-lingual signal that is not available in strictly unsupervised settings."}, {"id": 106, "string": "In addition to that, some datasets comprise unusually small embeddings, with only 50 dimensions and around 5,000-10,000 vocabulary items (Zhang et al., 2017a,b) ."}, {"id": 107, "string": "As the only exception,  report positive results on the English-Italian dataset of  in addition to their main experiments, which are carried out in Wikipedia."}, {"id": 108, "string": "While this dataset does use strictly monolingual corpora, it still corresponds to a pair of two relatively close indo-european languages."}, {"id": 109, "string": "In order to get a wider picture of how our method compares to previous work in different conditions, including more challenging settings, we carry out our experiments in the widely used dataset of  and the subsequent extensions of Artetxe et al."}, {"id": 110, "string": "(2017 Artetxe et al."}, {"id": 111, "string": "( , 2018a , which together comprise English-Italian, English-German, English-Finnish and English-Spanish."}, {"id": 112, "string": "More concretely, the dataset consists of 300-dimensional CBOW embeddings trained on WacKy crawling corpora (English, Italian, German), Common Crawl (Finnish) and WMT News Crawl (Spanish)."}, {"id": 113, "string": "The gold standards were derived from dictionaries built from Europarl word alignments and available at OPUS (Tiedemann, 2012) , split in a test set of 1,500 entries and a training set of 5,000 that we do not use in our experiments."}, {"id": 114, "string": "The datasets are freely available."}, {"id": 115, "string": "As a non-european agglutinative language, the English-Finnish pair is particularly challeng- Zhang et al."}, {"id": 116, "string": "(2017a) ."}, {"id": 117, "string": "We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with >5% accuracy) and the average runtime (minutes)."}, {"id": 118, "string": "EN-IT EN-DE EN-FI EN-ES best avg s t best avg s t best avg s t best avg s t Proposed method 48.53 48.13 10 8.9 48.47 48.19 10 7.3 33.50 32.63 10 12.9 37.60 37.33 10 9.1 Table 2 : Results of unsupervised methods on the dataset of  and the extensions of Artetxe et al."}, {"id": 119, "string": "(2017 Artetxe et al."}, {"id": 120, "string": "( , 2018a ."}, {"id": 121, "string": "We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with >5% accuracy) and the average runtime (minutes)."}, {"id": 122, "string": "ing due to the linguistic distance between them."}, {"id": 123, "string": "For completeness, we also test our method in the Spanish-English, Italian-English and Turkish-English datasets of Zhang et al."}, {"id": 124, "string": "(2017a) , which consist of 50-dimensional CBOW embeddings trained on Wikipedia, as well as gold standard dictionaries 4 from Open Multilingual WordNet (Spanish-English and Italian-English) and Google Translate (Turkish-English)."}, {"id": 125, "string": "The lower dimensionality and comparable corpora make an easier scenario, although it also contains a challenging pair of distant languages (Turkish-English)."}, {"id": 126, "string": "Our method is implemented in Python using NumPy and CuPy."}, {"id": 127, "string": "Together with it, we also test the methods of Zhang et al."}, {"id": 128, "string": "(2017a) and  using the publicly available implementations from the authors 5 ."}, {"id": 129, "string": "Given that Zhang et al."}, {"id": 130, "string": "(2017a) report using a different value of their hyperparameter \u03bb for different language pairs (\u03bb = 10 for English-Turkish and \u03bb = 1 for the rest), we test both values in all our experiments to 4 The test dictionaries were obtained through personal communication with the authors."}, {"id": 131, "string": "The rest of the language pairs were left out due to licensing issues."}, {"id": 132, "string": "5 Despite our efforts, Zhang et al."}, {"id": 133, "string": "(2017b) was left out because: 1) it does not create a one-to-one dictionary, thus difficulting direct comparison, 2) it depends on expensive proprietary software 3) its computational cost is orders of magnitude higher (running the experiments would have taken several months)."}, {"id": 134, "string": "better understand its effect."}, {"id": 135, "string": "In the case of , we test both the default hyperparameters in the source code as well as those reported in the paper, with iterative refinement activated in both cases."}, {"id": 136, "string": "Given the instability of these methods, we perform 10 runs for each, and report the best and average accuracies, the number of successful runs (those with >5% accuracy) and the average runtime."}, {"id": 137, "string": "All the experiments were run in a single Nvidia Titan Xp."}, {"id": 138, "string": "Results and discussion We first present the main results ( \u00a75.1), then the comparison to the state-of-the-art ( \u00a75.2), and finally ablation tests to measure the contribution of each component ( \u00a75.3)."}, {"id": 139, "string": "Main results We report the results in the dataset of Zhang et al."}, {"id": 140, "string": "(2017a) at Table 1 ."}, {"id": 141, "string": "As it can be seen, the proposed method performs at par with that of  both in Spanish-English and Italian-English, but gets substantially better results in the more challenging Turkish-English pair."}, {"id": 142, "string": "While we are able to reproduce the results reported by Zhang et al."}, {"id": 143, "string": "(2017a) , their method gets the worst results of all by a large margin."}, {"id": 144, "string": "Another disadvantage of that model is that different et al."}, {"id": 145, "string": "(2018a) ."}, {"id": 146, "string": "The remaining results were reported in the original papers."}, {"id": 147, "string": "For methods that do not require supervision, we report the average accuracy across 10 runs."}, {"id": 148, "string": "\u2021 For meaningful comparison, runs with <5% accuracy are excluded when computing the average, but note that, unlike ours, their method often gives a degenerated solution (see Table 2 )."}, {"id": 149, "string": "language pairs require different hyperparameters: \u03bb = 1 works substantially better for Spanish-English and Italian-English, but only \u03bb = 10 works for Turkish-English."}, {"id": 150, "string": "The results for the more challenging dataset from  and the extensions of Artetxe et al."}, {"id": 151, "string": "(2017 Artetxe et al."}, {"id": 152, "string": "( , 2018a are given in Table  2 ."}, {"id": 153, "string": "In this case, our proposed method obtains the best results in all metrics for all the four language pairs tested."}, {"id": 154, "string": "The method of Zhang et al."}, {"id": 155, "string": "(2017a) does not work at all in this more challenging scenario, which is in line with the negative results reported by the authors themselves for similar conditions (only %2.53 accuracy in their large Gigaword dataset)."}, {"id": 156, "string": "The method of  also fails for English-Finnish (only 1.62% in the best run), although it is able to get positive results in some runs for the rest of language pairs."}, {"id": 157, "string": "Between the two configurations tested, the default hyperparameters in the code show a more stable behavior."}, {"id": 158, "string": "These results confirm the robustness of the proposed method."}, {"id": 159, "string": "While the other systems succeed in some runs and fail in others, our method converges to a good solution in all runs without excep-tion and, in fact, it is the only one getting positive results for English-Finnish."}, {"id": 160, "string": "In addition to being more robust, our method also obtains substantially better accuracies, surpassing previous methods by at least 1-3 points in all but the easiest pairs."}, {"id": 161, "string": "Moreover, our method is not sensitive to hyperparameters that are difficult to tune without a development set, which is critical in realistic unsupervised conditions."}, {"id": 162, "string": "At the same time, our method is significantly faster than the rest."}, {"id": 163, "string": "In relation to that, it is interesting that, while previous methods perform a fixed number of iterations and take practically the same time for all the different language pairs, the runtime of our method adapts to the difficulty of the task thanks to the dynamic convergence criterion of our stochastic approach."}, {"id": 164, "string": "This way, our method tends to take longer for more challenging language pairs (1.7 vs 0.6 minutes for es-en and tr-en in one dataset, and 12.9 vs 7.3 minutes for en-fi and en-de in the other) and, in fact, our (relative) execution times correlate surprisingly well with the linguistic distance with English (closest/fastest is German, followed by Italian/Spanish, followed by Turkish/Finnish)."}, {"id": 165, "string": "Table 4 : Ablation test on the dataset of  and the extensions of Artetxe et al."}, {"id": 166, "string": "(2017 Artetxe et al."}, {"id": 167, "string": "( , 2018a ."}, {"id": 168, "string": "We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with >5% accuracy) and the average runtime (minutes)."}, {"id": 169, "string": "Table 3 shows the results of the proposed method in comparison to previous systems, including those with different degrees of supervision."}, {"id": 170, "string": "We focus on the widely used English-Italian dataset of  and its extensions."}, {"id": 171, "string": "Despite being fully unsupervised, our method achieves the best results in all language pairs but one, even surpassing previous supervised approaches."}, {"id": 172, "string": "The only exception is English-Finnish, where Artetxe et al."}, {"id": 173, "string": "Comparison with the state-of-the-art (2018a) gets marginally better results with a difference of 0.3 points, yet ours is the only unsupervised system that works for this pair."}, {"id": 174, "string": "At the same time, it is remarkable that the proposed system gets substantially better results than Artetxe et al."}, {"id": 175, "string": "(2017) , the only other system based on selflearning, with the additional advantage of being fully unsupervised."}, {"id": 176, "string": "Ablation test In order to better understand the role of different aspects in the proposed system, we perform an ablation test, where we separately analyze the effect of initialization, the different components of our robust self-learning algorithm, and the final symmetric re-weighting."}, {"id": 177, "string": "The obtained results are reported in Table 4 ."}, {"id": 178, "string": "In concordance with previous work, our results show that self-learning does not work with random initialization."}, {"id": 179, "string": "However, the proposed unsupervised initialization is able to overcome this issue without the need of any additional information, performing at par with other character-level heuristics that we tested (e.g."}, {"id": 180, "string": "shared numerals)."}, {"id": 181, "string": "As for the different self-learning components, we observe that the stochastic dictionary induction is necessary to overcome the problem of poor lo-cal optima for English-Finnish, although it does not make any difference for the rest of easier language pairs."}, {"id": 182, "string": "The frequency-based vocabulary cutoff also has a positive effect, yielding to slightly better accuracies and much faster runtimes."}, {"id": 183, "string": "At the same time, CSLS plays a critical role in the system, as hubness severely accentuates the problem of local optima in its absence."}, {"id": 184, "string": "The bidirectional dictionary induction is also beneficial, contributing to the robustness of the system as shown by English-Finnish and yielding to better accuracies in all cases."}, {"id": 185, "string": "Finally, these results also show that symmetric re-weighting contributes positively, bringing an improvement of around 1-2 points without any cost in the execution time."}, {"id": 186, "string": "Conclusions In this paper, we show that previous unsupervised mapping methods (Zhang et al., 2017a; often fail on realistic scenarios involving non-comparable corpora and/or distant languages."}, {"id": 187, "string": "In contrast to adversarial methods, we propose to use an initial weak mapping that exploits the structure of the embedding spaces in combination with a robust self-learning approach."}, {"id": 188, "string": "The results show that our method succeeds in all cases, providing the best results with respect to all previous work on unsupervised and supervised mappings."}, {"id": 189, "string": "The ablation analysis shows that our initial solution is instrumental for making self-learning work without supervision."}, {"id": 190, "string": "In order to make selflearning robust, we also added stochasticity to dictionary induction, used CSLS instead of nearest neighbor, and produced bidirectional dictionaries."}, {"id": 191, "string": "Results also improved using smaller in-termediate vocabularies and re-weighting the final solution."}, {"id": 192, "string": "Our implementation is available as an open source project at https://github."}, {"id": 193, "string": "com/artetxem/vecmap."}, {"id": 194, "string": "In the future, we would like to extend the method from the bilingual to the multilingual scenario, and go beyond the word level by incorporating embeddings of longer phrases."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 17}, {"section": "Related work", "n": "2", "start": 18, "end": 42}, {"section": "Proposed method", "n": "3", "start": 43, "end": 46}, {"section": "Embedding normalization", "n": "3.1", "start": 47, "end": 49}, {"section": "Fully unsupervised initialization", "n": "3.2", "start": 50, "end": 63}, {"section": "Robust self-learning", "n": "3.3", "start": 64, "end": 94}, {"section": "Symmetric re-weighting", "n": "3.4", "start": 95, "end": 102}, {"section": "Experimental settings", "n": "4", "start": 103, "end": 137}, {"section": "Results and discussion", "n": "5", "start": 138, "end": 138}, {"section": "Main results", "n": "5.1", "start": 139, "end": 172}, {"section": "Comparison with the state-of-the-art", "n": "5.2", "start": 173, "end": 175}, {"section": "Ablation test", "n": "5.3", "start": 176, "end": 185}, {"section": "Conclusions", "n": "6", "start": 186, "end": 194}], "figures": [{"filename": "../figure/image/1025-Table1-1.png", "caption": "Table 1: Results of unsupervised methods on the dataset of Zhang et al. (2017a). We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with >5% accuracy) and the average runtime (minutes).", "page": 5, "bbox": {"x1": 118.56, "x2": 479.03999999999996, "y1": 62.4, "y2": 150.23999999999998}}, {"filename": "../figure/image/1025-Table2-1.png", "caption": "Table 2: Results of unsupervised methods on the dataset of Dinu et al. (2015) and the extensions of Artetxe et al. (2017, 2018a). We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with>5% accuracy) and the average runtime (minutes).", "page": 5, "bbox": {"x1": 75.84, "x2": 521.28, "y1": 214.56, "y2": 301.92}}, {"filename": "../figure/image/1025-Table4-1.png", "caption": "Table 4: Ablation test on the dataset of Dinu et al. (2015) and the extensions of Artetxe et al. (2017, 2018a). We perform 10 runs for each method and report the best and average accuracies (%), the number of successful runs (those with >5% accuracy) and the average runtime (minutes).", "page": 7, "bbox": {"x1": 86.88, "x2": 510.24, "y1": 67.2, "y2": 186.23999999999998}}, {"filename": "../figure/image/1025-Figure1-1.png", "caption": "Figure 1: Motivating example for our unsupervised initialization method, showing the similarity distributions of three words (corresponding to the smoothed density estimates from the normalized square root of the similarity matrices as defined in Section 3.2). Equivalent translations (two and due) have more similar distributions than non-related words (two and cane - meaning dog). This observation is used to build an initial solution that is later improved through self-learning.", "page": 1, "bbox": {"x1": 98.39999999999999, "x2": 499.2, "y1": 65.75999999999999, "y2": 192.95999999999998}}, {"filename": "../figure/image/1025-Table3-1.png", "caption": "Table 3: Accuracy (%) of the proposed method in comparison with previous work. *Results obtained with the official implementation from the authors. \u2020Results obtained with the framework from Artetxe et al. (2018a). The remaining results were reported in the original papers. For methods that do not require supervision, we report the average accuracy across 10 runs. \u2021For meaningful comparison, runs with <5% accuracy are excluded when computing the average, but note that, unlike ours, their method often gives a degenerated solution (see Table 2).", "page": 6, "bbox": {"x1": 134.88, "x2": 463.2, "y1": 62.4, "y2": 301.92}}]}