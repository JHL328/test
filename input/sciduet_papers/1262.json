{"title": "Time Expression Analysis and Recognition Using Syntactic Token Types and General Heuristic Rules", "abstract": "Extracting time expressions from free text is a fundamental task for many applications. We analyze time expressions from four different datasets and find that only a small group of words are used to express time information and that the words in time expressions demonstrate similar syntactic behaviour. Based on the findings, we propose a type-based approach named SynTime 1 for time expression recognition. Specifically, we define three main syntactic token types, namely time token, modifier, and numeral, to group time-related token regular expressions. On the types we design general heuristic rules to recognize time expressions. In recognition, SynTime first identifies time tokens from raw text, then searches their surroundings for modifiers and numerals to form time segments, and finally merges the time segments to time expressions. As a lightweight rule-based tagger, SynTime runs in real time, and can be easily expanded by simply adding keywords for the text from different domains and different text types. Experiments on benchmark datasets and tweets data show that SynTime outperforms state-of-the-art methods.", "text": [{"id": 0, "string": "Introduction Time expression plays an important role in information retrieval and many applications in natural language processing (Alonso et al., 2011; Campos et al., 2014) ."}, {"id": 1, "string": "Recognizing time expressions from free text has attracted considerable attention since last decade (Verhagen et al., 2007 (Verhagen et al., , 2010 UzZaman et al., 2013) ."}, {"id": 2, "string": "1 Source: https://github.com/zhongxiaoshi/syntime We analyze time expressions in four datasets: TimeBank (Pustejovsky et al., 2003b) , Gigaword (Parker et al., 2011) , WikiWars (Mazur and Dale, 2010) , and Tweets."}, {"id": 3, "string": "From the analysis we make four findings about time expressions."}, {"id": 4, "string": "First, most time expressions are very short, with 80% of time expressions containing no more than three tokens."}, {"id": 5, "string": "Second, at least 91.8% of time expressions contain at least one time token."}, {"id": 6, "string": "Third, the vocabulary used to express time information is very small, with a small group of keywords."}, {"id": 7, "string": "Finally, words in time expressions demonstrate similar syntactic behaviour."}, {"id": 8, "string": "All the findings relate to the principle of least effort (Zipf, 1949) ."}, {"id": 9, "string": "That is, people tend to act under the least effort in order to minimize the cost of energy at both individual level and collective level to language usage (Zipf, 1949) ."}, {"id": 10, "string": "Time expression is part of language and acts as an interface of communication."}, {"id": 11, "string": "Short expressions, occurrence, small vocabulary, and similar syntactic behaviour all reduce the cost of energy required to communicate."}, {"id": 12, "string": "According to the findings we propose a typebased approach named SynTime ('Syn' stands for syntactic) to recognize time expressions."}, {"id": 13, "string": "Specifically, we define three main token types, namely time token, modifier, and numeral, to group timerelated token regular expressions."}, {"id": 14, "string": "Time tokens are the words that explicitly express time information, such as time units (e.g., 'year')."}, {"id": 15, "string": "Modifiers modify time tokens; they appear before or after time tokens, e.g., 'several' and 'ago' in 'several years ago.'"}, {"id": 16, "string": "Numerals are ordinals and numbers."}, {"id": 17, "string": "From free text SynTime first identifies time tokens, then recognizes modifiers and numerals."}, {"id": 18, "string": "Naturally, SynTime is a rule-based tagger."}, {"id": 19, "string": "The key difference between SynTime and other rulebased taggers lies in the way of defining token types and the way of designing rules."}, {"id": 20, "string": "The definition of token type in SynTime is inspired by part-of-speech in which \"linguists group some words of language into classes (sets) which show similar syntactic behaviour.\""}, {"id": 21, "string": "(Manning and Schutze, 1999) SynTime defines token types for tokens according to their syntactic behaviour."}, {"id": 22, "string": "Other rulebased taggers define types for tokens based on their semantic meaning."}, {"id": 23, "string": "For example, SUTime defines 5 semantic modifier types, such as frequency modifiers; 2 while SynTime defines 5 syntactic modifier types, such as modifiers that appear before time tokens."}, {"id": 24, "string": "(See Section 4.1 for details.)"}, {"id": 25, "string": "Accordingly, other rule-based taggers design deterministic rules based on their meanings of tokens themselves."}, {"id": 26, "string": "SynTime instead designs general rules on the token types rather than on the tokens themselves."}, {"id": 27, "string": "For example, our general rules do not work on tokens 'February' nor '1989' but on their token types 'MONTH' and 'YEAR.'"}, {"id": 28, "string": "That is why we call SynTime a type-based approach."}, {"id": 29, "string": "More importantly, other rule-based taggers design rules in a fixed method, including fixed length and fixed position."}, {"id": 30, "string": "In contrast, SynTime designs general rules in a heuristic way, based on the idea of boundary expansion."}, {"id": 31, "string": "The general heuristic rules are quite light-weight that it makes SynTime much more flexible and expansible, and leads SynTime to run in real time."}, {"id": 32, "string": "The heuristic rules are designed on token types and are independent of specific tokens, SynTime therefore is independent of specific domains, specific text types, and even specific languages that consist of specific tokens."}, {"id": 33, "string": "In this paper, we test SynTime on specific domains and specific text types in English."}, {"id": 34, "string": "(The test for other languages needs only to construct a collection of token regular expressions in the target language under our defined token types.)"}, {"id": 35, "string": "Specifically, we evaluate SynTime against three state-of-the-art methods (i.e., HeidelTime, SUTime, and UWTime) on three datasets: TimeBank, WikiWars, and Tweets."}, {"id": 36, "string": "3 datasets."}, {"id": 37, "string": "More importantly, SynTime achieves the best recalls on all three datasets and exceptionally good results on Tweets dataset."}, {"id": 38, "string": "To sum up, we make the following contributions."}, {"id": 39, "string": "\u2022 We analyze time expressions from four datasets and make four findings."}, {"id": 40, "string": "The findings provide evidence in terms of time expression for the principle of least effort (Zipf, 1949) ."}, {"id": 41, "string": "\u2022 We propose a time tagger named SynTime to recognize time expressions using syntactic token types and general heuristic rules."}, {"id": 42, "string": "Syn-Time is independent of specific tokens, and therefore independent of specific domains, specific text types, and specific languages."}, {"id": 43, "string": "\u2022 We conduct experiments on three datasets, and the results demonstrate the effectiveness of SynTime against state-of-the-art baselines."}, {"id": 44, "string": "Related Work Many research works on time expression identification are reported in TempEval exercises (Verhagen et al., 2007 (Verhagen et al., , 2010 UzZaman et al., 2013) ."}, {"id": 45, "string": "The task is divided into two subtasks: recognition and normalization."}, {"id": 46, "string": "Rule-based Time Expression Recognition."}, {"id": 47, "string": "Rule-based time taggers like GUTime, Heidel-Time, and SUTime, predefine time-related words and rules (Verhagen et al., 2005; Str\u00f6tgen and Gertz, 2010; Chang and Manning, 2012) ."}, {"id": 48, "string": "Heidel-Time (Str\u00f6tgen and Gertz, 2010) hand-crafts rules with time resources like weekdays and months, and leverages language clues like part-of-speech to identify time expression."}, {"id": 49, "string": "SUTime (Chang and Manning, 2012) designs deterministic rules using a cascade finite automata (Hobbs et al., 1997) on regular expressions over tokens (Chang and Manning, 2014) ."}, {"id": 50, "string": "It first identifies individual words, then expands them to chunks, and finally to time expressions."}, {"id": 51, "string": "Rule-based taggers achieve very good results in TempEval exercises."}, {"id": 52, "string": "SynTime is also a rule-based tagger while its key difference from other rule-based taggers is that between the rules and the tokens it introduces a layer of token type; its rules work on token types and are independent of specific tokens."}, {"id": 53, "string": "Moreover, SynTime designs rules in a heuristic way."}, {"id": 54, "string": "Machine Learning based Method."}, {"id": 55, "string": "Machine learning based methods extract features from the text and apply statistical models on the features for recognizing time expressions."}, {"id": 56, "string": "Example features include character features, word features, syntactic features, semantic features, and gazetteer features (Llorens et al., 2010; Filannino et al., 2013; Bethard, 2013) ."}, {"id": 57, "string": "The statistical models include Markov logic network, logistic regression, support vector machines, maximum entropy, and conditional random fields (Llorens et al., 2010; Uz-Zaman and Allen, 2010; Filannino et al., 2013; Bethard, 2013) ."}, {"id": 58, "string": "Some models obtain good performance, and even achieve the highest F 1 of 82.71% on strict match in TempEval-3 (Bethard, 2013) ."}, {"id": 59, "string": "Outside TempEval exercises, Angeli et al."}, {"id": 60, "string": "leverage compositional grammar and employ a EMstyle approach to learn a latent parser for time expression recognition (Angeli et al., 2012) ."}, {"id": 61, "string": "In the method named UWTime, Lee et al."}, {"id": 62, "string": "handcraft a combinatory categorial grammar (CCG) (Steedman, 1996) to define a set of lexicon with rules and use L1-regularization to learn linguistic context (Lee et al., 2014) ."}, {"id": 63, "string": "The two methods explicitly use linguistic information."}, {"id": 64, "string": "In (Lee et al., 2014) , especially, CCG could capture rich structure information of language, similar to the rule-based methods."}, {"id": 65, "string": "Tabassum et al."}, {"id": 66, "string": "focus on resolving the dates in tweets, and use distant supervision to recognize time expressions (Tabassum et al., 2016) ."}, {"id": 67, "string": "They use five time types and assign one of them to each word, which is similar to SynTime in the way of defining types over tokens."}, {"id": 68, "string": "However, they focus only on the type of date, while SynTime recoginizes all the time expressions and does not involve learning and runs in real time."}, {"id": 69, "string": "Time Expression Normalization."}, {"id": 70, "string": "Methods in TempEval exercises design rules for time expression normalization (Verhagen et al., 2005; Str\u00f6tgen and Gertz, 2010; Llorens et al., 2010; Uz-Zaman and Allen, 2010; Filannino et al., 2013; Bethard, 2013) ."}, {"id": 71, "string": "Because the rule systems have high similarity, Llorens et al."}, {"id": 72, "string": "suggest to construct a large knowledge base as a public resource for the task (Llorens et al., 2012) ."}, {"id": 73, "string": "Some researchers treat the normalization process as a learning task and use machine learning methods (Lee et al., 2014; Tabassum et al., 2016) ."}, {"id": 74, "string": "Lee et al."}, {"id": 75, "string": "(Lee et al., 2014) use AdaGrad algorithm (Duchi et al., 2011) and Tabassum et al."}, {"id": 76, "string": "(Tabassum et al., 2016 ) use a loglinear algorithm to normalize time expressions."}, {"id": 77, "string": "SynTime focuses only on the recognition task."}, {"id": 78, "string": "The normalization could be achieved by using methods similar to the existing rule systems, because they are highly similar (Llorens et al., 2012) ."}, {"id": 79, "string": "We conduct an analysis on four datasets: Time-Bank, Gigaword, WikiWars, and Tweets."}, {"id": 80, "string": "Time-Bank (Pustejovsky et al., 2003b ) is a benchmark dataset in TempEval series (Verhagen et al., 2007 (Verhagen et al., , 2010 UzZaman et al., 2013) , consisting of 183 news articles."}, {"id": 81, "string": "Gigaword (Parker et al., 2011 ) is a large automatically labelled dataset with 2,452 news articles and used in TempEval-3."}, {"id": 82, "string": "WikiWars dataset is derived from Wikipedia articles about wars (Mazur and Dale, 2010) ."}, {"id": 83, "string": "Tweets is our manually annotated dataset with 942 tweets of which each contains at least one time expression."}, {"id": 84, "string": "Table 1 summarizes the datasets."}, {"id": 85, "string": "Finding From the four datasets, we analyze their time expressions and make four findings."}, {"id": 86, "string": "We will see that despite the four datasets vary in corpus sizes, in text types, and in domains, their time expressions demonstrate similar characteristics."}, {"id": 87, "string": "Finding 1 Time expressions are very short."}, {"id": 88, "string": "More than 80% of time expressions contain no more than three words and more than 90% contain no more than four words."}, {"id": 89, "string": "Figure 1 plots the length distribution of time expressions."}, {"id": 90, "string": "Although the texts are collected from different sources (i.e., news articles, Wikipedia articles, and tweets) and vary in sizes, the length  Finding 2 More than 91% of time expressions contain at least one time token."}, {"id": 91, "string": "The second column in Table 2 reports the percentage of time expressions that contain at least one time token."}, {"id": 92, "string": "We find that at least 91.81% of time expressions contain time token(s)."}, {"id": 93, "string": "(Some time expressions have no time token but depend on other time expressions; in '2 to 8 days,' for example, '2' depends on '8 days.')"}, {"id": 94, "string": "This suggests that time tokens account for time expressions."}, {"id": 95, "string": "Therefore, to recognize time expressions, it is essential to recognize their time tokens."}, {"id": 96, "string": "Finding 3 Only a small group of time-related keywords are used to express time information."}, {"id": 97, "string": "From the time expressions in all four datasets, we find that the group of keywords used to express time information is small."}, {"id": 98, "string": "Table 3 reports the number of distinct words and of distinct time tokens."}, {"id": 99, "string": "The words/tokens are manually normalized before counting and their variants are ignored."}, {"id": 100, "string": "For example, 'year' and '5yrs' are counted as one token 'year.'"}, {"id": 101, "string": "Numerals in the counting are ignored."}, {"id": 102, "string": "Despite the four datasets vary in sizes, domains, and text types, the numbers of their distinct time tokens are comparable."}, {"id": 103, "string": "Across the four datasets, the number of distinct words is 350, about half of the simply summing of 675; the number of distinct time tokens is 123, less than half of the simply summing 282."}, {"id": 104, "string": "Among the 123 distinct time tokens, 45 appear in all the four datasets, and 101 appear in at least two datasets."}, {"id": 105, "string": "This indicates that time tokens, which account for time expressions, are highly overlapped across the four datasets."}, {"id": 106, "string": "In other words, time expressions highly overlap at their time tokens."}, {"id": 107, "string": "Finding 4 POS information could not distinguish time expressions from common words, but within time expressions, POS tags can help distinguish their constituents."}, {"id": 108, "string": "For each dataset we list the top 10 POS tags that appear in time expressions, and their percentages over the whole text."}, {"id": 109, "string": "Among the 40 tags (10 \u00d7 4 datasets), 37 have percentage lower than 20%; other 3 are CD."}, {"id": 110, "string": "This indicates that POS could not provide enough information to distinguish time expressions from common words."}, {"id": 111, "string": "However, the most common POS tags in time expressions are NN*, JJ, RB, CD, and DT."}, {"id": 112, "string": "Within time expressions, the time tokens usually have NN* and RB, the modifiers have JJ and RB, and the numerals have CD."}, {"id": 113, "string": "This finding indicates that for the time expressions, their similar constituents behave in similar syntactic way."}, {"id": 114, "string": "When seeing this, we realize that this is exactly how linguists define part-of-speech for language."}, {"id": 115, "string": "4 The definition of POS for language inspires us to define a syntactic type system for the time expression, part of language."}, {"id": 116, "string": "The four findings all relate to the principle of least effort (Zipf, 1949) ."}, {"id": 117, "string": "That is, people tend to act with least effort so as to minimize the cost of energy at both individual and collective levels to the language usage (Zipf, 1949) ."}, {"id": 118, "string": "Time expression is part of language and acts as an interface of communication."}, {"id": 119, "string": "Short expressions, occurrence, small vocabulary, and similar syntactic behaviour all reduce the cost of energy required to communicate."}, {"id": 120, "string": "To summarize: on average, a time expression contains two tokens of which one is time token and the other is modifier/numeral, and the size of time tokens is small."}, {"id": 121, "string": "To recognize a time expression, therefore, we first recognize the time token, then recognize the modifier/numeral."}, {"id": 122, "string": "SynTime: Syntactic Token Types and General Heuristic Rules SynTime defines a syntactic type system for the tokens of time expressions, and designs heuristic rules working on the token types."}, {"id": 123, "string": "Figure 2 shows the layout of SynTime, consisting of three levels: Token level, type level, and rule level."}, {"id": 124, "string": "Token types at the type level group the tokens of time expressions."}, {"id": 125, "string": "Heuristic rules lie at the rule level, working on token types rather than on tokens themselves."}, {"id": 126, "string": "That is why the heuristic rules are general."}, {"id": 127, "string": "For example, the heuristic rules do not work on tokens '1989' nor 'February,' but on their token types 'YEAR' and 'MONTH.'"}, {"id": 128, "string": "The heuristic rules are only relevant to token types, and are independent of specific tokens."}, {"id": 129, "string": "For this reason, our token types and heuristic rules are independent of specific domains, specific text types, and even specific languages that consist of specific tokens."}, {"id": 130, "string": "In this paper, we test SynTime on specific domain (i.e., war domain) and specific text types (i.e., formal text and informal text) in English."}, {"id": 131, "string": "The test for other languages simply needs to construct a set of token regular expressions in the target language under our defined token types."}, {"id": 132, "string": "Figure 3 shows the overview of SynTime in practice."}, {"id": 133, "string": "Shown on the left-hand side, SynTime is initialized with regular expressions over tokens."}, {"id": 134, "string": "After initialization, SynTime can be directly applied on text."}, {"id": 135, "string": "On the other hand, SynTime can be easily expanded by simply adding the time-related token regular expressions from training text under each defined token type."}, {"id": 136, "string": "The expansion enables SynTime to recognize time expressions in text from different domains and different text types."}, {"id": 137, "string": "Shown on the right-hand side of Figure 3 , Syn-Time recognizes time expression through three main steps."}, {"id": 138, "string": "In the first step, SynTime identifies time tokens from the POS-tagged raw text."}, {"id": 139, "string": "Then around the time tokens SynTime searches for modifiers and numerals to form time segments."}, {"id": 140, "string": "In the last step, SynTime transforms the time segments to time expressions."}, {"id": 141, "string": "SynTime Construction We define a syntactic type system for time expression, specifically, 15 token types for time tokens, 5 token types for modifiers, and 1 token type for numeral."}, {"id": 142, "string": "Token types to tokens is like POS tags to words; for example, 'February' has a POS tag of NNP and a token type of MONTH."}, {"id": 143, "string": "Time Token."}, {"id": 144, "string": "We define 15 token types for the time tokens and use their names similar to Joda-Time classes: 5 DECADE (-), YEAR (-), SEA-SON (5), MONTH (12), WEEK (7), DATE (-), TIME (-), DAY TIME (27), TIMELINE (12), HOLIDAY (20), PERIOD (9), DURATION (-), TIME UNIT (15), TIME ZONE (6), and ERA (2)."}, {"id": 145, "string": "Number in '()' indicates the number of distinct tokens in this token type."}, {"id": 146, "string": "'-' indicates that this token type involves changing digits and cannot be counted."}, {"id": 147, "string": "Modifier."}, {"id": 148, "string": "We define 3 token types for the modifiers according to their possible positions relative to time tokens."}, {"id": 149, "string": "Modifiers that appear before time tokens are PREFIX (48); modifiers after time tokens are SUFFIX (2)."}, {"id": 150, "string": "LINKAGE (4) link two time tokens."}, {"id": 151, "string": "Besides, we define 2 special modifier types, COMMA (1) for comma ',' and IN ARTICLE (2) for indefinite articles 'a' and 'an.'"}, {"id": 152, "string": "TimeML (Pustejovsky et al., 2003a) and Time-Bank (Pustejovsky et al., 2003b) do not treat most prepositions like 'on' as a part of time expressions."}, {"id": 153, "string": "Thus SynTime does not collect those prepositions."}, {"id": 154, "string": "Numeral."}, {"id": 155, "string": "Number in time expressions can be a time token e.g., '10' in 'October 10, 2016,' or a modifier e.g., '10' in '10 days.'"}, {"id": 156, "string": "We define NU-MERAL (-) for the ordinals and numbers."}, {"id": 157, "string": "SynTime Initialization."}, {"id": 158, "string": "The token regular expressions for initializing SynTime are collected from SUTime, 6 a state-of-the-art rule-based tagger that achieved the highest recall in TempEval-3 (Chang and Manning, , 2013 ."}, {"id": 159, "string": "Specifically, we collect from SUTime only the tokens and the regular expressions over tokens, and discard its other rules of recognizing full time expressions."}, {"id": 160, "string": "Time Expression Recognition On the token types, SynTime designs a small set of heuristic rules to recognize time expressions."}, {"id": 161, "string": "The recognition process includes three main steps: (1) time token identification, (2) time segment identification, and (3) time expression extraction."}, {"id": 162, "string": "Time Token Identification Identifying time tokens is simple, through matching of string and regular expressions."}, {"id": 163, "string": "Some words might cause ambiguity."}, {"id": 164, "string": "For example, 'May' could be a modal verb, or the fifth month of year."}, {"id": 165, "string": "To filter out the ambiguous words, we use POS information."}, {"id": 166, "string": "In implementation, we use Stanford POS Tagger; 7 and the POS tags for matching the instances of token types in SynTime are based on our Finding 4 in Section 3.2."}, {"id": 167, "string": "Besides time tokens are identified, in this step, individual token is assigned with one token type of either modifier or numeral if it is matched with token regular expressions."}, {"id": 168, "string": "In the next two steps, SynTime works on those token types."}, {"id": 169, "string": "Time Segment Identification The task of time segment identification is to search the surrounding of each time token identified in previous step for modifiers and numerals, then gather the time token with its modifiers and numerals to form a time segment."}, {"id": 170, "string": "The searching is under simple heuristic rules in which the key idea is to expand the time token's boundaries."}, {"id": 171, "string": "At first, each time token is a time segment."}, {"id": 172, "string": "If it is either a PERIOD or DURATION, then no need to further search."}, {"id": 173, "string": "Otherwise, search its left and its right for modifiers and numerals."}, {"id": 174, "string": "For the left searching, if encounter a PREFIX or NUMERAL or IN ARTICLE, then continue searching."}, {"id": 175, "string": "For the right searching, if encounter a SUFFIX or NUMERAL, then continue searching."}, {"id": 176, "string": "Both the left and the right searching stop when reaching a COMMA or LINK-AGE or a non-modifier/numeral word."}, {"id": 177, "string": "The left searching does not exceed the previous time token; the right searching does not exceed the next time token."}, {"id": 178, "string": "A time segment consists of exactly one time token, and zero or some modifiers/numerals."}, {"id": 179, "string": "A special kind of time segments do not contain any time token; they depend on other time segments next to them."}, {"id": 180, "string": "For example, in '8 to 20 days,' 'to 20 days' is a time segment, and '8 to' forms a dependent time segment."}, {"id": 181, "string": "(See Figure 4(e) .)"}, {"id": 182, "string": "Time Expression Extraction The task of time expression extraction is to extract time expressions from the identified time segments in which the core step is to determine whether to merge two adjacent or overlapping time segments into a new time segment."}, {"id": 183, "string": "We scan the time segments in a sentence from beginning to the end."}, {"id": 184, "string": "A stand-alone time segment is a time expression."}, {"id": 185, "string": "(See Figure 4(a) .)"}, {"id": 186, "string": "The focus is to deal with two or more time segments that are adjacent or overlapping."}, {"id": 187, "string": "If two time segments s 1 and s 2 are adjacent, merge them to form a new time segment s 1 ."}, {"id": 188, "string": "(See Figure 4(b) .)"}, {"id": 189, "string": "Consider that s 1 and s 2 overlap at a shared boundary."}, {"id": 190, "string": "According to our time segment identification, the shared boundary could be a modifier or a numeral."}, {"id": 191, "string": "If the word at the shared boundary is neither a COMMA nor a LINKAGE, then merge s 1 and s 2 ."}, {"id": 192, "string": "(See Figure 4(c) .)"}, {"id": 193, "string": "If the word is a LINKAGE, then extract s 1 as a time expression and continue scanning."}, {"id": 194, "string": "When the shared boundary is a COMMA, merge s 1 and s 2 only if the COMMA's previous token and its next token satisfy the three conditions: (1) the previous token is a time token or a NUMERAL; (2) the next token is a time token; and (3) the token types of the previous token and of the next token are not the same."}, {"id": 195, "string": "(See Figure 4(d) .)"}, {"id": 196, "string": "Although Figure 4 shows the examples as token types together with the tokens, we should note that the heuristic rules only work on the token types."}, {"id": 197, "string": "After the extraction step, time expressions are exported as a sequence of tokens from the sequence of token types."}, {"id": 198, "string": "SynTime Expansion SynTime could be expanded by simply adding new words under each defined token type without changing any rule."}, {"id": 199, "string": "The expansion requires the words to be added to be annotated manually."}, {"id": 200, "string": "We apply the initial SynTime on the time expressions from training text and list the words that are not covered."}, {"id": 201, "string": "Whether the uncovered words are added to SynTime is manually determined."}, {"id": 202, "string": "The rule for determination is that the added words can not cause ambiguity and should be generic."}, {"id": 203, "string": "Wiki-Wars dataset contains a few examples like this: 'The time Arnold reached Quebec City.'"}, {"id": 204, "string": "Words in this example are extremely descriptive, and we do not collect them."}, {"id": 205, "string": "In tweets, on the other hand, people may use abbreviations and informal variants; for example, '2day' and 'tday' are popular spellings of 'today.'"}, {"id": 206, "string": "Such kind of abbreviations and informal variants will be collected."}, {"id": 207, "string": "According to our findings, not many words are used to express time information, the manual addition of keywords thus will not cost much."}, {"id": 208, "string": "In addition, we find that even in tweets people tend to use formal words."}, {"id": 209, "string": "In the Twitter word clusters trained from 56 million English tweets, 8 the most often used words are the formal words, and their frequencies are much greater than the informal words'."}, {"id": 210, "string": "The cluster of 'today,' 9 for example, its most often use is the formal one, 'today,' which appears 1,220,829 times; while its second most often use '2day' appears only 34,827 times."}, {"id": 211, "string": "The low rate of informal words (e.g., about 3% in 'today' cluster) suggests that even in informal environment the manual keyword addition costs little."}, {"id": 212, "string": "Experiments We evaluate SynTime against three state-of-theart baselines (i.e., HeidelTime, SUTime, and UW-Time) on three datasets (i.e., TimeBank, Wiki-Wars, and Tweets)."}, {"id": 213, "string": "WikiWars is a specific domain dataset about war; TimeBank and WikiWars are the datasets in formal text while Tweets dataset is in informal text."}, {"id": 214, "string": "For SynTime we report the results of its two versions: SynTime-I and SynTime-E. SynTime-I is the initial version, and SynTime-E is the expanded version of SynTime-I."}, {"id": 215, "string": "Experiment Setting Datasets."}, {"id": 216, "string": "We use three datasets of which TimeBank and WikiWars are benchmark datasets whose details are shown in Section 3.1; Tweets is our manually labeled dataset that are collected from Twitter."}, {"id": 217, "string": "For Tweets dataset, we randomly sample 4000 tweets and use SUTime to tag them."}, {"id": 218, "string": "942 tweets of which each contains at least one time expression."}, {"id": 219, "string": "From the remaining 3,058 tweets, we randomly sample 500 and manually annotate them, and find that only 15 tweets contain time expressions."}, {"id": 220, "string": "We therefore roughly consider that SU-Time misses about 3% time expressions in tweets."}, {"id": 221, "string": "Two annotators then manually annotate the 942 tweets with discussion to final agreement according to the standards of TimeML and TimeBank."}, {"id": 222, "string": "We finally get 1,127 manually labeled time expressions."}, {"id": 223, "string": "For the 942 tweets, we randomly sample 200 tweets as test set, and the rest 742 as training set, because a baseline UWTime requires training."}, {"id": 224, "string": "Baseline Methods."}, {"id": 225, "string": "We compare SynTime with methods: HeidelTime (Str\u00f6tgen and Gertz, 2010) , SUTime (Chang and , and UW- Evaluation Metrics."}, {"id": 226, "string": "We follow TempEval-3 and use their evaluation toolkit 10 to report P recision, Recall, and F 1 in terms of strict match and relaxed match (UzZaman et al., 2013)."}, {"id": 227, "string": "22, 1986' and 'February 01, 1989 ' at the level of word or of character."}, {"id": 228, "string": "One suggestion is to consider a type-based learning method that could use type information."}, {"id": 229, "string": "For example, the above two time expressions refer to the same pattern of 'MONTH NUMERAL COMMA Table 5 lists the number of time tokens and modifiers added to SynTime-I to get SynTime-E. On TimeBank and Tweets datasets, only a few tokens are added, the corresponding results are affected slightly."}, {"id": 230, "string": "This confirms that the size of time words is small, and that SynTime-I covers most of time words."}, {"id": 231, "string": "On WikiWars dataset, relatively more tokens are added, SynTime-E performs much better than SynTime-I, especially in recall."}, {"id": 232, "string": "It improves the recall by 3.25% in strict match and by 2.98% in relaxed match."}, {"id": 233, "string": "This indicates that with more words added from specific domains (e.g., WikiWars dataset about war), SynTime can significantly improve the performance."}, {"id": 234, "string": "Experiment Result Limitations SynTime assumes that words are tokenized and POS tagged correctly."}, {"id": 235, "string": "In reality, however, the tokenized and tagged words are not that perfect, due to the limitation of used tools."}, {"id": 236, "string": "For example, Stanford POS Tagger assigns VBD to the word 'sat' in 'friday or sat' while whose tag should be NNP."}, {"id": 237, "string": "The incorrect tokens and POS tags affect the result."}, {"id": 238, "string": "Conclusion and future work We conduct an analysis on time expressions from four datasets, and find that time expressions in general are very short and expressed by a small vocabulary, and words in time expressions demonstrate similar syntactic behavior."}, {"id": 239, "string": "Our findings provide evidence in terms of time expression for the principle of least effort (Zipf, 1949) ."}, {"id": 240, "string": "Inspired by part-of-speech, based on the findings, we define a syntactic type system for the time expression, and propose a type-based time expression tagger, named by SynTime."}, {"id": 241, "string": "SynTime defines syntactic token types for tokens and on the token types it designs general heuristic rules based on the idea of boundary expansion."}, {"id": 242, "string": "Experiments on three datasets show that SynTime outperforms the stateof-the-art baselines, including rule-based time taggers and machine learning based time tagger."}, {"id": 243, "string": "Because our heuristic rules are quite simple, Syn-Time is light-weight and runs in real time."}, {"id": 244, "string": "Our token types and heuristic rules are independent of specific tokens, SynTime therefore is independent of specific domains, specific text types, and even specific languages that consist of specific tokens."}, {"id": 245, "string": "In this paper, we test SynTime on specific domains and specific text types in English."}, {"id": 246, "string": "The test for other languages needs only to construct a collection of token regular expressions in the target language under our defined token types."}, {"id": 247, "string": "Time expression is part of language and follows the principle of least effort."}, {"id": 248, "string": "Since language usage relates to human habits (Zipf, 1949; Chomsky, 1986; Pinker, 1995) , we might expect that humans would share some common habits, and therefore expect that other parts of language would more or less follow the same principle."}, {"id": 249, "string": "In the future we will try our analytical method on other parts of language."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 43}, {"section": "Related Work", "n": "2", "start": 44, "end": 84}, {"section": "Finding", "n": "3.2", "start": 85, "end": 121}, {"section": "SynTime: Syntactic Token Types and General Heuristic Rules", "n": "4", "start": 122, "end": 140}, {"section": "SynTime Construction", "n": "4.1", "start": 141, "end": 159}, {"section": "Time Expression Recognition", "n": "4.2", "start": 160, "end": 161}, {"section": "Time Token Identification", "n": "4.2.1", "start": 162, "end": 168}, {"section": "Time Segment Identification", "n": "4.2.2", "start": 169, "end": 181}, {"section": "Time Expression Extraction", "n": "4.2.3", "start": 182, "end": 197}, {"section": "SynTime Expansion", "n": "4.3", "start": 198, "end": 211}, {"section": "Experiments", "n": "5", "start": 212, "end": 233}, {"section": "Limitations", "n": "5.3", "start": 234, "end": 237}, {"section": "Conclusion and future work", "n": "6", "start": 238, "end": 249}], "figures": [{"filename": "../figure/image/1262-Figure4-1.png", "caption": "Figure 4: Example time segments and time expressions. The above labels are from time segment identification; the below labels are for time expression extraction.", "page": 5, "bbox": {"x1": 322.56, "x2": 499.2, "y1": 284.64, "y2": 305.28}}, {"filename": "../figure/image/1262-Table1-1.png", "caption": "Table 1: Statistics of the datasets (A tweet here is a document.)", "page": 2, "bbox": {"x1": 315.84, "x2": 517.4399999999999, "y1": 96.47999999999999, "y2": 166.07999999999998}}, {"filename": "../figure/image/1262-Figure1-1.png", "caption": "Figure 1: Length distribution of time expressions", "page": 2, "bbox": {"x1": 324.47999999999996, "x2": 500.15999999999997, "y1": 181.44, "y2": 305.76}}, {"filename": "../figure/image/1262-Table4-1.png", "caption": "Table 4: Overall performance. The best results are in bold face and the second best are underlined. Some results are borrowed from their original papers and the papers are indicated by the references.", "page": 7, "bbox": {"x1": 72.96, "x2": 522.24, "y1": 96.47999999999999, "y2": 330.24}}, {"filename": "../figure/image/1262-Table2-1.png", "caption": "Table 2: The percentage of time expressions that contain at least one time token, and the average length of time expressions", "page": 3, "bbox": {"x1": 84.96, "x2": 277.44, "y1": 108.47999999999999, "y2": 180.0}}, {"filename": "../figure/image/1262-Table3-1.png", "caption": "Table 3: Number of distinct words and number of distinct time tokens in time expressions", "page": 3, "bbox": {"x1": 88.8, "x2": 273.12, "y1": 226.56, "y2": 297.12}}, {"filename": "../figure/image/1262-Table5-1.png", "caption": "Table 5: Number of time tokens and modifiers for expansion", "page": 8, "bbox": {"x1": 80.64, "x2": 279.36, "y1": 96.47999999999999, "y2": 153.12}}, {"filename": "../figure/image/1262-Figure3-1.png", "caption": "Figure 3: Overview of SynTime. Left-hand side shows the construction of SynTime, with initialization using token regular expressions, and optional expansion using training text. Right-hand side shows the main steps of SynTime recognizing time expressions.", "page": 4, "bbox": {"x1": 326.88, "x2": 501.12, "y1": 65.75999999999999, "y2": 245.28}}, {"filename": "../figure/image/1262-Figure2-1.png", "caption": "Figure 2: Layout of SynTime. The layout consists of three levels: token level, type level, and rule level. Token types group the constituent tokens of time expressions. Heuristic rules work on token types, and are independent of specific tokens.", "page": 4, "bbox": {"x1": 75.84, "x2": 284.15999999999997, "y1": 62.879999999999995, "y2": 131.04}}]}