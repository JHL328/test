{"title": "Neural Question Answering at BioASQ 5B", "abstract": "This paper describes our submission to the 2017 BioASQ challenge. We participated in Task B, Phase B which is concerned with biomedical question answering (QA). We focus on factoid and list question, using an extractive QA model, that is, we restrict our system to output substrings of the provided text snippets. At the core of our system, we use FastQA, a state-ofthe-art neural QA system. We extended it with biomedical word embeddings and changed its answer layer to be able to answer list questions in addition to factoid questions. We pre-trained the model on a large-scale open-domain QA dataset, SQuAD, and then fine-tuned the parameters on the BioASQ training set. With our approach, we achieve state-of-the-art results on factoid questions and competitive results on list questions.", "text": [{"id": 0, "string": "Introduction BioASQ is a semantic indexing, question answering (QA) and information extraction challenge (Tsatsaronis et al., 2015) ."}, {"id": 1, "string": "We participated in Task B of the challenge which is concerned with biomedical QA."}, {"id": 2, "string": "More specifically, our system participated in Task B, Phase B: Given a question and gold-standard snippets (i.e., pieces of text that contain the answer(s) to the question), the system is asked to return a list of answer candidates."}, {"id": 3, "string": "The fifth BioASQ challenge is taking place at the time of writing."}, {"id": 4, "string": "Five batches of 100 questions each were released every two weeks."}, {"id": 5, "string": "Participating systems have 24 hours to submit their results."}, {"id": 6, "string": "At the time of writing, all batches had been released."}, {"id": 7, "string": "The questions are categorized into different question types: factoid, list, summary and yes/no."}, {"id": 8, "string": "Our work concentrates on answering factoid and list questions."}, {"id": 9, "string": "For factoid questions, the system's responses are interpreted as a ranked list of answer candidates."}, {"id": 10, "string": "They are evaluated using meanreciprocal rank (MRR)."}, {"id": 11, "string": "For list questions, the system's responses are interpreted as a set of answers to the list question."}, {"id": 12, "string": "Precision and recall are computed by comparing the given answers to the goldstandard answers."}, {"id": 13, "string": "F1 score, i.e., the harmonic mean of precision and recall, is used as the official evaluation measure 1 ."}, {"id": 14, "string": "Most existing biomedical QA systems employ a traditional QA pipeline, similar in structure to the baseline system by Weissenborn et al."}, {"id": 15, "string": "(2013) ."}, {"id": 16, "string": "They consist of several discrete steps, e.g., namedentity recognition, question classification, and candidate answer scoring."}, {"id": 17, "string": "These systems require a large amount of resources and feature engineering that is specific to the biomedical domain."}, {"id": 18, "string": "For example, OAQA (Zi et al., 2016) , which has been very successful in last year's challenge, uses a biomedical parser, entity tagger and a thesaurus to retrieve synonyms."}, {"id": 19, "string": "Our system, on the other hand, is based on a neural network QA architecture that is trained endto-end on the target task."}, {"id": 20, "string": "We build upon FastQA (Weissenborn et al., 2017) , an extractive factoid QA system which achieves state-of-the-art results on QA benchmarks that provide large amounts of training data."}, {"id": 21, "string": "For example, SQuAD (Rajpurkar et al., 2016) provides a dataset of \u2248 100, 000 questions on Wikipedia articles."}, {"id": 22, "string": "Our approach is to train FastQA (with some extensions) on the SQuAD dataset and then fine-tune the model parameters on the BioASQ training set."}, {"id": 23, "string": "Note that by using an extractive QA network as our central component, we restrict our system's Figure 1 : Neural architecture of our system."}, {"id": 24, "string": "Question and context (i.e., the snippets) are mapped directly to start and end probabilities for each context token."}, {"id": 25, "string": "We use FastQA (Weissenborn et al., 2017) with modified input vectors and an output layer that supports list answers in addition to factoid answers."}, {"id": 26, "string": "responses to substrings in the provided snippets."}, {"id": 27, "string": "This also implies that the network will not be able to answer yes/no questions."}, {"id": 28, "string": "We do, however, generalize the FastQA output layer in order to be able to answer list questions in addition to factoid questions."}, {"id": 29, "string": "Model Our system is a neural network which takes as input a question and a context (i.e., the snippets) and outputs start and end pointers to tokens in the context."}, {"id": 30, "string": "At its core, we use FastQA (Weissenborn et al., 2017) , a state-of-the-art neural QA system."}, {"id": 31, "string": "In the following, we describe our changes to the architecture and how the network is trained."}, {"id": 32, "string": "Network architecture In the input layer, the context and question tokens are mapped to high-dimensional word vectors."}, {"id": 33, "string": "Our word vectors consists of three components, which are concatenated to form a single vector: \u2022 GloVe embedding: We use 300-dimensional GloVe embeddings 2 (Pennington et al., 2014) which have been trained on a large collection of web documents."}, {"id": 34, "string": "\u2022 Character embedding: This embedding is computed by a 1-dimensional convolutional neural network from the characters of the words, as introduced by Seo et al."}, {"id": 35, "string": "(2016) ."}, {"id": 36, "string": "\u2022 Biomedical Word2Vec embeddings: We use the biomedical word embeddings provided by Pavlopoulos et al."}, {"id": 37, "string": "(2014) ."}, {"id": 38, "string": "These are 200-dimensional Word2Vec embeddings (Mikolov et al., 2013) which were trained on \u2248 10 million PubMed abstracts."}, {"id": 39, "string": "To the embedding vectors, we concatenate a one-hot encoding of the question type (list or factoid)."}, {"id": 40, "string": "Note that these features are identical for all tokens."}, {"id": 41, "string": "Following our embedding layer, we invoke FastQA in order to compute start and end scores for all context tokens."}, {"id": 42, "string": "Because end scores are conditioned on the chosen start, there are O(n 2 ) end scores where n is the number of context tokens."}, {"id": 43, "string": "We denote the start index by i \u2208 [1, n], the end index by j \u2208 [i, n], the start scores by y i start , and end scores by y i,j end ."}, {"id": 44, "string": "In our output layer, the start, end, and span probabilities are computed as: p i start = \u03c3(y i start ) (1) p i,\u00b7 end = sof tmax(y i,\u00b7 end ) (2) p i,j span = p i start \u00b7 p i,j end (3) where \u03c3 denotes the sigmoid function."}, {"id": 45, "string": "By computing the start probability via the sigmoid rather than softmax function (as used in FastQA), we enable the model to output multiple spans as likely answer spans."}, {"id": 46, "string": "This generalizes the factoid QA network to list questions."}, {"id": 47, "string": "Training & decoding Loss We define our loss as the cross-entropy of the correct start and end indices."}, {"id": 48, "string": "In the case of multiple occurrences of the same answer, we only minimize the span of the lowest loss."}, {"id": 49, "string": "Table 1 : Preliminary results for factoid and list questions for all five batches and for our single and ensemble systems."}, {"id": 50, "string": "We report MRR and F1 scores for factoid and list questions, respectively."}, {"id": 51, "string": "In parentheses, we report the rank of the respective systems relative to all other systems in the challenge."}, {"id": 52, "string": "The last row averages the performance numbers of the respective system and question type across the five batches."}, {"id": 53, "string": "Optimization We train the network in two steps: First, the network is trained on SQuAD, following the procedure by Weissenborn et al."}, {"id": 54, "string": "(2017) (pretraining phase) ."}, {"id": 55, "string": "Second, we fine-tune the network parameters on BioASQ (fine-tuning phase)."}, {"id": 56, "string": "For both phases, we use the Adam optimizer (Kingma and Ba, 2014) with an exponentially decaying learning rate."}, {"id": 57, "string": "We start with learning rates of 10 \u22123 and 10 \u22124 for the pre-training and fine-tuning phases, respectively."}, {"id": 58, "string": "BioASQ dataset preparation During finetuning, we extract answer spans from the BioASQ training data by looking for occurrences of the gold standard answer in the provided snippets."}, {"id": 59, "string": "Note that this approach is not perfect as it can produce false positives (e.g., the answer is mentioned in a sentence which does not answer the question) and false negatives (e.g., a sentence answers the question, but the exact string used is not in the synonym list)."}, {"id": 60, "string": "Because BioASQ usually contains multiple snippets for a given question, we process all snippets independently and then aggregate the answer spans, sorting globally according to their probability p i,j span ."}, {"id": 61, "string": "Decoding During the inference phase, we retrieve the top 20 answers span via beam search with beam size 20."}, {"id": 62, "string": "From this sorted list of answer strings, we remove all duplicate strings."}, {"id": 63, "string": "For factoid questions, we output the top five answer strings as our ranked list of answer candidates."}, {"id": 64, "string": "For list questions, we use a probability cutoff threshold t, such that {(i, j)|p i,j span \u2265 t} is the set of answers."}, {"id": 65, "string": "We set t to be the threshold for which the list F1 score on the development set is optimized."}, {"id": 66, "string": "Ensemble In order to further tweak the performance of our systems, we built a model ensemble."}, {"id": 67, "string": "For this, we trained five single models using 5-fold cross-validation on the entire training set."}, {"id": 68, "string": "These models are combined by averaging their start and end scores before computing the span probabilities (Equations 1-3)."}, {"id": 69, "string": "As a result, we submit two systems to the challenge: The best single model (according to its development set) and the model ensemble."}, {"id": 70, "string": "Implementation We implemented our system using TensorFlow (Abadi et al., 2016) ."}, {"id": 71, "string": "It was trained on an NVidia GForce Titan X GPU."}, {"id": 72, "string": "Results & discussion We report the results for all five test batches of BioASQ 5 (Task 5b, Phase B) in Table 1 ."}, {"id": 73, "string": "Note that the performance numbers are not final, as the provided synonyms in the gold-standard answers will be updated as a manual step, in order to reflect valid responses by the participating systems."}, {"id": 74, "string": "This has not been done by the time of writing 3 ."}, {"id": 75, "string": "Note also that -in contrast to previous BioASQ challenges -systems are no longer allowed to provide an own list of synonyms in this year's challenge."}, {"id": 76, "string": "In general, the single and ensemble system are performing very similar relative to the rest of field: Their ranks are almost always right next to each other."}, {"id": 77, "string": "Between the two, the ensemble model performed slightly better on average."}, {"id": 78, "string": "On factoid questions, our system has been very successful, winning three out of five batches."}, {"id": 79, "string": "On list questions, however, the relative performance varies significantly."}, {"id": 80, "string": "We expect our system to perform better on factoid questions than list questions, because our pre-training dataset (SQuAD) does not contain any list questions."}, {"id": 81, "string": "Starting with batch 3, we also submitted responses to yes/no questions by always answering yes."}, {"id": 82, "string": "Because of a very skewed class distribution in the BioASQ dataset, this is a strong baseline."}, {"id": 83, "string": "Because this is done merely to have baseline performance for this question type and because of the naivety of the method, we do not list or discuss the results here."}, {"id": 84, "string": "Conclusion In this paper, we summarized the system design of our BioASQ 5B submission for factoid and list questions."}, {"id": 85, "string": "We use a neural architecture which is trained end-to-end on the QA task."}, {"id": 86, "string": "This approach has not been applied to BioASQ questions in previous challenges."}, {"id": 87, "string": "Our results show that our approach achieves state-of-the art results on factoid questions and competitive results on list questions."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 28}, {"section": "Model", "n": "2", "start": 29, "end": 31}, {"section": "Network architecture", "n": "2.1", "start": 32, "end": 46}, {"section": "Training & decoding", "n": "2.2", "start": 47, "end": 71}, {"section": "Results & discussion", "n": "3", "start": 72, "end": 83}, {"section": "Conclusion", "n": "4", "start": 84, "end": 87}], "figures": [{"filename": "../figure/image/1174-Table1-1.png", "caption": "Table 1: Preliminary results for factoid and list questions for all five batches and for our single and ensemble systems. We report MRR and F1 scores for factoid and list questions, respectively. In parentheses, we report the rank of the respective systems relative to all other systems in the challenge. The last row averages the performance numbers of the respective system and question type across the five batches.", "page": 2, "bbox": {"x1": 133.92, "x2": 463.2, "y1": 62.4, "y2": 184.32}}, {"filename": "../figure/image/1174-Figure1-1.png", "caption": "Figure 1: Neural architecture of our system. Question and context (i.e., the snippets) are mapped directly to start and end probabilities for each context token. We use FastQA (Weissenborn et al., 2017) with modified input vectors and an output layer that supports list answers in addition to factoid answers.", "page": 1, "bbox": {"x1": 72.0, "x2": 299.03999999999996, "y1": 61.44, "y2": 276.0}}]}