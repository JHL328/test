{"title": "Syntax for Semantic Role Labeling, To Be, Or Not To Be", "abstract": "Semantic role labeling (SRL) is dedicated to recognizing the predicate-argument structure of a sentence. Previous studies have shown syntactic information has a remarkable contribution to SRL performance. However, such perception was challenged by a few recent neural SRL models which give impressive performance without a syntactic backbone. This paper intends to quantify the importance of syntactic information to dependency SRL in deep learning framework. We propose an enhanced argument labeling model companying with an extended korder argument pruning algorithm for effectively exploiting syntactic information. Our model achieves state-of-the-art results on the CoNLL-2008, 2009 benchmarks for both English and Chinese, showing the quantitative significance of syntax to neural SRL together with a thorough empirical survey over existing models.", "text": [{"id": 0, "string": "Introduction Semantic role labeling (SRL), namely semantic parsing, is a shallow semantic parsing task, which aims to recognize the predicate-argument structure of each predicate in a sentence, such as who did what to whom, where and when, etc."}, {"id": 1, "string": "Specifically, we seek to identify arguments and label their semantic roles given a predicate."}, {"id": 2, "string": "SRL is an impor-tant method to obtain semantic information beneficial to a wide range of natural language processing (NLP) tasks, including machine translation (Shi et al., 2016) , question answering (Berant et al., 2013; Yih et al., 2016) and discourse relation sense classification (Mihaylov and Frank, 2016) ."}, {"id": 3, "string": "There are two formulizations for semantic predicate-argument structures, one is based on constituents (i.e., phrase or span), the other is based on dependencies."}, {"id": 4, "string": "The latter proposed by the CoNLL-2008 shared task (Surdeanu et al., 2008) is also called semantic dependency parsing, which annotates the heads of arguments rather than phrasal arguments."}, {"id": 5, "string": "Generally, SRL is decomposed into multi-step classification subtasks in pipeline systems, consisting of predicate identification and disambiguation, argument identification and classification."}, {"id": 6, "string": "In prior work of SRL, considerable attention has been paid to feature engineering that struggles to capture sufficient discriminative information, while neural network models are capable of extracting features automatically."}, {"id": 7, "string": "In particular, syntactic information, including syntactic tree feature, has been show extremely beneficial to SRL since a larger scale of empirical verification of Punyakanok et al."}, {"id": 8, "string": "(2008) ."}, {"id": 9, "string": "However, all the work had to take the risk of erroneous syntactic input, leading to an unsatisfactory performance."}, {"id": 10, "string": "To alleviate the above issues,  propose a simple but effective model for dependency SRL without syntactic input."}, {"id": 11, "string": "It seems that neural SRL does not have to rely on syntactic features, contradicting with the belief that syntax is a necessary prerequisite for SRL as early as Gildea and Palmer (2002) ."}, {"id": 12, "string": "This dramatic contradiction motivates us to make a thorough exploration on syntactic contribution to SRL."}, {"id": 13, "string": "This paper will focus on semantic dependency parsing and formulate SRL as one or two se-quence tagging tasks with predicate-specific encoding."}, {"id": 14, "string": "With the help of the proposed k-order argument pruning algorithm over syntactic tree, our model obtains state-of-the-art scores on the CoNLL benchmarks for both English and Chinese."}, {"id": 15, "string": "In order to quantitatively evaluate the contribution of syntax to SRL, we adopt the ratio between labeled F 1 score for semantic dependencies (Sem-F 1 ) and the labeled attachment score (LAS) for syntactic dependencies introduced by CoNLL-2008 Shared Task 1 as evaluation metric."}, {"id": 16, "string": "Considering that various syntactic parsers contribute different syntactic inputs with various range of quality levels, the ratio provides a fairer comparison between syntactically-driven SRL systems, which will be surveyed by our empirical study."}, {"id": 17, "string": "Model To fully disclose the predicate-argument structure, typical SRL systems have to step by step perform four subtasks."}, {"id": 18, "string": "Since the predicates in CoNLL-2009 (Haji\u010d et al., 2009 ) corpus have been preidentified, we need to tackle three other subtasks, which are formulized into two-step pipeline in this work, predicate disambiguation and argument labeling."}, {"id": 19, "string": "Namely, we do the work of argument identification and classification in one model."}, {"id": 20, "string": "Argument structure for each known predicate will be disclosed by our argument labeler over a sequence including possible arguments (candidates)."}, {"id": 21, "string": "There are two ways to determine the sequence, one is to simply input the entire sentence as a syntax-agnostic SRL system does, the other is to select words according to syntactic parse tree around the predicate as most previous SRL systems did."}, {"id": 22, "string": "The latter strategy usually works through a syntactic tree based argument pruning algorithm."}, {"id": 23, "string": "We will use the proposed k-order argument pruning algorithm (Section 2.1) to get a sequence w = (w 1 , ."}, {"id": 24, "string": "."}, {"id": 25, "string": "."}, {"id": 26, "string": ", w n ) for each predicate."}, {"id": 27, "string": "Then, we represent each word w i \u2208 w as x i (Section 2.2)."}, {"id": 28, "string": "Eventually, we obtain contextual features with sequence encoder (Section 2.3)."}, {"id": 29, "string": "The overall role labeling model is depicted in Figure 1 ."}, {"id": 30, "string": "Argument Pruning As pointed out by Punyakanok et al."}, {"id": 31, "string": "(2008) , syntactic information is most relevant in identifying 1 CoNLL-2008 is an English-only task, while CoNLL-2009 extends to a multilingual one."}, {"id": 32, "string": "Their main difference is that predicates have been beforehand indicated for the latter."}, {"id": 33, "string": "Figure 1: The Argument Labeling Model the arguments, and the most crucial contribution of full parsing is in the pruning stage."}, {"id": 34, "string": "In this paper, we propose a k-order argument pruning algorithm inspired by Zhao et al."}, {"id": 35, "string": "(2009b) ."}, {"id": 36, "string": "First of all, for node n and its descendant n d in a syntactic dependency tree, we define the order to be the distance between the two nodes, denoted as D(n, n d )."}, {"id": 37, "string": "Then we define k-order descendants of given node satisfying D(n, n d ) = k, and k-order traversal that visits each node from the given node to its descendant nodes within k-th order."}, {"id": 38, "string": "Note that the definition of k-order traversal is somewhat different from tree traversal in terminology."}, {"id": 39, "string": "A brief description of the proposed k-order pruning algorithm is given as follow."}, {"id": 40, "string": "Initially, we set a given predicate as the current node in a syntactic dependency tree."}, {"id": 41, "string": "Then, collect all its argument candidates by the strategy of k-order traversal."}, {"id": 42, "string": "Afterwards, reset the current node to its syntactic head and repeat the previous step till the root of the tree."}, {"id": 43, "string": "Finally, collect the root and stop."}, {"id": 44, "string": "The k-order argument algorithm is presented in Algorithm 1 in detail."}, {"id": 45, "string": "An example of a syntactic dependency tree for sentence She began to trade the art for money is shown in Figure 2 ."}, {"id": 46, "string": "The main reasons for applying the extended korder argument pruning algorithm are two-fold."}, {"id": 47, "string": "Algorithm 1 k-order argument pruning algorithm Input: A predicate p, the root node r given a syntactic dependency tree T , the order k Output: The set of argument candidates S 1: initialization set p as current node c, c = p 2: for each descendant n i of c in T do goto step 2 12: end if 13: return argument candidates set S First, previous standard pruning algorithm may hurt the argument coverage too much, even though indeed arguments usually tend to surround their predicate in a close distance."}, {"id": 48, "string": "As a sequence tagging model has been applied, it can effectively handle the imbalanced distribution between arguments and non-arguments, which is hardly tackled by early argument classification models that commonly adopt the standard pruning algorithm."}, {"id": 49, "string": "Second, the extended pruning algorithm provides a better trade-off between computational cost and performance by carefully tuning k. Word Representation We produce a predicate-specific word representation x i for each word w i , where i stands for the word position in an input sequence, following ."}, {"id": 50, "string": "However, we differ by (1) leveraging a predicate-specific indicator embedding, (2) using deeper refined representation, including character and dependency relation embeddings, and (3) applying recent advances in RNNs, such as highway connections (Srivastava et al., 2015) ."}, {"id": 51, "string": "In this work, word representation x i is the concatenation of four types of features: predicatespecific feature, character-level, word-level and linguistic features."}, {"id": 52, "string": "Unlike previous work, we leverage a predicate-specific indicator embedding x ie i rather than directly using a binary flag either 0 or 1."}, {"id": 53, "string": "At character level, we exploit convolutional neural network (CNN) with bidirectional LSTM (BiLSTM) to learn character embedding Figure 2 : An example of first-order, second-order and third-order argument pruning."}, {"id": 54, "string": "Shadow part indicates the given predicate."}, {"id": 55, "string": "x ce i ."}, {"id": 56, "string": "As shown in Figure 1 , the representation calculated by the CNN is fed as input to BiL-STM."}, {"id": 57, "string": "At word level, we use a randomly initialized word embedding x re i and a pre-trained word embedding x pe i ."}, {"id": 58, "string": "For linguistic features, we employ a randomly initialized lemma embedding x le i and a randomly initialized POS tag embedding x pos i ."}, {"id": 59, "string": "In order to incorporate more syntactic information, we adopt an additional feature, the dependency relation to syntactic head."}, {"id": 60, "string": "Likewise, it is a randomly initialized embedding x de i ."}, {"id": 61, "string": "The resulting word representation is concatenated as x i = [x ie i , x ce i , x re i , x pe i , x le i , x pos i , x de i ]."}, {"id": 62, "string": "Sequence Encoder As Long short-term memory (LSTM) networks (Hochreiter and Schmidhuber, 1997) have shown significant representational effectiveness to NLP tasks, we thus use BiLSTM as the sentence encorder."}, {"id": 63, "string": "Given an input sequence x = (x 1 , ."}, {"id": 64, "string": "."}, {"id": 65, "string": "."}, {"id": 66, "string": ", x n ), BiLSTM processes the sequence in both forward and backward direction to obtain two separated hidden states, \u2212 \u2192 h i which handles data from x 1 to x i and \u2190 \u2212 h i which tackles data from x n to x i for each word representation."}, {"id": 67, "string": "Finally, we get a contextual representation h i = [ \u2212 \u2192 h i , \u2190 \u2212 h i ] by concatenating the states of BiLSTM networks."}, {"id": 68, "string": "To get the final predicted semantic roles, we exploit a multi-layer perceptron (MLP) with highway connections on the top of BiLSTM networks, which takes as input the hidden representation h i of all time steps."}, {"id": 69, "string": "The MLP network consists of 10 layers with highway connections and we employ ReLU activations for the hidden layers."}, {"id": 70, "string": "Finally, we use a softmax layer over the outputs to maximize the likelihood of labels."}, {"id": 71, "string": "Predicate Disambiguation Although predicates have been identified given a sentence, predicate disambiguation is an indispensable task, which aims to determine the predicate-argument structure for an identified predicate in a particular context."}, {"id": 72, "string": "Here, we also use the identical model (BiLSTM composed with MLP) for predicate disambiguation, in which the only difference is that we remove the syntactic dependency relation feature in corresponding word representation (Section 2.2)."}, {"id": 73, "string": "Exactly, given a predicate p, the resulting word representation is p i = [p ie i , p ce i , p re i , p pe i , p le i , p pos i ]."}, {"id": 74, "string": "Experiments Our model 2 is evaluated on the CoNLL-2009 shared task both for English and Chinese datasets, following the standard training, development and test splits."}, {"id": 75, "string": "The hyperparameters in our model were selected based on the development set, and are summarized in Table 1 ."}, {"id": 76, "string": "Note that the parameters of predicate model are the same as these in argument model."}, {"id": 77, "string": "All real vectors are randomly initialized, and the pre-trained word embeddings for English are GloVe vectors (Pennington et al., 2014) ."}, {"id": 78, "string": "For Chinese, we exploit Wikipedia documents to train Word2Vec embeddings (Mikolov et al., 2013) ."}, {"id": 79, "string": "During training procedures, we use the categorical cross-entropy as objective, with Adam optimizer (Kingma and Ba, 2015) ."}, {"id": 80, "string": "We train models for a maximum of 20 epochs and obtain the nearly best model based on development results."}, {"id": 81, "string": "For argument labeling, we preprocess corpus with k-order argument pruning algorithm."}, {"id": 82, "string": "In addition, we use four CNN layers with singlelayer BiLSTM to induce character representations derived from sentences."}, {"id": 83, "string": "For English 3 , to further enhance the representation, we adopt CNN-BiLSTM character embedding structure from Al-lenNLP toolkit (Peters et al., 2018) ."}, {"id": 84, "string": "Preprocessing During the pruning of argument candidates, we use the officially predicted syntactic parses provided by CoNLL-2009 shared-task organizers on both English and Chinese."}, {"id": 85, "string": "Figure 3 shows changing curves of coverage and reduction following k on the English train set."}, {"id": 86, "string": "According to our statistics, the number of non-arguments is ten times more than that of arguments, where the data distribution is fairly unbalanced."}, {"id": 87, "string": "However, a proper pruning strategy could alleviate this problem."}, {"id": 88, "string": "Accordingly, the first-order pruning reduces more than 50% candidates at the cost of missing 5.5% true ones on average, and the second-order prunes about 40% candidates with nearly 2.0% loss."}, {"id": 89, "string": "The coverage of third-order has achieved 99% and it reduces approximately 1/3 corpus size."}, {"id": 90, "string": "It is worth noting that as k is larger than 19,  there will come full coverage on all argument candidates for English training set, which let our high order pruning algorithm degrade into a syntaxagnostic setting."}, {"id": 91, "string": "In this work, we use the tenthorder pruning for pursuing the best performance."}, {"id": 92, "string": "Results Our   with ensemble models, our single model even provides better performance (+0.4% F 1 ) than the system , and significantly surpasses all the rest models."}, {"id": 93, "string": "In the syntaxagnostic setting (without pruning and dependency relation embedding), we also reach the new stateof-the-art, achieving a performance gain of 1% F 1 ."}, {"id": 94, "string": "On the out-of-domain (Brown) test set, we achieve the new best results of 79.3% (syntaxaware) and 78.8% (syntax-agnostic) in F 1 scores."}, {"id": 95, "string": "Moreover, our syntax-aware model performs better than the syntax-agnostic one."}, {"id": 96, "string": "Table 4 presents the results on Chinese test set."}, {"id": 97, "string": "Even though we use the same parameters as for English, our model also outperforms the best reported results by 0.3% (syntax-aware) and 0.6% (syntax-agnostic) in F 1 scores."}, {"id": 98, "string": "Table 6 : Ablation on development set."}, {"id": 99, "string": "The \"+\" denotes a specific version over the basic model."}, {"id": 100, "string": "Analysis To evaluate the contributions of key factors in our method, a series of ablation studies are performed on the English development set."}, {"id": 101, "string": "In order to demonstrate the effectiveness of our k-order pruning algorithm, we report the SRL performance excluding predicate senses in evaluation, eliminating the performance gain from predicate disambiguation."}, {"id": 102, "string": "Table 5 shows the results from our syntax-aware model with lower order argument pruning."}, {"id": 103, "string": "Compared to the best previous model, our system still yields an increment in recall by more than 1%, leading to improvements in F 1 score."}, {"id": 104, "string": "It demonstrates that refining syntactic parser tree based candidate pruning does help in argument recognition."}, {"id": 105, "string": "Table 6 presents the performance of our syntaxagnostic SRL system with a basic configuration, which removes components, including indicator and character embeddings."}, {"id": 106, "string": "Note that the first row is the results of BiLSTM (removing MLP from basic model), whose encoding is the same as ."}, {"id": 107, "string": "Experiments show that both enhanced representations improve over our basic model, and our adopted labeling model is superior to the simple BiLSTM."}, {"id": 108, "string": "Figure 4 shows F 1 scores in different k-order pruning together with our syntax-agnostic model."}, {"id": 109, "string": "It also indicates that the least first-order pruning fails to give satisfactory performance, the best performing setting coming from a moderate setting of k = 10, and the largest k shows that our argu- ment pruning falls back to syntax-agnostic type."}, {"id": 110, "string": "Meanwhile, from the best k setting to the lower order pruning, we receive a much faster performance drop, compared to the higher order pruning until the complete syntax-agnostic case."}, {"id": 111, "string": "The proposed k-order pruning algorithm always works even it reaches the syntax-agnostic setting, which empirically explains why the current syntax-aware and syntax-agnostic SRL models hold little performance difference, as maximum k-order pruning actually removes few words just like syntaxagnostic model."}, {"id": 112, "string": "End-to-end SRL In this work, we consider additional model that integrates predicate disambiguation and argument labeling into one sequence labeling model."}, {"id": 113, "string": "In order to implement an end-to-end model, we introduce a virtual root (VR) for predicate disambiguation similar to Zhao et al."}, {"id": 114, "string": "(2013) who handled the entire SRL task as word pair classification."}, {"id": 115, "string": "Concretely, we add a predicate sense feature to the input sequence by concatenating a VR."}, {"id": 116, "string": "The word representation of VR is randomly initialized during training."}, {"id": 117, "string": "In Figure 5 , we give an example sequence with the labels for the given sentence."}, {"id": 118, "string": "We also report results of our end-to-end model on CoNLL-2009 test set with syntax-aware and syntax-agnostic settings."}, {"id": 119, "string": "As shown in Table 7 , our end-to-end model yields slightly weaker performance compared with our pipeline."}, {"id": 120, "string": "A reasonable account for performance degradation is that the training data has completely different genre distributions over predicate senses and argument roles, which may be somewhat confusing for integrative model to make classification decisions."}, {"id": 121, "string": "Figure 5 : An example sequence with labels of endto-end model (makes is the given predicate)."}, {"id": 122, "string": "Our system P R F 1 syntax-aware (end-to-end) 89.3 88.7 89.0 syntax-aware (pipeline) 89.7 89.3 89.5 syntax-agnostic (end-to-end) 88.9 87.9 88.4 syntax-agnostic (pipeline) 89.5 87.9 88.7 Table 7 : Comparison of results on CoNLL-2009 data between our end-to-end and pipeline models."}, {"id": 123, "string": "CoNLL-2008 SRL Setting For a full SRL task, the predicate identification subtask is also indispensable, which has been included in CoNLL-2008 shared task."}, {"id": 124, "string": "We thus evaluate our model in terms of data and setting of the CoNLL-2008 benchmark (WSJ)."}, {"id": 125, "string": "To identify predicates, we train the BiLSTM-MLP sequence labeling model with same parameters in Section 2.4 to tackle the predicate identification and disambiguation subtasks in one shot, and the only difference is that we remove the predicate-specific indicator feature."}, {"id": 126, "string": "The F 1 score of our predicate labeling model is 90.53% on indomain (WSJ) data."}, {"id": 127, "string": "Compared with the best reported results, we observe absolute improvements in semantic F 1 of 0.8% (in Table 8 )."}, {"id": 128, "string": "Note that as predicate identification is introduced, our same model shows about 6% performance loss for either syntax-agnostic or syntax-aware case, which indicates that predicate identification should be carefully handled, as it is very needed in a complete practical SRL system."}, {"id": 129, "string": "Syntactic Contribution Syntactic information plays an informative role in semantic role labeling."}, {"id": 130, "string": "However, few studies were done to quantitatively evaluate the syntactic contribution to SRL."}, {"id": 131, "string": "Furthermore, we observe that most of the above compared neural SRL systems took the syntactic parser of (Bj\u00f6rkelund et al., 2010) as syntactic inputs instead of the one from CoNLL-2009 shared task, which adopted a much weaker syntactic parser."}, {"id": 132, "string": "Especially , adopted an external syntactic System LAS Sem-F 1 Johansson and Nugues (2008) 90.13 81.75 Zhao and Kit (2008) 87.52 77.67 Zhao et al."}, {"id": 133, "string": "(2009b) 88.39 82.1 (80.53) 89.28 82.5 (80.94) Zhao et al."}, {"id": 134, "string": "(2013) 88.39 82.5 (80.91) 89.28 82.4 (80.88) Ours (syntax-agnostic) \u2212 82.9 Ours (syntax-aware) 86.0 83.3 parser with even higher parsing accuracy."}, {"id": 135, "string": "Contrarily, our SRL model is based on the automatically predicted parse with moderate performance provided by CoNLL-2009 shared task, but outperforms their models."}, {"id": 136, "string": "This section thus attempts to explore how much syntax contributes to dependency-based SRL in deep learning framework and how to effectively evaluate relative performance of syntax-based SRL."}, {"id": 137, "string": "To this end, we conduct experiments for empirical analysis with different syntactic inputs."}, {"id": 138, "string": "Syntactic Input In order to obtain different syntactic inputs, we design a faulty syntactic tree generator (refer to STG hereafter), which is able to produce random errors in the output parse tree like a true parser does."}, {"id": 139, "string": "To simplify implementation, we construct a new syntactic tree based on the gold standard parse tree."}, {"id": 140, "string": "Given an input error probability distribution estimated from a true parser output, our algorithm presented in Algorithm 2 stochastically modifies the syntactic heads of nodes on the premise of a valid tree."}, {"id": 141, "string": "Evaluation Measure For SRL task, the primary evaluation measure is the semantic labeled F 1 score."}, {"id": 142, "string": "However, the score is influenced by the quality of syntactic input to some extent, leading to unfaithfully reflecting the competence of syntax-based SRL system."}, {"id": 143, "string": "Namely, this is not the outcome of a true and fair quantitative comparison for these types of SRL models."}, {"id": 144, "string": "To normalize the semantic score relative to syntactic parse, we take into account additional evaluation measure to estimate the actual overall performance of SRL."}, {"id": 145, "string": "Here, we use the ratio between labeled F 1 score for semantic dependencies (Sem-F 1 ) and the labeled attachment score (LAS) for syntactic dependencies System LAS (%) P (%) R (%) Sem-F 1 (%) Sem-F 1 /LAS (%) Zhao et al."}, {"id": 146, "string": "(2009c) Table 9 : Results on English test set, in terms of labeled attachment score for syntactic dependencies (LAS), semantic precision (P), semantic recall (R), semantic labeled F 1 score (Sem-F 1 ), the ratio Sem-F 1 /LAS."}, {"id": 147, "string": "A superscript * indicates LAS results from our personal communication with the authors."}, {"id": 148, "string": "Algorithm 2 Faulty Syntactic Tree Generator Input: A gold standard syntactic tree GT , the specific error probability p Output: The new generative syntactic tree N T 1: N denotes the number of nodes in GT 2: for each node n \u2208 GT do end if 14: end for 15: return the new generative tree N T proposed by Surdeanu et al."}, {"id": 149, "string": "(2008) as evaluation metric."}, {"id": 150, "string": "6 The benefits of this measure are twofold: quantitatively evaluating syntactic contribution to SRL and impartially estimating the true performance of SRL, independent of the performance of the input syntactic parser."}, {"id": 151, "string": "Table 9 reports the performance of existing models 7 in term of Sem-F 1 /LAS ratio on CoNLL-2009 English test set."}, {"id": 152, "string": "Interestingly, even though our system has significantly lower scores than others by 3.8% LAS in syntactic components, we 6 The idea of ratio score in Surdeanu et al."}, {"id": 153, "string": "(2008) actually was from author of this paper, Hai Zhao, which has been indicated in the acknowledgement part of Surdeanu et al."}, {"id": 154, "string": "(2008) ."}, {"id": 155, "string": "7 Note that several SRL systems without providing syntactic information are not listed in the table."}, {"id": 156, "string": "1st-order SRL 10th-order SRL GCNs Figure 6 : The Sem-F 1 scores of our models with different quality of syntactic inputs vs. GCNs  on test set."}, {"id": 157, "string": "obtain the highest results both on Sem-F 1 and the Sem-F 1 /LAS ratio, respectively."}, {"id": 158, "string": "These results show that our SRL component is relatively much stronger."}, {"id": 159, "string": "Moreover, the ratio comparison in Table  9 also shows that since the CoNLL-2009 shared task, most SRL works actually benefit from the enhanced syntactic component rather than the improved SRL component itself."}, {"id": 160, "string": "All post-CoNLL SRL systems, either traditional or neural types, did not exceed the top systems of CoNLL-2009 shared task, (Zhao et al., 2009c ) (SRL-only track using the provided predicated syntax) and (Zhao et al., 2009a) (Joint track using self-developed parser)."}, {"id": 161, "string": "We believe that this work for the first time reports both higher Sem-F 1 and higher Sem-F 1 /LAS ratio since CoNLL-2009 shared task."}, {"id": 162, "string": "We also perform our first and tenth order pruning models with different erroneous syntactic inputs generated from STG and evaluate their per-formance using the Sem-F 1 /LAS ratio."}, {"id": 163, "string": "Figure 6 shows Sem-F 1 scores at different quality of syntactic parse inputs on the English test set whose LAS varies from 85% to 100%."}, {"id": 164, "string": "Compared to previous state-of-the-arts ."}, {"id": 165, "string": "Our tenth-order pruning model gives quite stable SRL performance no matter the syntactic input quality varies in a broad range, while our firstorder pruning model yields overall lower results (1-5% F 1 drop), owing to missing too many true arguments."}, {"id": 166, "string": "These results show that high-quality syntactic parses may indeed enhance dependency SRL."}, {"id": 167, "string": "Furthermore, it indicates that our model with an accurate enough syntactic input as Marcheggiani and Titov (2017), namely, 90% LAS, will give a Sem-F 1 exceeding 90% for the first time in the research timeline of semantic role labeling."}, {"id": 168, "string": "Related Work Semantic role labeling was pioneered by Gildea and Jurafsky (2002) ."}, {"id": 169, "string": "Most traditional SRL models rely heavily on feature templates (Pradhan et al., 2005; Zhao et al., 2009b; Bj\u00f6rkelund et al., 2009 )."}, {"id": 170, "string": "Among them, Pradhan et al."}, {"id": 171, "string": "(2005) combined features derived from different syntactic parses based on SVM classifier, while Zhao et al."}, {"id": 172, "string": "(2009b) presented an integrative approach for dependency SRL by greedy feature selection algorithm."}, {"id": 173, "string": "Later, Collobert et al."}, {"id": 174, "string": "(2011) proposed a convolutional neural network model of inducing word embeddings substituting for hand-crafted features, which was a breakthrough for SRL task."}, {"id": 175, "string": "With the impressive success of deep neural networks in various NLP tasks (Zhang et al., 2016; Qin et al., 2017; Cai et al., 2017) , a series of neural SRL systems have been proposed."}, {"id": 176, "string": "Foland and Martin (2015) presented a dependency semantic role labeler using convolutional and time-domain neural networks, while FitzGerald et al."}, {"id": 177, "string": "(2015) exploited neural network to jointly embed arguments and semantic roles, akin to the work (Lei et al., 2015) , which induced a compact feature representation applying tensor-based approach."}, {"id": 178, "string": "Recently, researchers consider multiple ways to effectively integrate syntax into SRL learning."}, {"id": 179, "string": "Roth and Lapata (2016) introduced dependency path embedding to model syntactic information and exhibited a notable success."}, {"id": 180, "string": "leveraged the graph convolutional network to incorporate syntax into neural models."}, {"id": 181, "string": "Differently,  proposed a syntax-agnostic model using effective word representation for dependency SRL, which for the first time achieves comparable performance as stateof-the-art syntax-aware SRL models."}, {"id": 182, "string": "However, most neural SRL works seldom pay much attention to the impact of input syntactic parse over the resulting SRL performance."}, {"id": 183, "string": "This work is thus more than proposing a high performance SRL model through reviewing the highlights of previous models, and presenting an effective syntactic tree based argument pruning."}, {"id": 184, "string": "Our work is also closely related to (Punyakanok et al., 2008; He et al., 2017) ."}, {"id": 185, "string": "Under the traditional methods, Punyakanok et al."}, {"id": 186, "string": "(2008) investigated the significance of syntax to SRL system and shown syntactic information most crucial in the pruning stage."}, {"id": 187, "string": "He et al."}, {"id": 188, "string": "(2017) presented extensive error analysis with deep learning model for span SRL, including discussion of how constituent syntactic parser could be used to improve SRL performance."}, {"id": 189, "string": "Conclusion and Future Work This paper presents a simple and effective neural model for dependency-based SRL, incorporating syntactic information with the proposed extended k-order pruning algorithm."}, {"id": 190, "string": "With a large enough setting of k, our pruning algorithm will result in a syntax-agnostic setting for the argument labeling model, which smoothly unifies syntax-aware and syntax-agnostic SRL in a consistent way."}, {"id": 191, "string": "Experimental results show that with the help of deep enhanced representation, our model outperforms the previous state-of-the-art models in both syntaxaware and syntax-agnostic situations."}, {"id": 192, "string": "In addition, we consider the Sem-F1/LAS ratio as a mean of evaluating syntactic contribution to SRL, and true performance of SRL independent of the quality of syntactic parser."}, {"id": 193, "string": "Though we again confirm the importance of syntax to SRL with empirical experiments, we are aware that since (Pradhan et al., 2005) , the gap between syntax-aware and syntax-agnostic SRL has been greatly reduced, from as high as 10% to only 1-2% performance loss in this work."}, {"id": 194, "string": "However, maybe we will never reach a satisfying conclusion, as whenever one proposes a syntax-agnostic SRL system which can outperform all syntax-aware ones at then, always there comes argument that you have never fully explored creative new method to effectively exploit the syntax input."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 16}, {"section": "Model", "n": "2", "start": 17, "end": 29}, {"section": "Argument Pruning", "n": "2.1", "start": 30, "end": 48}, {"section": "Word Representation", "n": "2.2", "start": 49, "end": 61}, {"section": "Sequence Encoder", "n": "2.3", "start": 62, "end": 70}, {"section": "Predicate Disambiguation", "n": "2.4", "start": 71, "end": 73}, {"section": "Experiments", "n": "3", "start": 74, "end": 83}, {"section": "Preprocessing", "n": "3.1", "start": 84, "end": 91}, {"section": "Results", "n": "3.2", "start": 92, "end": 99}, {"section": "Analysis", "n": "3.3", "start": 100, "end": 111}, {"section": "End-to-end SRL", "n": "3.4", "start": 112, "end": 122}, {"section": "CoNLL-2008 SRL Setting", "n": "3.5", "start": 123, "end": 128}, {"section": "Syntactic Contribution", "n": "4", "start": 129, "end": 167}, {"section": "Related Work", "n": "5", "start": 168, "end": 188}, {"section": "Conclusion and Future Work", "n": "6", "start": 189, "end": 194}], "figures": [{"filename": "../figure/image/1057-Table6-1.png", "caption": "Table 6: Ablation on development set. The \u201c+\u201d denotes a specific version over the basic model.", "page": 5, "bbox": {"x1": 76.8, "x2": 283.2, "y1": 172.79999999999998, "y2": 271.2}}, {"filename": "../figure/image/1057-Figure4-1.png", "caption": "Figure 4: F1 scores by k-order pruning and the syntax-agnostic result on English development set.", "page": 5, "bbox": {"x1": 312.47999999999996, "x2": 517.4399999999999, "y1": 64.8, "y2": 217.44}}, {"filename": "../figure/image/1057-Table5-1.png", "caption": "Table 5: SRL results without predicate sense.", "page": 5, "bbox": {"x1": 72.0, "x2": 290.4, "y1": 62.879999999999995, "y2": 132.96}}, {"filename": "../figure/image/1057-Figure1-1.png", "caption": "Figure 1: The Argument Labeling Model", "page": 1, "bbox": {"x1": 307.68, "x2": 538.56, "y1": 63.839999999999996, "y2": 328.32}}, {"filename": "../figure/image/1057-Table7-1.png", "caption": "Table 7: Comparison of results on CoNLL-2009 data between our end-to-end and pipeline models.", "page": 6, "bbox": {"x1": 75.84, "x2": 284.15999999999997, "y1": 168.48, "y2": 239.04}}, {"filename": "../figure/image/1057-Figure5-1.png", "caption": "Figure 5: An example sequence with labels of endto-end model (makes is the given predicate).", "page": 6, "bbox": {"x1": 84.96, "x2": 273.59999999999997, "y1": 62.879999999999995, "y2": 115.67999999999999}}, {"filename": "../figure/image/1057-Table8-1.png", "caption": "Table 8: Results on the CoNLL-2008 in-domain (WSJ) test set. The results in parenthesis are on WSJ + Brown test set.", "page": 6, "bbox": {"x1": 306.71999999999997, "x2": 535.1999999999999, "y1": 62.879999999999995, "y2": 188.16}}, {"filename": "../figure/image/1057-Figure2-1.png", "caption": "Figure 2: An example of first-order, second-order and third-order argument pruning. Shadow part indicates the given predicate.", "page": 2, "bbox": {"x1": 344.64, "x2": 485.28, "y1": 63.839999999999996, "y2": 261.12}}, {"filename": "../figure/image/1057-Figure6-1.png", "caption": "Figure 6: The Sem-F1 scores of our models with different quality of syntactic inputs vs. GCNs (Marcheggiani and Titov, 2017) on test set.", "page": 7, "bbox": {"x1": 313.44, "x2": 516.0, "y1": 270.71999999999997, "y2": 421.44}}, {"filename": "../figure/image/1057-Table9-1.png", "caption": "Table 9: Results on English test set, in terms of labeled attachment score for syntactic dependencies (LAS), semantic precision (P), semantic recall (R), semantic labeled F1 score (Sem-F1), the ratio SemF1/LAS. A superscript * indicates LAS results from our personal communication with the authors.", "page": 7, "bbox": {"x1": 81.6, "x2": 512.16, "y1": 62.879999999999995, "y2": 202.07999999999998}}, {"filename": "../figure/image/1057-Table1-1.png", "caption": "Table 1: Hyperparameter values.", "page": 3, "bbox": {"x1": 77.75999999999999, "x2": 282.24, "y1": 62.879999999999995, "y2": 240.95999999999998}}, {"filename": "../figure/image/1057-Figure3-1.png", "caption": "Figure 3: Changing curves of coverage and reduction with different k value on English training set. The coverage rate is the proportion of true arguments in pruning output, while the reduction is the one of pruned argument candidates in total tokens.", "page": 3, "bbox": {"x1": 318.24, "x2": 510.24, "y1": 64.8, "y2": 204.95999999999998}}, {"filename": "../figure/image/1057-Table4-1.png", "caption": "Table 4: Results on the Chinese test set.", "page": 4, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 355.68, "y2": 486.24}}, {"filename": "../figure/image/1057-Table2-1.png", "caption": "Table 2: Results on the English test set (WSJ).", "page": 4, "bbox": {"x1": 72.0, "x2": 290.4, "y1": 62.879999999999995, "y2": 301.92}}, {"filename": "../figure/image/1057-Table3-1.png", "caption": "Table 3: Results on English out-of-domain test set (Brown).", "page": 4, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 62.879999999999995, "y2": 301.92}}]}