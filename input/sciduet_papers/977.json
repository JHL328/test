{"title": "Token-level and sequence-level loss smoothing for RNN language models", "abstract": "Despite the effectiveness of recurrent neural network language models, their maximum likelihood estimation suffers from two limitations. It treats all sentences that do not match the ground truth as equally poor, ignoring the structure of the output space. Second, it suffers from \"exposure bias\": during training tokens are predicted given ground-truth sequences, while at test time prediction is conditioned on generated output sequences. To overcome these limitations we build upon the recent reward augmented maximum likelihood approach i.e. sequence-level smoothing that encourages the model to predict sentences close to the ground truth according to a given performance metric. We extend this approach to token-level loss smoothing, and propose improvements to the sequence-level smoothing approach. Our experiments on two different tasks, image captioning and machine translation, show that token-level and sequence-level loss smoothing are complementary, and significantly improve results.", "text": [{"id": 0, "string": "Introduction Recurrent neural networks (RNNs) have recently proven to be very effective sequence modeling tools, and are now state of the art for tasks such as machine translation , image captioning (Kiros et al., 2014; Anderson et al., 2017) and automatic speech recognition (Chorowski et al., 2015; Chiu et al., 2017) ."}, {"id": 1, "string": "The basic principle of RNNs is to iteratively compute a vectorial sequence representation, by applying at each time-step the same trainable func-tion to compute the new network state from the previous state and the last symbol in the sequence."}, {"id": 2, "string": "These models are typically trained by maximizing the likelihood of the target sentence given an encoded source (text, image, speech) ."}, {"id": 3, "string": "Maximum likelihood estimation (MLE), however, has two main limitations."}, {"id": 4, "string": "First, the training signal only differentiates the ground-truth target output from all other outputs."}, {"id": 5, "string": "It treats all other output sequences as equally incorrect, regardless of their semantic proximity from the ground-truth target."}, {"id": 6, "string": "While such a \"zero-one\" loss is probably acceptable for coarse grained classification of images, e.g."}, {"id": 7, "string": "across a limited number of basic object categories (Everingham et al., 2010) it becomes problematic as the output space becomes larger and some of its elements become semantically similar to each other."}, {"id": 8, "string": "This is in particular the case for tasks that involve natural language generation (captioning, translation, speech recognition) where the number of possible outputs is practically unbounded."}, {"id": 9, "string": "For natural language generation tasks, evaluation measures typically do take into account structural similarity, e.g."}, {"id": 10, "string": "based on n-grams, but such structural information is not reflected in the MLE criterion."}, {"id": 11, "string": "The second limitation of MLE is that training is based on predicting the next token given the input and preceding ground-truth output tokens, while at test time the model predicts conditioned on the input and the so-far generated output sequence."}, {"id": 12, "string": "Given the exponentially large output space of natural language sentences, it is not obvious that the learned RNNs generalize well beyond the relatively sparse distribution of ground-truth sequences used during MLE optimization."}, {"id": 13, "string": "This phenomenon is known as \"exposure bias\" (Ranzato et al., 2016; ."}, {"id": 14, "string": "MLE minimizes the KL divergence between a target Dirac distribution on the ground-truth sentence(s) and the model's distribution."}, {"id": 15, "string": "In this pa-per, we build upon the \"loss smoothing\" approach by Norouzi et al."}, {"id": 16, "string": "(2016) , which smooths the Dirac target distribution over similar sentences, increasing the support of the training data in the output space."}, {"id": 17, "string": "We make the following main contributions: \u2022 We propose a token-level loss smoothing approach, using word-embeddings, to achieve smoothing among semantically similar terms, and we introduce a special procedure to promote rare tokens."}, {"id": 18, "string": "\u2022 For sequence-level smoothing, we propose to use restricted token replacement vocabularies, and a \"lazy evaluation\" method that significantly speeds up training."}, {"id": 19, "string": "\u2022 We experimentally validate our approach on the MSCOCO image captioning task and the WMT'14 English to French machine translation task, showing that on both tasks combining token-level and sequence-level loss smoothing improves results significantly over maximum likelihood baselines."}, {"id": 20, "string": "In the remainder of the paper, we review the existing methods to improve RNN training in Section 2."}, {"id": 21, "string": "Then, we present our token-level and sequence-level approaches in Section 3."}, {"id": 22, "string": "Experimental evaluation results based on image captioning and machine translation tasks are laid out in Section 4."}, {"id": 23, "string": "Related work Previous work aiming to improve the generalization performance of RNNs can be roughly divided into three categories: those based on regularization, data augmentation, and alternatives to maximum likelihood estimation."}, {"id": 24, "string": "Regularization techniques are used to increase the smoothness of the function learned by the network, e.g."}, {"id": 25, "string": "by imposing an 2 penalty on the network weights, also known as \"weight decay\"."}, {"id": 26, "string": "More recent approaches mask network activations during training, as in dropout (Srivastava et al., 2014) and its variants adapted to recurrent models (Pham et al., 2014; Krueger et al., 2017) ."}, {"id": 27, "string": "Instead of masking, batch-normalization (Ioffe and Szegedy, 2015) rescales the network activations to avoid saturating the network's non-linearities."}, {"id": 28, "string": "Instead of regularizing the network parameters or activations, it is also possible to directly regularize based on the entropy of the output distribution (Pereyra et al., 2017) ."}, {"id": 29, "string": "Data augmentation techniques improve the ro-bustness of the learned models by applying transformations that might be encountered at test time to the training data."}, {"id": 30, "string": "In computer vision, this is common practice, and implemented by, e.g., scaling, cropping, and rotating training images (Le-Cun et al., 1998; Krizhevsky et al., 2012; Paulin et al., 2014) ."}, {"id": 31, "string": "In natural language processing, examples of data augmentation include input noising by randomly dropping some input tokens (Iyyer et al., 2015; Bowman et al., 2015; Kumar et al., 2016) , and randomly replacing words with substitutes sampled from the model ."}, {"id": 32, "string": "Xie et al."}, {"id": 33, "string": "(2017) introduced data augmentation schemes for RNN language models that leverage n-gram statistics in order to mimic Kneser-Ney smoothing of n-grams models."}, {"id": 34, "string": "In the context of machine translation, Fadaee et al."}, {"id": 35, "string": "(2017) modify sentences by replacing words with rare ones when this is plausible according to a pretrained language model, and substitutes its equivalent in the target sentence using automatic word alignments."}, {"id": 36, "string": "This approach, however, relies on the availability of additional monolingual data for language model training."}, {"id": 37, "string": "The de facto standard way to train RNN language models is maximum likelihood estimation (MLE) ."}, {"id": 38, "string": "The sequential factorization of the sequence likelihood generates an additive structure in the loss, with one term corresponding to the prediction of each output token given the input and the preceding ground-truth output tokens."}, {"id": 39, "string": "In order to directly optimize for sequence-level structured loss functions, such as measures based on n-grams like BLEU or CIDER, Ranzato et al."}, {"id": 40, "string": "(2016) use reinforcement learning techniques that optimize the expectation of a sequence-level reward."}, {"id": 41, "string": "In order to avoid early convergence to poor local optima, they pre-train the model using MLE."}, {"id": 42, "string": "Leblond et al."}, {"id": 43, "string": "(2018) build on the learning to search approach to structured prediction (Daum\u00e9 III et al., 2009; Chang et al., 2015) and adapts it to RNN training."}, {"id": 44, "string": "The model generates candidate sequences at each time-step using all possible tokens, and scores these at sequence-level to derive a training signal for each time step."}, {"id": 45, "string": "This leads to an approach that is structurally close to MLE, but computationally expensive."}, {"id": 46, "string": "Norouzi et al."}, {"id": 47, "string": "(2016) introduce a reward augmented maximum likelihood (RAML) approach, that incorpo-rates a notion of sequence-level reward without facing the difficulties of reinforcement learning."}, {"id": 48, "string": "They define a target distribution over output sentences using a soft-max over the reward over all possible outputs."}, {"id": 49, "string": "Then, they minimize the KL divergence between the target distribution and the model's output distribution."}, {"id": 50, "string": "Training with a general reward distribution is similar to MLE training, except that we use multiple sentences sampled from the target distribution instead of only the ground-truth sentences."}, {"id": 51, "string": "In our work, we build upon the work of Norouzi et al."}, {"id": 52, "string": "(2016) by proposing improvements to sequence-level smoothing, and extending it to token-level smoothing."}, {"id": 53, "string": "Our token-level smoothing approach is related to the label smoothing approach of Szegedy et al."}, {"id": 54, "string": "(2016) for image classification."}, {"id": 55, "string": "Instead of maximizing the probability of the correct class, they train the model to predict the correct class with a large probability and all other classes with a small uniform probability."}, {"id": 56, "string": "This regularizes the model by preventing overconfident predictions."}, {"id": 57, "string": "In natural language generation with large vocabularies, preventing such \"narrow\" over-confident distributions is imperative, since for many tokens there are nearly interchangeable alternatives."}, {"id": 58, "string": "Loss smoothing for RNN training We briefly recall standard recurrent neural network training, before presenting sequence-level and token-level loss smoothing below."}, {"id": 59, "string": "Maximum likelihood RNN training We are interested in modeling the conditional probability of a sequence y = (y 1 , ."}, {"id": 60, "string": "."}, {"id": 61, "string": "."}, {"id": 62, "string": ", y T ) given a conditioning observation x, p \u03b8 (y|x) = T t=1 p \u03b8 (y t |x, y <t ), (1) where y <t = (y 1 , ."}, {"id": 63, "string": "."}, {"id": 64, "string": "."}, {"id": 65, "string": ", y t\u22121 ), the model parameters are given by \u03b8, and x is a source sentence or an image in the contexts of machine translation and image captioning, respectively."}, {"id": 66, "string": "In a recurrent neural network, the sequence y is predicted based on a sequence of states h t , p \u03b8 (y t |x, y <t ) = p \u03b8 (y t |h t ), (2) where the RNN state is computed recursively as h t = f \u03b8 (h t\u22121 , y t\u22121 , x) for t \u2208 {1, ..T }, g \u03b8 (x) for t = 0."}, {"id": 67, "string": "(3) The input is encoded by g \u03b8 and used to initialize the state sequence, and f \u03b8 is a non-linear function that updates the state given the previous state h t\u22121 , the last output token y t\u22121 , and possibly the input x."}, {"id": 68, "string": "The state update function can take different forms, the ones including gating mechanisms such as LSTMs (Hochreiter and Schmidhuber, 1997) and GRUs (Chung et al., 2014) are particularly effective to model long sequences."}, {"id": 69, "string": "In standard teacher-forced training, the hidden states will be computed by forwarding the ground truth sequence y * i.e."}, {"id": 70, "string": "in Eq."}, {"id": 71, "string": "(3) , the RNN has access to the true previous token y * t\u22121 ."}, {"id": 72, "string": "In this case we will note the hidden states h * t ."}, {"id": 73, "string": "Given a ground-truth target sequence y * , maximum likelihood estimation (MLE) of the network parameters \u03b8 amounts to minimizing the loss MLE (y * , x) = \u2212 ln p \u03b8 (y * |x) (4) = \u2212 T t=1 ln p \u03b8 (y * t |h * t )."}, {"id": 74, "string": "(5) The loss can equivalently be expressed as the KLdivergence between a Dirac centered on the target output (with \u03b4 a (x) = 1 at x = a and 0 otherwise) and the model distribution, either at the sequencelevel or at the token-level: MLE (y * , x) = D KL \u03b4 y * ||p \u03b8 (y|x) (6) = T t=1 D KL \u03b4 y * t ||p \u03b8 (y t |h * t ) ."}, {"id": 75, "string": "(7) Loss smoothing approaches considered in this paper consist in replacing the Dirac on the groundtruth sequence with distributions with larger support."}, {"id": 76, "string": "These distributions can be designed in such a manner that they reflect which deviations from ground-truth predictions are preferred over others."}, {"id": 77, "string": "Sequence-level loss smoothing The reward augmented maximum likelihood approach of Norouzi et al."}, {"id": 78, "string": "(2016) consists in replacing the sequence-level Dirac \u03b4 y * in Eq."}, {"id": 79, "string": "(6) with a distribution r(y|y * ) \u221d exp r(y, y * )/\u03c4, where r(y, y * ) is a \"reward\" function that measures the quality of sequence y w.r.t."}, {"id": 80, "string": "y * , e.g."}, {"id": 81, "string": "metrics used for evaluation of natural language processing tasks can be used, such as BLEU (Papineni et al., 2002) or CIDER (Vedantam et al., 2015) ."}, {"id": 82, "string": "The temperature parameter \u03c4 controls the concentration of the distribution around y * ."}, {"id": 83, "string": "When m > 1 ground-truth sequences are paired with the same input x, the reward function can be adapted to fit this setting and be defined as r(y, {y * (1) , ."}, {"id": 84, "string": "."}, {"id": 85, "string": "."}, {"id": 86, "string": ", y * (m) })."}, {"id": 87, "string": "The sequence-level smoothed loss function is then given by Seq (y * , x) = D KL r(y|y * )||p \u03b8 (y|x) = H(r(y|y * )) \u2212 E r [ln p \u03b8 (y|x)] , (9) where the entropy term H(r(y|y * )) does not depend on the model parameters \u03b8."}, {"id": 88, "string": "In general, expectation in Eq."}, {"id": 89, "string": "(9) is intractable due to the exponentially large output space, and replaced with a Monte-Carlo approximation: E r [\u2212 ln p \u03b8 (y|x)] \u2248 \u2212 L l=1 ln p \u03b8 (y l |x)."}, {"id": 90, "string": "(10) Stratified sampling."}, {"id": 91, "string": "Norouzi et al."}, {"id": 92, "string": "(2016) show that when using the Hamming or edit distance as a reward, we can sample directly from r(y|y * ) using a stratified sampling approach."}, {"id": 93, "string": "In this case sampling proceeds in three stages."}, {"id": 94, "string": "(i) Sample a distance d from {0, ."}, {"id": 95, "string": "."}, {"id": 96, "string": "."}, {"id": 97, "string": ", T } from a prior distribution on d. (ii) Uniformly select d positions in the sequence to be modified."}, {"id": 98, "string": "(iii) Sample the d substitutions uniformly from the token vocabulary."}, {"id": 99, "string": "Details on the construction of the prior distribution on d for a reward based on the Hamming distance can be found in Appendix A."}, {"id": 100, "string": "Importance sampling."}, {"id": 101, "string": "For a reward based on BLEU or CIDER , we cannot directly sample from r(y|y * ) since the normalizing constant, or \"partition function\", of the distribution is intractable to compute."}, {"id": 102, "string": "In this case we can resort to importance sampling."}, {"id": 103, "string": "We first sample L sequences y l from a tractable proposal distribution q(y|y * )."}, {"id": 104, "string": "We then compute the importance weights \u03c9 l \u2248 r(y l |y * )/q(y l |y * ) L k=1 r(y k |y * )/q(y k |y * ) , (11) where r(y k |y * ) is the un-normalized reward distribution in Eq."}, {"id": 105, "string": "(8)."}, {"id": 106, "string": "We finally approximate the expectation by reweighing the samples in the Monte Carlo approximation as E r [\u2212 ln p \u03b8 (y|x)] \u2248 \u2212 L l=1 \u03c9 l ln p \u03b8 (y l |x)."}, {"id": 107, "string": "(12) In our experiments we use a proposal distribution based on the Hamming distance, which allows for tractable stratified sampling, and generates sentences that do not stray away from the ground truth."}, {"id": 108, "string": "We propose two modifications to the sequencelevel loss smoothing of Norouzi et al."}, {"id": 109, "string": "(2016) : sampling to a restricted vocabulary (described in the following paragraph) and lazy sequence-level smoothing (described in section 3.4)."}, {"id": 110, "string": "Restricted vocabulary sampling."}, {"id": 111, "string": "In the stratified sampling method for Hamming and edit distance rewards, instead of drawing from the large vocabulary V, containing typically in the order of 10 4 words or more, we can restrict ourselves to a smaller subset V sub more adapted to our task."}, {"id": 112, "string": "We considered three different possibilities for V sub ."}, {"id": 113, "string": "V : the full vocabulary from which we sample uniformly (default), or draw from our token-level smoothing distribution defined below in Eq."}, {"id": 114, "string": "(13) ."}, {"id": 115, "string": "V ref s : uniformly sample from the set of tokens that appear in the ground-truth sentence(s) associated with the current input."}, {"id": 116, "string": "V batch : uniformly sample from the tokens that appear in the ground-truth sentences across all inputs that appear in a given training mini-batch."}, {"id": 117, "string": "Uniformly sampling from V batch has the effect of boosting the frequencies of words that appear in many reference sentences, and thus approximates to some extent sampling substitutions from the uni-gram statistics of the training set."}, {"id": 118, "string": "Token-level loss smoothing While the sequence-level smoothing can be directly based on performance measures of interest such as BLEU or CIDEr, the support of the smoothed distribution is limited to the number of samples drawn during training."}, {"id": 119, "string": "We propose smoothing the token-level Diracs \u03b4 y * t in Eq."}, {"id": 120, "string": "(7) to increase its support to similar tokens."}, {"id": 121, "string": "Since we apply smoothing to each of the tokens independently, this approach implicitly increases the support to an exponential number of sequences, unlike the sequence-level smoothing approach."}, {"id": 122, "string": "This comes at the price, however, of a naive token-level independence assumption in the smoothing."}, {"id": 123, "string": "We define the smoothed token-level distribution, similar as the sequence-level one, as a softmax over a token-level \"reward\" function, r(y t |y * where \u03c4 is again a temperature parameter."}, {"id": 124, "string": "As a token-level reward r(y t , y * t ) we use the cosine similarity between y t and y * t in a semantic wordembedding space."}, {"id": 125, "string": "In our experiments we use GloVe (Pennington et al., 2014) ; preliminary experiments with word2vec (Mikolov et al., 2013) yielded somewhat worse results."}, {"id": 126, "string": "Promoting rare tokens."}, {"id": 127, "string": "We can further improve the token-level smoothing by promoting rare tokens."}, {"id": 128, "string": "To do so, we penalize frequent tokens when smoothing over the vocabulary, by subtracting \u03b2 freq(y t ) from the reward, where freq(\u00b7) denotes the term frequency and \u03b2 is a non-negative weight."}, {"id": 129, "string": "This modification encourages frequent tokens into considering the rare ones."}, {"id": 130, "string": "We experimentally found that it is also beneficial for rare tokens to boost frequent ones, as they tend to have mostly rare tokens as neighbors in the wordembedding space."}, {"id": 131, "string": "With this in mind, we define a new token-level reward as: r freq (y t , y * t ) = r(y t , y * t ) (14) \u2212 \u03b2 min freq(y t ) freq(y * t ) , freq(y * t ) freq(y t ) , where the penalty term is strongest if both tokens have similar frequencies."}, {"id": 132, "string": "Combining losses In both loss smoothing methods presented above, the temperature parameter \u03c4 controls the concentration of the distribution."}, {"id": 133, "string": "As \u03c4 gets smaller the distribution peaks around the ground-truth, while for large \u03c4 the uniform distribution is approached."}, {"id": 134, "string": "We can, however, not separately control the spread of the distribution and the mass reserved for the ground-truth output."}, {"id": 135, "string": "We therefore introduce a second parameter \u03b1 \u2208 [0, 1] to interpolate between the Dirac on the ground-truth and the smooth distribution."}, {"id": 136, "string": "Using\u1fb1 = 1 \u2212 \u03b1, the sequence-level and token-level loss functions are then defined as To benefit from both sequence-level and tokenlevel loss smoothing, we also combine them by applying token-level smoothing to the different sequences sampled for the sequence-level smoothing."}, {"id": 137, "string": "We introduce two mixing parameters \u03b1 1 and \u03b1 2 ."}, {"id": 138, "string": "The first controls to what extent sequencelevel smoothing is used, while the second controls to what extent token-level smoothing is used."}, {"id": 139, "string": "The combined loss is defined as \u03b1 1 ,\u03b1 2 Seq, Tok (y * , x, r) = \u03b1 1 E r [ Tok (y, x)] +\u1fb1 1 Tok (y * , x) = \u03b1 1 E r [\u03b1 2 Tok (y, x) +\u1fb1 2 MLE (y, x)] +\u1fb1 1 (\u03b1 2 Tok (y * , x) +\u1fb1 2 MLE (y * , x))."}, {"id": 140, "string": "(17) In our experiments, we use held out validation data to set mixing and temperature parameters."}, {"id": 141, "string": "Algorithm 1 Sequence-level smoothing algorithm Input: x, y * Output: \u03b1 seq (x, y * ) Encode x to initialize the RNN Forward y * in the RNN to compute the hidden states h * t Compute the MLE loss MLE(y * , x) for l \u2208 {1, ."}, {"id": 142, "string": "."}, {"id": 143, "string": "."}, {"id": 144, "string": ", L} do Sample y l \u223c r(|y * ) if Lazy then Compute (y l , x) = \u2212 t log p \u03b8 (y l t |h * t ) else Forward y l in the RNN to get its hidden states h l t Compute (y l , x) = MLE(y l , x) end if end for \u03b1 Seq (x, y * ) =\u1fb1 MLE(y * , x) + \u03b1 L l (y l , x) Lazy sequence smoothing."}, {"id": 145, "string": "Although sequencelevel smoothing is computationally efficient compared to reinforcement learning approaches (Ranzato et al., 2016; Rennie et al., 2017) , it is slower compared to MLE."}, {"id": 146, "string": "In particular, we need to forward each of the samples y l through the RNN in teacher-forcing mode so as to compute its hidden states h l t , which are used to compute the sequence MLE loss as MLE (y l , x) = \u2212 T t=1 ln p \u03b8 (y l t |h l t )."}, {"id": 147, "string": "(18) To speed up training, and since we already forward the ground truth sequence in the RNN to evaluate the MLE part of \u03b1 Seq (y * , x), we propose to use the same hidden states h * t to compute both the MLE and the sequence-level smoothed loss."}, {"id": 148, "string": "In this case: lazy (y l , x) = \u2212 T t=1 ln p \u03b8 (y l t |h * t ) (19) In this manner, we only have a single instead of L + 1 forwards-passes in the RNN."}, {"id": 149, "string": "We provide the pseudo-code for training in Algorithm 1."}, {"id": 150, "string": "Experimental evaluation In this section, we compare sequence prediction models trained with maximum likelihood (MLE) with our token and sequence-level loss smoothing on two different tasks: image captioning and machine translation."}, {"id": 151, "string": "4.1 Image captioning 4.1.1 Experimental setup."}, {"id": 152, "string": "We use the MS-COCO datatset (Lin et al., 2014) , which consists of 82k training images each annotated with five captions."}, {"id": 153, "string": "We use the standard splits of Karpathy and Li (2015) , with 5k images for validation, and 5k for test."}, {"id": 154, "string": "The test set results are generated via beam search (beam size 3) and are evaluated with the MS-COCO captioning evaluation tool."}, {"id": 155, "string": "We report CIDER and BLEU scores on this internal test set."}, {"id": 156, "string": "We also report results obtained on the official MS-COCO server that additionally measures METEOR (Denkowski and Lavie, 2014) and ROUGE-L (Lin, 2004) ."}, {"id": 157, "string": "We experiment with both non-attentive LSTMs  and the ResNet baseline of the stateof-the-art top-down attention (Anderson et al., 2017) ."}, {"id": 158, "string": "The MS-COCO vocabulary consists of 9,800 words that occur at least 5 times in the training set."}, {"id": 159, "string": "Additional details and hyperparameters can be found in Appendix B.1."}, {"id": 160, "string": "Results and discussion Restricted vocabulary sampling In this section, we evaluate the impact of the vocabulary subset from which we sample the modified sentences for sequence-level smoothing."}, {"id": 161, "string": "We experiment with two rewards: CIDER , which scores w.r.t."}, {"id": 162, "string": "all five available reference sentences, and Hamming distance reward taking only a single reference into account."}, {"id": 163, "string": "For each reward we train our (Seq) models with each of the three subsets detailed previously in Section 3.2, Restricted vocabulary sampling."}, {"id": 164, "string": "From the results in Table 1 we note that for the inattentive models, sampling from V ref s or V batch has a better performance than sampling from the full vocabulary on all metrics."}, {"id": 165, "string": "In fact, using these subsets introduces a useful bias to the model and improves performance."}, {"id": 166, "string": "This improvement is most notable using the CIDER reward that scores candidate sequences w.r.t."}, {"id": 167, "string": "to multiple references, which stabilizes the scoring of the candidates."}, {"id": 168, "string": "With an attentive decoder, no matter the reward, re-sampling sentences with words from V ref rather than the full vocabulary V is better for both reward functions, and all metrics."}, {"id": 169, "string": "Additional experimental results, presented in Appendix B.2, obtained with a BLEU-4 reward, in its single and (Xu et al., 2015) 70."}, {"id": 170, "string": "Overall For reference, we include in Table 1 baseline results obtained using MLE, and our implementation of MLE with entropy regularization (MLE+\u03b3H) (Pereyra et al., 2017) , as well as the RAML approach of Norouzi et al."}, {"id": 171, "string": "(2016) which corresponds to sequence-level smoothing based on the Hamming reward and sampling replacements from the full vocabulary (Seq, Hamming, V) We observe that entropy smoothing is not able to improve performance much over MLE for the model without attention, and even deteriorates for the attention model."}, {"id": 172, "string": "We improve upon RAML by choosing an adequate subset of vocabulary for substitutions."}, {"id": 173, "string": "We also report the performances of token-level smoothing, where the promotion of rare tokens boosted the scores in both attentive and nonattentive models."}, {"id": 174, "string": "For sequence-level smoothing, choosing a taskrelevant reward with importance sampling yielded better results than plain Hamming distance."}, {"id": 175, "string": "Moreover, we used the two smoothing schemes (Tok-Seq) and achieved the best results with CIDER as a reward for sequence-level smoothing combined with a token-level smoothing that promotes rare tokens improving CIDER from 93.59 (MLE) to 99.92 for the model without attention, and improving from 101.63 to 103.81 with attention."}, {"id": 176, "string": "Qualitative results."}, {"id": 177, "string": "In Figure 1 we showcase captions obtained with MLE and our three variants of smoothing i.e."}, {"id": 178, "string": "token-level (Tok), sequencelevel (Seq) and the combination (Tok-Seq)."}, {"id": 179, "string": "We note that the sequence-level smoothing tend to generate lengthy captions overall, which is maintained in the combination."}, {"id": 180, "string": "On the other hand, the token-level smoothing allows for a better recognition of objects in the image that stems from the robust training of the classifier e.g."}, {"id": 181, "string": "the 'cement block' in the top right image or the carrots in the bottom right."}, {"id": 182, "string": "More examples are available in Appendix B.4 Comparison to the state of the art."}, {"id": 183, "string": "We compare our model to state-of-the-art systems on the MS-COCO evaluation server in Table 2 ."}, {"id": 184, "string": "We submitted a single model (Tok-Seq, CIDER , V ref s ) as well as an ensemble of five models with different initializations trained on the training set plus 35k images from the dev set (a total of 117k images) to the MS-COCO server."}, {"id": 185, "string": "The three best results on the server (Rennie et al., 2017; Yao et al., 2017; Anderson et al., 2017) are trained in two stages where they first train using MLE, before switching to policy gradient methods based on CIDEr."}, {"id": 186, "string": "Anderson et al."}, {"id": 187, "string": "(2017) reported an increase of 5.8% of CIDER on the test split after the CIDER optimization."}, {"id": 188, "string": "Moreover, Yao et al."}, {"id": 189, "string": "(2017) uses additional information about image regions to train the attributes classifiers, while Anderson et al."}, {"id": 190, "string": "(2017) pre-trains its bottom-up attention model on the Visual Genome dataset (Krishna et al., 2017) ."}, {"id": 191, "string": "Lu et al."}, {"id": 192, "string": "(2017) ; Yao et al."}, {"id": 193, "string": "(2017) use the same CNN encoder as ours (ResNet-152), Yang et al., 2016) use Inception-v3 (Szegedy et al., 2016) (2017) use Resnet-101, both of which have similar performances to ResNet-152 on ImageNet classification (Canziani et al., 2016) ."}, {"id": 194, "string": "Machine translation Experimental setup."}, {"id": 195, "string": "For this task we validate the effectiveness of our approaches on two different datasets."}, {"id": 196, "string": "The first is WMT'14 English to French, in its filtered version, with 12M sentence pairs obtained after dynamically selecting a \"clean\" subset of 348M words out of the original \"noisy\" 850M words ."}, {"id": 197, "string": "The second benchmark is IWSLT'14 German to English consisting of around 150k pairs for training."}, {"id": 198, "string": "In all our experiments we use the attentive model of  The hyperparameters of each of these models as well as any additional pre-processing can be found in Appendix C.1 To assess the translation quality we report the BLEU-4 metric."}, {"id": 199, "string": "We present our results in Table 3 ."}, {"id": 200, "string": "On both benchmarks, we improve on both MLE and RAML approach of Norouzi et al."}, {"id": 201, "string": "(2016) (Seq, Hamming, V): using the smaller batch-vocabulary for replacement improves results, and using importance sampling based on BLEU-4 further boosts results."}, {"id": 202, "string": "In this case, unlike in the captioning experiment, token-level smoothing brings smaller improvements."}, {"id": 203, "string": "The combination of both smoothing approaches gives best results, similar to what was observed for image captioning, improving the MLE BLEU-4 from 30.03 to 31.39 on WMT'14 and from 27.55 to 28.74 on IWSLT'14."}, {"id": 204, "string": "The outputs of our best model are compared to the MLE in some examples showcased in Appendix C. Results and analysis Conclusion We investigated the use of loss smoothing approaches to improve over maximum likelihood estimation of RNN language models."}, {"id": 205, "string": "We generalized the sequence-level smoothing RAML approach of Norouzi et al."}, {"id": 206, "string": "(2016) to the tokenlevel by smoothing the ground-truth target across semantically similar tokens."}, {"id": 207, "string": "For the sequencelevel, which is computationally expensive, we introduced an efficient \"lazy\" evaluation scheme, and introduced an improved re-sampling strategy."}, {"id": 208, "string": "Experimental evaluation on image captioning and machine translation demonstrates the complementarity of sequence-level and token-level loss smoothing, improving over both the maximum likelihood and RAML."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 22}, {"section": "Related work", "n": "2", "start": 23, "end": 57}, {"section": "Loss smoothing for RNN training", "n": "3", "start": 58, "end": 58}, {"section": "Maximum likelihood RNN training", "n": "3.1", "start": 59, "end": 76}, {"section": "Sequence-level loss smoothing", "n": "3.2", "start": 77, "end": 117}, {"section": "Token-level loss smoothing", "n": "3.3", "start": 118, "end": 131}, {"section": "Combining losses", "n": "3.4", "start": 132, "end": 149}, {"section": "Experimental evaluation", "n": "4", "start": 150, "end": 159}, {"section": "Results and discussion", "n": "4.1.2", "start": 160, "end": 194}, {"section": "Experimental setup.", "n": "4.2.1", "start": 195, "end": 203}, {"section": "Conclusion", "n": "5", "start": 204, "end": 208}], "figures": [{"filename": "../figure/image/977-Table1-1.png", "caption": "Table 1: MS-COCO \u2019s test set evaluation measures.", "page": 5, "bbox": {"x1": 112.8, "x2": 485.28, "y1": 63.839999999999996, "y2": 329.28}}, {"filename": "../figure/image/977-Table3-1.png", "caption": "Table 3: Tokenized BLEU score on WMT\u201914 En-Fr evaluated on the news-test-2014 set. And Tokenzied, case-insensitive BLEU on IWSLT\u201914 De-En.", "page": 7, "bbox": {"x1": 73.92, "x2": 289.44, "y1": 590.4, "y2": 699.36}}, {"filename": "../figure/image/977-Figure1-1.png", "caption": "Figure 1: Examples of generated captions with the baseline MLE and our models with attention.", "page": 7, "bbox": {"x1": 76.8, "x2": 535.1999999999999, "y1": 61.44, "y2": 195.35999999999999}}, {"filename": "../figure/image/977-Table2-1.png", "caption": "Table 2: MS-COCO \u2019s server evaluation . (+) for ensemble submissions, (\u2020) for submissions with CIDEr optimization and (\u25e6) for models using additional data.", "page": 6, "bbox": {"x1": 72.96, "x2": 524.16, "y1": 66.72, "y2": 191.04}}]}