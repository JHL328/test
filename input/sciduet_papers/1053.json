{"title": "Stack-Pointer Networks for Dependency Parsing", "abstract": "We introduce a novel architecture for dependency parsing: stack-pointer networks (STACKPTR). Combining pointer networks (Vinyals et al., 2015) with an internal stack, the proposed model first reads and encodes the whole sentence, then builds the dependency tree top-down (from root-to-leaf) in a depth-first fashion. The stack tracks the status of the depthfirst search and the pointer networks select one child for the word at the top of the stack at each step. The STACKPTR parser benefits from the information of the whole sentence and all previously derived subtree structures, and removes the leftto-right restriction in classical transitionbased parsers. Yet, the number of steps for building any (including non-projective) parse tree is linear in the length of the sentence just as other transition-based parsers, yielding an efficient decoding algorithm with O(n 2 ) time complexity. We evaluate our model on 29 treebanks spanning 20 languages and different dependency annotation schemas, and achieve state-of-theart performance on 21 of them.", "text": [{"id": 0, "string": "Introduction Dependency parsing, which predicts the existence and type of linguistic dependency relations between words, is a first step towards deep language understanding."}, {"id": 1, "string": "Its importance is widely recognized in the natural language processing (NLP) community, with it benefiting a wide range of NLP applications, such as coreference resolution (Ng, 2010; Durrett and Klein, 2013; Work done while at Carnegie Mellon University."}, {"id": 2, "string": "2016), sentiment analysis (Tai et al., 2015) , machine translation (Bastings et al., 2017) , information extraction (Nguyen et al., 2009; Angeli et al., 2015; Peng et al., 2017) , word sense disambiguation (Fauceglia et al., 2015) , and low-resource languages processing (McDonald et al., 2013; Ma and Xia, 2014) ."}, {"id": 3, "string": "There are two dominant approaches to dependency parsing (Buchholz and Marsi, 2006; Nivre et al., 2007) : local and greedy transitionbased algorithms (Yamada and Matsumoto, 2003; Nivre and Scholz, 2004; Zhang and Nivre, 2011; Chen and Manning, 2014) , and the globally optimized graph-based algorithms (Eisner, 1996; Mc-Donald et al., 2005a,b; ."}, {"id": 4, "string": "Transition-based dependency parsers read words sequentially (commonly from left-to-right) and build dependency trees incrementally by making series of multiple choice decisions."}, {"id": 5, "string": "The advantage of this formalism is that the number of operations required to build any projective parse tree is linear with respect to the length of the sentence."}, {"id": 6, "string": "The challenge, however, is that the decision made at each step is based on local information, leading to error propagation and worse performance compared to graph-based parsers on root and long dependencies (McDonald and Nivre, 2011) ."}, {"id": 7, "string": "Previous studies have explored solutions to address this challenge."}, {"id": 8, "string": "Stack LSTMs  are capable of learning representations of the parser state that are sensitive to the complete contents of the parser's state."}, {"id": 9, "string": "Andor et al."}, {"id": 10, "string": "(2016) proposed a globally normalized transition model to replace the locally normalized classifier."}, {"id": 11, "string": "However, the parsing accuracy is still behind state-of-the-art graph-based parsers (Dozat and Manning, 2017) ."}, {"id": 12, "string": "Graph-based dependency parsers, on the other hand, learn scoring functions for parse trees and perform exhaustive search over all possible trees for a sentence to find the globally highest scoring tree."}, {"id": 13, "string": "Incorporating this global search algorithm with distributed representations learned from neural networks, neural graph-based parsers (Kiperwasser and Goldberg, 2016; Wang and Chang, 2016; Kuncoro et al., 2016; Dozat and Manning, 2017) have achieved the state-of-the-art accuracies on a number of treebanks in different languages."}, {"id": 14, "string": "Nevertheless, these models, while accurate, are usually slow (e.g."}, {"id": 15, "string": "decoding is O(n 3 ) time complexity for first-order models (McDonald et al., 2005a,b) and higher polynomials for higherorder models (McDonald and Pereira, 2006; Ma and Zhao, 2012b,a) )."}, {"id": 16, "string": "In this paper, we propose a novel neural network architecture for dependency parsing, stackpointer networks (STACKPTR)."}, {"id": 17, "string": "STACKPTR is a transition-based architecture, with the corresponding asymptotic efficiency, but still maintains a global view of the sentence that proves essential for achieving competitive accuracy."}, {"id": 18, "string": "Our STACKPTR parser has a pointer network (Vinyals et al., 2015) as its backbone, and is equipped with an internal stack to maintain the order of head words in tree structures."}, {"id": 19, "string": "The STACKPTR parser performs parsing in an incremental, topdown, depth-first fashion; at each step, it generates an arc by assigning a child for the head word at the top of the internal stack."}, {"id": 20, "string": "This architecture makes it possible to capture information from the whole sentence and all the previously derived subtrees, while maintaining a number of parsing steps linear in the sentence length."}, {"id": 21, "string": "We evaluate our parser on 29 treebanks across 20 languages and different dependency annotation schemas, and achieve state-of-the-art performance on 21 of them."}, {"id": 22, "string": "The contributions of this work are summarized as follows: (i) We propose a neural network architecture for dependency parsing that is simple, effective, and efficient."}, {"id": 23, "string": "(ii) Empirical evaluations on benchmark datasets over 20 languages show that our method achieves state-of-the-art performance on 21 different treebanks 1 ."}, {"id": 24, "string": "(iii) Comprehensive error analysis is conducted to compare the proposed method to a strong graph-based baseline using biaffine attention (Dozat and Manning, 2017) ."}, {"id": 25, "string": "Background We first briefly describe the task of dependency parsing, setup the notation, and review Pointer Networks (Vinyals et al., 2015) ."}, {"id": 26, "string": "Dependency Parsing and Notations Dependency trees represent syntactic relationships between words in the sentences through labeled directed edges between head words and their dependents."}, {"id": 27, "string": "Figure 1 (a) shows a dependency tree for the sentence, \"But there were no buyers\"."}, {"id": 28, "string": "In this paper, we will use the following notation: Input: x = {w 1 , ."}, {"id": 29, "string": "."}, {"id": 30, "string": "."}, {"id": 31, "string": ", w n } represents a generic sentence, where w i is the ith word."}, {"id": 32, "string": "Output: y = {p 1 , p 2 , \u00b7 \u00b7 \u00b7 , p k } represents a generic (possibly non-projective) dependency tree, where each path p i = $, w i,1 , w i,2 , \u00b7 \u00b7 \u00b7 , w i,l i is a sequence of words from the root to a leaf."}, {"id": 33, "string": "\"$\" is an universal virtual root that is added to each tree."}, {"id": 34, "string": "Stack: \u03c3 denotes a stack configuration, which is a sequence of words."}, {"id": 35, "string": "We use \u03c3|w to represent a stack configuration that pushes word w into the stack \u03c3."}, {"id": 36, "string": "Children: ch(w i ) denotes the list of all the children (modifiers) of word w i ."}, {"id": 37, "string": "Pointer Networks Pointer Networks (PTR-NET) (Vinyals et al., 2015) are a variety of neural network capable of learning the conditional probability of an output sequence with elements that are discrete tokens corresponding to positions in an input sequence."}, {"id": 38, "string": "This model cannot be trivially expressed by standard sequence-to-sequence networks  due to the variable number of input positions in each sentence."}, {"id": 39, "string": "PTR-NET solves the problem by using attention (Bahdanau et al., 2015; Luong et al., 2015) as a pointer to select a member of the input sequence as the output."}, {"id": 40, "string": "Formally, the words of the sentence x are fed one-by-one into the encoder (a multiple-layer bidirectional RNN), producing a sequence of encoder hidden states s i ."}, {"id": 41, "string": "At each time step t, the decoder (a uni-directional RNN) receives the input from last step and outputs decoder hidden state h t ."}, {"id": 42, "string": "The attention vector a t is calculated as follows: e t i = score(h t , s i ) a t = softmax (e t ) (1) where score(\u00b7, \u00b7) is the attention scoring function, which has several variations such as dot-product, concatenation, and biaffine (Luong et al., 2015) ."}, {"id": 43, "string": "PTR-NET regards the attention vector a t as a probability distribution over the source words, i.e."}, {"id": 44, "string": "it uses a t i as pointers to select the input elements."}, {"id": 45, "string": "3 Stack-Pointer Networks Overview Similarly to PTR-NET, STACKPTR first reads the whole sentence and encodes each word into the encoder hidden state s i ."}, {"id": 46, "string": "The internal stack \u03c3 is always initialized with the root symbol $."}, {"id": 47, "string": "At each time step t, the decoder receives the input vector corresponding to the top element of the stack \u03c3 (the head word w p where p is the word index), generates the hidden state h t , and computes the attention vector a t using Eq."}, {"id": 48, "string": "(1)."}, {"id": 49, "string": "The parser chooses a specific position c according to the attention scores in a t to generate a new dependency arc (w h , w c ) by selecting w c as a child of w h ."}, {"id": 50, "string": "Then the parser pushes w c onto the stack, i.e."}, {"id": 51, "string": "\u03c3 \u2192 \u03c3|w c , and goes to the next step."}, {"id": 52, "string": "At one step if the parser points w h to itself, i.e."}, {"id": 53, "string": "c = h, it indicates that all children of the head word w h have already been selected."}, {"id": 54, "string": "Then the parser goes to the next step by popping w h out of \u03c3."}, {"id": 55, "string": "At test time, in order to guarantee a valid dependency tree containing all the words in the input sentences exactly once, the decoder maintains a list of \"available\" words."}, {"id": 56, "string": "At each decoding step, the parser selects a child for the current head word, and removes the child from the list of available words to make sure that it cannot be selected as a child of other head words."}, {"id": 57, "string": "For head words with multiple children, it is possible that there is more than one valid selection for each time step."}, {"id": 58, "string": "In order to define a deterministic decoding process to make sure that there is only one ground-truth choice at each step (which is necessary for simple maximum likelihood estimation), a predefined order for each ch(w i ) needs to be introduced."}, {"id": 59, "string": "The predefined order of children can have different alternatives, such as leftto-right or inside-out 2 ."}, {"id": 60, "string": "In this paper, we adopt the inside-out order 3 since it enables us to utilize second-order sibling information, which has been proven beneficial for parsing performance (Mc-Donald and Pereira, 2006; ) (see \u00a7 3.4 for details)."}, {"id": 61, "string": "Figure 1 (b) depicts the architecture of STACKPTR and the decoding procedure for the example sentence in Figure 1 (a) ."}, {"id": 62, "string": "Encoder The encoder of our parsing model is based on the bi-directional LSTM-CNN architecture (BLSTM-CNNs) (Chiu and Nichols, 2016; where CNNs encode character-level information of a word into its character-level repre-sentation and BLSTM models context information of each word."}, {"id": 63, "string": "Formally, for each word, the CNN, with character embeddings as inputs, encodes the character-level representation."}, {"id": 64, "string": "Then the character-level representation vector is concatenated with the word embedding vector to feed into the BLSTM network."}, {"id": 65, "string": "To enrich word-level information, we also use POS embeddings."}, {"id": 66, "string": "Finally, the encoder outputs a sequence of hidden states s i ."}, {"id": 67, "string": "Decoder The decoder for our parser is a uni-directional LSTM."}, {"id": 68, "string": "Different from previous work (Bahdanau et al., 2015; Vinyals et al., 2015) which uses word embeddings of the previous word as the input to the decoder, our decoder receives the encoder hidden state vector (s i ) of the top element in the stack \u03c3 (see Figure 1 (b))."}, {"id": 69, "string": "Compared to word embeddings, the encoder hidden states contain more contextual information, benefiting both the training and decoding procedures."}, {"id": 70, "string": "The decoder produces a sequence of decoder hidden states h i , one for each decoding step."}, {"id": 71, "string": "Higher-order Information As mentioned before, our parser is capable of utilizing higher-order information."}, {"id": 72, "string": "In this paper, we incorporate two kinds of higher-order structures grandparent and sibling."}, {"id": 73, "string": "A sibling structure is a head word with two successive modifiers, and a grandparent structure is a pair of dependencies connected head-to-tail: 0 12 3 456 2782 96 56 986 2 5214 3 77543 9 5 2 52 \u00ff \u00ff ! \""}, {"id": 74, "string": "\"#$% & #& ' % !"}, {"id": 75, "string": "#& (()& *% & & !"}, {"id": 76, "string": "*\"& (+(\"!"}, {"id": 77, "string": "\"% ) &, \" \"#$' (% & #-.,\"/\" \"#$ % %% #*) (& ** *% & 0 % #( !"}, {"id": 78, "string": "$% %()- 1 2 3 -45 67 896: ;<=>?"}, {"id": 79, "string": "@ ABCDE3 -F14 G H I .J3-4 %& *% &()!"}, {"id": 80, "string": "!& %#( & +!"}, {"id": 81, "string": ", & * -\"ABCDE3 -F14K!"}, {"id": 82, "string": "& %& *K&& *&& 1 %& *!"}, {"id": 83, "string": "$% %()% & #-'A #& *# \" !"}, {"id": 84, "string": "0 & $()J3-4 (,% (& !"}, {"id": 85, "string": "!"}, {"id": 86, "string": "$, & *& *!"}, {"id": 87, "string": "& *() & *% & #.\""}, {"id": 88, "string": "#& !"}, {"id": 89, "string": "$%(!"}, {"id": 90, "string": "K EL' % #& #! '"}, {"id": 91, "string": "#((%& & $."}, {"id": 92, "string": "\"(,* #*) ( %& *) (0 #%()& * % ."}, {"id": 93, "string": "%& (M NOP QR#*\" \"#$& & (%!"}, {"id": 94, "string": "!SNR P T .,* #*#+% #( \" % (!"}, {"id": 95, "string": "& (' #& ( \" % #+) ( !"}, {"id": 96, "string": "U\"%) (!"}, {"id": 97, "string": "!"}, {"id": 98, "string": "(,% ABCDE3 -F145 V W<; ABCDEXDY3 -FZ4 Y*& % .,& && *\" \"#$& 1%%& () & %Z.#*(),* #*[%% & #(& 0 +& (& (& *% #( ()1'(# & ) #& ( U& (% . )"}, {"id": 99, "string": "/# & % !"}, {"id": 100, "string": "( & *% % &) (% (!"}, {"id": 101, "string": "K EL'' \\\"/ A # /#!"}, {"id": 102, "string": "!"}, {"id": 103, "string": "$.A#& (%u' .u' v.\"u' w\"% # + % %& *& ."}, {"id": 104, "string": "% #& K!"}, {"id": 105, "string": "$.)"}, {"id": 106, "string": "#& (& % & ( \"0 #* ! \""}, {"id": 107, "string": "& % ."}, {"id": 108, "string": "\"0 % +!"}, {"id": 109, "string": "& % .\""}, {"id": 110, "string": "& () \"0 % +!"}, {"id": 111, "string": "\"& 0 % +!"}, {"id": 112, "string": "& % ' x yz{ | } {| { { } | C,& * \"0 ( \"\" \"#$ % %+ !"}, {"id": 113, "string": "\"( \"%) ( % & % !"}, {"id": 114, "string": "( & *%'_ & * % % #& (., (K \"+#[ (\"(& ,( !"}, {"id": 115, "string": "K& % %) ( K (%,( [' G H G +H vY*\"$ #0 ( % & #& % \"\" K& (%()& *E % G vH!"}, {"id": 116, "string": "( & *' B( !"}, {"id": 117, "string": "& % % \" #& \"%& !"}, {"id": 118, "string": "%\" 0 #( !"}, {"id": 119, "string": "& % %%& U( \"% '(+ K & $.,! \""}, {"id": 120, "string": "& *% $& # *& 0 *\"\"K % (% ' x { | } } { } { \u1ef8 */ % && $ () % ,\"% # +% %/ % & 0 ( \" ) #& ( U& (.,* #*\"#( (% %\" 0 \"#$& & ( & % \" K \"!\""}, {"id": 121, "string": "\"# % 'E % 0 G vH & (\"#\", \"!"}, {"id": 122, "string": "$0 % \"\"$ #0 ( !"}, {"id": 123, "string": "( & *) (/ % & 0 ( \" % % & %& *+% %) ($ % % ."}, {"id": 124, "string": "#! \""}, {"id": 125, "string": "(, !"}, {"id": 126, "string": "( & *%.,% U & %\"% * ' Y*E % G vH!"}, {"id": 127, "string": "( & * %+% \"(& ,( & !"}, {"id": 128, "string": "& \"& $ %()\"$ #0 ( %& #0 & % OQ S\u00a1P% % .,* #*#(% % &()*\"0 ,( \"\" & %\"% #\"& %((% \"."}, {"id": 129, "string": "\"\u00a2 \u00a3OQ \u00a4 S\u00a1P% % .,* #*#(% % &()\" \"#$\"& * (+& ,& **\"\"(\" / ' ( !"}, {"id": 130, "string": "!"}, {"id": 131, "string": "$.,\"(& #( !"}, {"id": 132, "string": "& % %\u00a5 \u00a6 \u00a7 ,* \u00a9\"\u00aa & * \" #%()& *% \u00ab %*\"0 ,( \"\"\" ( & ' #( !"}, {"id": 133, "string": "& % %\"0 (& \"%\u00ac \u00a6 \u00a7 ,* \u00a9\"\u00ae & * \"()& * *\"\"(\" /()\" \"#$' _ & & K!"}, {"id": 134, "string": "$."}, {"id": 135, "string": "#( !"}, {"id": 136, "string": "& % % & %*! )"}, {"id": 137, "string": "0 #(% & & & *\"\"+$\u00a9.,* % #( !"}, {"id": 138, "string": "& % %(!"}, {"id": 139, "string": "$ & !*! )"}, {"id": 140, "string": "0 #(% & & & .% #& *#(% & & &# +& \"\"+$\"\" ( (\" / %& (\u00ae' E#*& $ ()% %# & \"+$ # % K!"}, {"id": 141, "string": "$ #(+ & ,(%!"}, {"id": 142, "string": "!"}, {"id": 143, "string": "."}, {"id": 144, "string": "\"#&% % & *#(0 % & #& (% % # /\" * #!"}, {"id": 145, "string": "!"}, {"id": 146, "string": "$ v' #( !"}, {"id": 147, "string": "& % %#(% & #& \") ( ()#( !"}, {"id": 148, "string": "& % % . \""}, {"id": 149, "string": "#& & *\" K % (()& * \u00b0\u00a9F\u00ae\u00b1 & (#(% & & & %*\"\"+$\u00a9\" \u00ae' #( !"}, {"id": 150, "string": "& % %# & \"+$#( !"}, {"id": 151, "string": "& 0 #( !"}, {"id": 152, "string": "& % , & *& *(& **!"}, {"id": 153, "string": ")() \u00ae\u00ab %#(% & & & 'Y* ( &()#(#& & ( #*#(% & #& (\u00b2\u00ae vG H(\u00b3 0 vG +H \u00b2 %& *T S\u00a1 \u00a2 PSQ\u00a2 \u00a3P .)"}, {"id": 154, "string": "\"& *&% & + & \"& (/\"& *( & !#(% & #& (' _ ( \"& ( % %& #-."}, {"id": 155, "string": "&% ) /#%& ( /\"( & !#(% & #& (%) (!"}, {"id": 156, "string": "!#( !"}, {"id": 157, "string": "& \" #( !"}, {"id": 158, "string": "& % %\"/\"(-' Y* %#+ To utilize higher-order information, the decoder's input at each step is the sum of the encoder hidden states of three words: \u03b2 t = s h + s g + s s where \u03b2 t is the input vector of decoder at time t and h, g, s are the indices of the head word and its grandparent and sibling, respectively."}, {"id": 159, "string": "Figure 1 (b) illustrates the details."}, {"id": 160, "string": "Here we use the element-wise sum operation instead of concatenation because it does not increase the dimension of the input vector \u03b2 t , thus introducing no additional model parameters."}, {"id": 161, "string": "Biaffine Attention Mechanism For attention score function (Eq."}, {"id": 162, "string": "(1)), we adopt the biaffine attention mechanism (Luong et al., 2015; Dozat and Manning, 2017) : e t i = h T t Ws i + U T h t + V T s i + b where W, U, V, b are parameters, denoting the weight matrix of the bi-linear term, the two weight vectors of the linear terms, and the bias vector."}, {"id": 163, "string": "As discussed in Dozat and Manning (2017) , applying a multilayer perceptron (MLP) to the output vectors of the BLSTM before the score function can both reduce the dimensionality and overfitting of the model."}, {"id": 164, "string": "We follow this work by using a one-layer perceptron to s i and h i with elu (Clevert et al., 2015) as its activation function."}, {"id": 165, "string": "Similarly, the dependency label classifier also uses a biaffine function to score each label, given the head word vector h t and child vector s i as inputs."}, {"id": 166, "string": "Again, we use MLPs to transform h t and s i before feeding them into the classifier."}, {"id": 167, "string": "Training Objectives The STACKPTR parser is trained to optimize the probability of the dependency trees given sentences: P \u03b8 (y|x), which can be factorized as: P \u03b8 (y|x) = k i=1 P \u03b8 (p i |p <i , x) = k i=1 l i j=1 P \u03b8 (c i,j |c i,<j , p <i , x), (2) where \u03b8 represents model parameters."}, {"id": 168, "string": "p <i denotes the preceding paths that have already been generated."}, {"id": 169, "string": "c i,j represents the jth word in p i and c i,<j denotes all the proceeding words on the path p i ."}, {"id": 170, "string": "Thus, the STACKPTR parser is an autoregressive model, like sequence-to-sequence models, but it factors the distribution according to a top-down tree structure as opposed to a left-to-right chain."}, {"id": 171, "string": "We define P \u03b8 (c i,j |c i,<j , p <i , x) = a t , where attention vector a t (of dimension n) is used as the distribution over the indices of words in a sentence."}, {"id": 172, "string": "Arc Prediction Our parser is trained by optimizing the conditional likelihood in Eq (2), which is implemented as the cross-entropy loss."}, {"id": 173, "string": "Label Prediction We train a separated multiclass classifier in parallel to predict the dependency labels."}, {"id": 174, "string": "Following Dozat and Manning (2017) , the classifier takes the information of the head word and its child as features."}, {"id": 175, "string": "The label classifier is trained simultaneously with the parser by optimizing the sum of their objectives."}, {"id": 176, "string": "Discussion Time Complexity."}, {"id": 177, "string": "The number of decoding steps to build a parse tree for a sentence of length n is 2n\u22121, linear in n. Together with the attention mechanism (at each step, we need to compute the attention vector a t , whose runtime is O(n)), the time complexity of decoding algorithm is O(n 2 ), which is more efficient than graph-based parsers that have O(n 3 ) or worse complexity when using dynamic programming or maximum spanning tree (MST) decoding algorithms."}, {"id": 178, "string": "Top-down Parsing."}, {"id": 179, "string": "When humans comprehend a natural language sentence, they arguably do it in an incremental, left-to-right manner."}, {"id": 180, "string": "However, when humans consciously annotate a sentence with syntactic structure, they rarely ever process in fixed left-to-right order."}, {"id": 181, "string": "Rather, they start by reading the whole sentence, then seeking the main predicates, jumping back-and-forth over the sentence and recursively proceeding to the subtree structures governed by certain head words."}, {"id": 182, "string": "Our parser follows a similar kind of annotation process: starting from reading the whole sentence, and processing in a top-down manner by finding the main predicates first and only then search for sub-trees governed by them."}, {"id": 183, "string": "When making latter decisions, the parser has access to the entire structure built in earlier steps."}, {"id": 184, "string": "Implementation Details Pre-trained Word Embeddings."}, {"id": 185, "string": "For all the parsing models in different languages, we initialize word vectors with pretrained word embeddings."}, {"id": 186, "string": "For Chinese, Dutch, English, German and Spanish, we use the structured-skipgram  embeddings."}, {"id": 187, "string": "For other languages we use Polyglot embeddings (Al-Rfou et al., 2013) ."}, {"id": 188, "string": "Optimization."}, {"id": 189, "string": "Parameter optimization is performed with the Adam optimizer (Kingma and Ba, 2014) with \u03b2 1 = \u03b2 2 = 0.9."}, {"id": 190, "string": "We choose an initial learning rate of \u03b7 0 = 0.001."}, {"id": 191, "string": "The learning rate \u03b7 is annealed by multiplying a fixed decay rate \u03c1 = 0.75 when parsing performance stops increasing on validation sets."}, {"id": 192, "string": "To reduce the effects of \"gradient exploding\", we use gradient clipping of 5.0 (Pascanu et al., 2013) ."}, {"id": 193, "string": "Dropout Training."}, {"id": 194, "string": "To mitigate overfitting, we apply dropout (Srivastava et al., 2014; ."}, {"id": 195, "string": "For BLSTM, we use recurrent dropout (Gal and Ghahramani, 2016) with a drop rate of 0.33 between hidden states and 0.33 between layers."}, {"id": 196, "string": "Following Dozat and Manning (2017) , we also use embedding dropout with a rate of 0.33 on all word, character, and POS embeddings."}, {"id": 197, "string": "Hyper-Parameters."}, {"id": 198, "string": "Some parameters are chosen from those reported in Dozat and Manning (2017) ."}, {"id": 199, "string": "We use the same hyper-parameters across the models on different treebanks and languages, due to time constraints."}, {"id": 200, "string": "The details of the chosen hyper-parameters for all experiments are summarized in Appendix A."}, {"id": 201, "string": "Experiments Setup We evaluate our STACKPTR parser mainly on three treebanks: the English Penn Treebank (PTB version 3.0) (Marcus et al., 1993) , the Penn Chinese Treebank (CTB version 5.1) (Xue et al., 2002) , and the German CoNLL 2009 corpus (Haji\u010d et al., 2009) ."}, {"id": 202, "string": "We use the same experimental settings as Kuncoro et al."}, {"id": 203, "string": "(2016) ."}, {"id": 204, "string": "To make a thorough empirical comparison with previous studies, we also evaluate our system on treebanks from CoNLL shared task and the Universal Dependency (UD) Treebanks 4 ."}, {"id": 205, "string": "For the CoNLL Treebanks, we use the English treebank from CoNLL-2008 shared task (Surdeanu et al., 2008) and all 13 treebanks from CoNLL-2006 shared task (Buchholz and Marsi, 2006) ."}, {"id": 206, "string": "The experimental settings are the same as ."}, {"id": 207, "string": "For UD Treebanks, we select 12 languages."}, {"id": 208, "string": "The details of the treebanks and experimental settings are in \u00a7 4.5 and Appendix B."}, {"id": 209, "string": "Evaluation Metrics Parsing performance is measured with five metrics: unlabeled attachment score (UAS), labeled attachment score (LAS), unlabeled complete match (UCM), labeled complete match (LCM), and root accuracy (RA)."}, {"id": 210, "string": "Following previous work (Kuncoro et al., 2016; Dozat and Manning, 2017) , we report results excluding punctuations for Chinese and English."}, {"id": 211, "string": "For each experiment, we report the mean values with corresponding standard deviations over 5 repetitions."}, {"id": 212, "string": "Baseline For fair comparison of the parsing performance, we re-implemented the graph-based Deep Biaffine (BIAF) parser (Dozat and Manning, 2017) , which achieved state-of-the-art results on a wide range of languages."}, {"id": 213, "string": "Our re-implementation adds character-level information using the same LSTM-CNN encoder as our model ( \u00a7 3.2) to the original BIAF model, which boosts its performance on all languages."}, {"id": 214, "string": "Main Results We first conduct experiments to demonstrate the effectiveness of our neural architecture by comparing with the strong baseline BIAF."}, {"id": 215, "string": "We compare the performance of four variations of our model with different decoder inputs -Org, +gpar, +sib and Full -where the Org model utilizes only the encoder hidden states of head words, while the +gpar and +sib models augments the original one with grandparent and sibling information, respectively."}, {"id": 216, "string": "The Full model includes all the three information as inputs."}, {"id": 217, "string": "Figure 2 illustrates the performance (five metrics) of different variations of our STACKPTR parser together with the results of baseline BIAF re-implemented by us, on the test sets of the three languages."}, {"id": 218, "string": "On UAS and LAS, the Full variation of STACKPTR with decoding beam size 10 outperforms BIAF on Chinese, and obtains competitive performance on English and German."}, {"id": 219, "string": "An interesting observation is that the Full model achieves the best accuracy on English and Chinese, while performs slightly worse than +sib on German."}, {"id": 220, "string": "This shows that the importance of higher-order information varies in languages."}, {"id": 221, "string": "On LCM and UCM, STACKPTR significantly outperforms BIAF on all languages, showing the superiority of our parser on complete sentence parsing."}, {"id": 222, "string": "The results of our parser on RA are slightly worse than BIAF."}, {"id": 223, "string": "More details of results are provided in Appendix C. Table 1 illustrates the UAS and LAS of the four versions of our model (with decoding beam size 10) on the three treebanks, together with previous top-performing systems for comparison."}, {"id": 224, "string": "Note that the results of STACKPTR and our reimplementation of BIAF are the average of 5 repetitions instead of a single run."}, {"id": 225, "string": "Our Full model significantly outperforms all the transition-based parsers on all three languages, and achieves better results than most graph-based parsers."}, {"id": 226, "string": "Our Table 1 : UAS and LAS of four versions of our model on test sets for three languages, together with topperforming parsing systems."}, {"id": 227, "string": "\"T\" and \"G\" indicate transition-and graph-based models, respectively."}, {"id": 228, "string": "For BIAF, we provide the original results reported in Dozat and Manning (2017) and our re-implementation."}, {"id": 229, "string": "For STACKPTR and our re-implementation of BiAF, we report the average over 5 runs."}, {"id": 230, "string": "re-implementation of BIAF obtains better performance than the original one in Dozat and Manning (2017) , demonstrating the effectiveness of the character-level information."}, {"id": 231, "string": "Our model achieves state-of-the-art performance on both UAS and LAS on Chinese, and best UAS on English."}, {"id": 232, "string": "On German, the performance is competitive with BIAF, and significantly better than other models."}, {"id": 233, "string": "Comparison with Previous Work Error Analysis In this section, we characterize the errors made by BIAF and STACKPTR by presenting a number of experiments that relate parsing errors to a set of linguistic and structural properties."}, {"id": 234, "string": "For simplicity, we follow McDonald and Nivre (2011) and report labeled parsing metrics (either accuracy, precision, or recall) for all experiments."}, {"id": 235, "string": "Length and Graph Factors Following McDonald and Nivre (2011), we analyze parsing errors related to structural factors."}, {"id": 236, "string": "Sentence Length."}, {"id": 237, "string": "Figure 3 (a) shows the accuracy of both parsing models relative to sentence lengths."}, {"id": 238, "string": "Consistent with the analysis in Mc-Donald and Nivre (2011) , STACKPTR tends to perform better on shorter sentences, which make fewer parsing decisions, significantly reducing the chance of error propagation."}, {"id": 239, "string": "Dependency Length."}, {"id": 240, "string": "Figure 3 (b) measures the precision and recall relative to dependency lengths."}, {"id": 241, "string": "While the graph-based BIAF parser still performs better for longer dependency arcs and transition-based STACKPTR parser does better for shorter ones, the gap between the two systems is marginal, much smaller than that shown Table 3 : UAS and LAS on 14 treebanks from CoNLL shared tasks, together with several state-of-the-art parsers."}, {"id": 242, "string": "Bi-Att is the bi-directional attention based parser (Cheng et al., 2016) , and NeuroMST is the neural MST parser ."}, {"id": 243, "string": "\"Best Published\" includes the most accurate parsers in term of UAS among , Martins et al."}, {"id": 244, "string": "(2011) , Martins et al."}, {"id": 245, "string": "(2013) , , , Zhang and McDonald (2014) , Pitler and McDonald (2015) , and Cheng et al."}, {"id": 246, "string": "(2016) ."}, {"id": 247, "string": "in McDonald and Nivre (2011) ."}, {"id": 248, "string": "One possible reason is that, unlike traditional transition-based parsers that scan the sentence from left to right, STACKPTR processes in a top-down manner, thus sometimes unnecessarily creating shorter dependency arcs first."}, {"id": 249, "string": "Root Distance."}, {"id": 250, "string": "Figure 3 (c) plots the precision and recall of each system for arcs of varying distance to the root."}, {"id": 251, "string": "Different from the observation in McDonald and Nivre (2011) , STACKPTR does not show an obvious advantage on the precision for arcs further away from the root."}, {"id": 252, "string": "Furthermore, the STACKPTR parser does not have the tendency to over-predict root modifiers reported in McDonald and Nivre (2011) ."}, {"id": 253, "string": "This behavior can be explained using the same reasoning as above: the fact that arcs further away from the root are usually constructed early in the parsing algorithm of traditional transition-based parsers is not true for the STACKPTR parser."}, {"id": 254, "string": "Effect of POS Embedding The only prerequisite information that our parsing model relies on is POS tags."}, {"id": 255, "string": "With the goal of achieving an end-to-end parser, we explore the effect of POS tags on parsing performance."}, {"id": 256, "string": "We run experiments on PTB using our STACKPTR parser with gold-standard and predicted POS tags, and without tags, respectively."}, {"id": 257, "string": "STACKPTR in these experiments is the Full model with beam=10."}, {"id": 258, "string": "Table 2 gives results of the parsers with different versions of POS tags on the test data of PTB."}, {"id": 259, "string": "The parser with gold-standard POS tags significantly outperforms the other two parsers, showing that dependency parsers can still benefit from accurate POS information."}, {"id": 260, "string": "The parser with predicted (imperfect) POS tags, however, performs even slightly worse than the parser without using POS tags."}, {"id": 261, "string": "It illustrates that an end-to-end parser that doesn't rely on POS information can obtain competitive (or even better) performance than parsers using imperfect predicted POS tags, even if the POS tagger is relative high accuracy (accuracy > 97% in this experiment on PTB)."}, {"id": 262, "string": "Table 3 summarizes the parsing results of our model on the test sets of 14 treebanks from the CoNLL shared task, along with the state-of-theart baselines."}, {"id": 263, "string": "Along with BIAF, we also list the performance of the bi-directional attention based Parser (Bi-Att) (Cheng et al., 2016) and the neural MST parser (NeuroMST)  for comparison."}, {"id": 264, "string": "Our parser achieves state-of-theart performance on both UAS and LAS on eight languages -Arabic, Czech, English, German, Portuguese, Slovene, Spanish, and Swedish."}, {"id": 265, "string": "On Bulgarian and Dutch, our parser obtains the best UAS."}, {"id": 266, "string": "On other languages, the performance of our parser is competitive with BIAF, and significantly better than others."}, {"id": 267, "string": "The only exception is Japanese, on which NeuroMST obtains the best scores."}, {"id": 268, "string": "Experiments on Other Treebanks CoNLL Treebanks UD Treebanks For UD Treebanks, we select 12 languages -Bulgarian, Catalan, Czech, Dutch, English, French, German, Italian, Norwegian, Romanian, Russian and Spanish."}, {"id": 269, "string": "For all the languages, we adopt the standard training/dev/test splits, and use the universal POS tags (Petrov et al., 2012) provided in each treebank."}, {"id": 270, "string": "The statistics of these corpora are provided in Appendix B."}, {"id": 271, "string": "Table 4 summarizes the results of the STACKPTR parser, along with BIAF for comparison, on both the development and test datasets for each language."}, {"id": 272, "string": "First, both BIAF and STACKPTR parsers achieve relatively high parsing accuracies on all the 12 languages -all with UAS are higher than 90%."}, {"id": 273, "string": "On nine languages -Catalan, Czech, Dutch, English, French, German, Norwegian, Russian and Spanish -STACKPTR outperforms BIAF for both UAS and LAS."}, {"id": 274, "string": "On Bulgarian, STACKPTR achieves slightly better UAS while LAS is slightly worse than BIAF."}, {"id": 275, "string": "On Italian and Romanian, BIAF obtains marginally better parsing performance than STACKPTR."}, {"id": 276, "string": "Conclusion In this paper, we proposed STACKPTR, a transition-based neural network architecture, for dependency parsing."}, {"id": 277, "string": "Combining pointer networks with an internal stack to track the status of the top-down, depth-first search in the decoding procedure, the STACKPTR parser is able to capture information from the whole sentence and all the previously derived subtrees, removing the leftto-right restriction in classical transition-based parsers, while maintaining linear parsing steps, w.r.t the length of the sentences."}, {"id": 278, "string": "Experimental re-sults on 29 treebanks show the effectiveness of our parser across 20 languages, by achieving state-ofthe-art performance on 21 corpora."}, {"id": 279, "string": "There are several potential directions for future work."}, {"id": 280, "string": "First, we intend to consider how to conduct experiments to improve the analysis of parsing errors qualitatively and quantitatively."}, {"id": 281, "string": "Another interesting direction is to further improve our model by exploring reinforcement learning approaches to learn an optimal order for the children of head words, instead of using a predefined fixed order."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 24}, {"section": "Background", "n": "2", "start": 25, "end": 25}, {"section": "Dependency Parsing and Notations", "n": "2.1", "start": 26, "end": 36}, {"section": "Pointer Networks", "n": "2.2", "start": 37, "end": 44}, {"section": "Overview", "n": "3.1", "start": 45, "end": 61}, {"section": "Encoder", "n": "3.2", "start": 62, "end": 66}, {"section": "Decoder", "n": "3.3", "start": 67, "end": 70}, {"section": "Higher-order Information", "n": "3.4", "start": 71, "end": 160}, {"section": "Biaffine Attention Mechanism", "n": "3.5", "start": 161, "end": 166}, {"section": "Training Objectives", "n": "3.6", "start": 167, "end": 175}, {"section": "Discussion", "n": "3.7", "start": 176, "end": 183}, {"section": "Implementation Details", "n": "3.8", "start": 184, "end": 200}, {"section": "Setup", "n": "4.1", "start": 201, "end": 213}, {"section": "Main Results", "n": "4.2", "start": 214, "end": 231}, {"section": "Error Analysis", "n": "4.4", "start": 232, "end": 234}, {"section": "Length and Graph Factors", "n": "4.4.1", "start": 235, "end": 253}, {"section": "Effect of POS Embedding", "n": "4.4.2", "start": 254, "end": 267}, {"section": "UD Treebanks", "n": "4.5.2", "start": 268, "end": 275}, {"section": "Conclusion", "n": "5", "start": 276, "end": 281}], "figures": [{"filename": "../figure/image/1053-Figure2-1.png", "caption": "Figure 2: Parsing performance of different variations of our model on the test sets for three languages, together with baseline BIAF. For each of our STACKPTR models, we perform decoding with beam size equal to 1 and 10. The improvements of decoding with beam size 10 over 1 are presented by stacked bars with light colors.", "page": 5, "bbox": {"x1": 72.0, "x2": 526.0799999999999, "y1": 61.44, "y2": 336.0}}, {"filename": "../figure/image/1053-Table1-1.png", "caption": "Table 1: UAS and LAS of four versions of our model on test sets for three languages, together with topperforming parsing systems. \u201cT\u201d and \u201cG\u201d indicate transition- and graph-based models, respectively. For BIAF, we provide the original results reported in Dozat and Manning (2017) and our re-implementation. For STACKPTR and our re-implementation of BiAF, we report the average over 5 runs.", "page": 6, "bbox": {"x1": 124.8, "x2": 473.28, "y1": 61.44, "y2": 275.03999999999996}}, {"filename": "../figure/image/1053-Table2-1.png", "caption": "Table 2: Parsing performance on the test data of PTB with different versions of POS tags.", "page": 6, "bbox": {"x1": 72.96, "x2": 287.03999999999996, "y1": 471.84, "y2": 514.0799999999999}}, {"filename": "../figure/image/1053-Figure3-1.png", "caption": "Figure 3: Parsing performance of BIAF and STACKPTR parsers relative to length and graph factors.", "page": 6, "bbox": {"x1": 72.0, "x2": 526.0799999999999, "y1": 349.44, "y2": 427.68}}, {"filename": "../figure/image/1053-Figure1-1.png", "caption": "Figure 1: Neural architecture for the STACKPTR network, together with the decoding procedure of an example sentence. The BiRNN of the encoder is elided for brevity. For the inputs of decoder at each time step, vectors in red and blue boxes indicate the sibling and grandparent.", "page": 2, "bbox": {"x1": 73.92, "x2": 528.0, "y1": 62.879999999999995, "y2": 269.28}}, {"filename": "../figure/image/1053-Table3-1.png", "caption": "Table 3: UAS and LAS on 14 treebanks from CoNLL shared tasks, together with several state-of-the-art parsers. Bi-Att is the bi-directional attention based parser (Cheng et al., 2016), and NeuroMST is the neural MST parser (Ma and Hovy, 2017). \u201cBest Published\u201d includes the most accurate parsers in term of UAS among Koo et al. (2010), Martins et al. (2011), Martins et al. (2013), Lei et al. (2014), Zhang et al. (2014), Zhang and McDonald (2014), Pitler and McDonald (2015), and Cheng et al. (2016).", "page": 7, "bbox": {"x1": 84.96, "x2": 511.2, "y1": 62.4, "y2": 224.16}}, {"filename": "../figure/image/1053-Table4-1.png", "caption": "Table 4: UAS and LAS on both the development and test datasets of 12 treebanks from UD Treebanks, together with BIAF for comparison.", "page": 8, "bbox": {"x1": 74.88, "x2": 521.28, "y1": 62.4, "y2": 214.07999999999998}}]}