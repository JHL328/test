{"title": "Weighted parsing for grammar-based language models", "abstract": "We develop a general framework for weighted parsing which is built on top of grammarbased language models and employs flexible weight algebras. It generalizes previous work in that area (semiring parsing, weighted deductive parsing) and also covers applications outside the classical scope of parsing, e.g., algebraic dynamic programming. We show an algorithm which terminates and is correct for a large class of weighted grammar-based language models.", "text": [{"id": 0, "string": "Introduction The weighted parsing problem takes as input a weighted language model (LM) and a syntactic object a."}, {"id": 1, "string": "For instance, the LM can be given by some grammar G, e.g., a context-free grammar (CFG) or a linear context-free rewriting system (LCFRS), and a can be some string."}, {"id": 2, "string": "Each rule r of G has a value (weight of r); the weight is an element of some weight algebra K. That algebra has a binary commutative and associative operation \u2295 on its carrier set, which is used to handle ambiguity of G. As output we expect an element k \u2208 K which is the \u2295-accumulation of the weight wt(d) K of each abstract syntax tree (AST) d of a in G, i.e., k = \u2295 d\u2208AST(G,a) wt(d) K where wt(d) K is computed by other operations of the algebra K (using the weights of the occurring rules) and \u2295 is an extension of \u2295 to infinitely many summands (infinitary sum operation)."}, {"id": 3, "string": "For instance, if K = [0, 1] is the set of probabilities, \u2295 = max, \u2295 = sup, and wt(d) K is the product of all weights of occurrences of rules in d, then k is the maximal probability of an AST of a in G. Goodman (1999) developed a formal framework for weighted parsing, called semiring parsing."}, {"id": 4, "string": "As weight algebras he used complete semirings (K, \u2295, \u2297, 0, 1, \u2295 ) (Eilenberg, 1974) , i.e., \u2295 is the infinitary sum operation extending \u2295."}, {"id": 5, "string": "The binary operation \u2297 is used to compute wt(d) K ."}, {"id": 6, "string": "By appropriate choices of the complete semiring, he formalized the following problems as weighted parsing problems for a CFG G and a: the calculation of recognition, string probabilities, number of derivations, derivation forests, probability of best derivation, best derivation, and best n derivations."}, {"id": 7, "string": "The algorithm which he proposed for solving the weighted parsing problem is a pipeline with two phases."}, {"id": 8, "string": "In the first phase, the CFG G, a deduction system I (Shieber et al., 1995) , and the syntactic object a (i.e., a string) are combined into a single CFG G (using a construction idea of Bar-Hillel et al., 1961) ."}, {"id": 9, "string": "In the second phase, the value k (from above) is calculated, if G is acyclic."}, {"id": 10, "string": "1 Nederhof (2003) developed a similar framework, called weighted deductive parsing."}, {"id": 11, "string": "As weight algebras he employed algebras of the form (K, min, 0, \u2126, min ) where K is a totally ordered set, min = inf (infimum), inf(K) \u2208 K, and \u2126 is a set of superior functions; a superior function f is an operation on K which is monotone nondecreasing in each argument and f (k 1 , ."}, {"id": 12, "string": "."}, {"id": 13, "string": "."}, {"id": 14, "string": ", k m ) \u2265 max(k 1 , ."}, {"id": 15, "string": "."}, {"id": 16, "string": "."}, {"id": 17, "string": ", k m ) holds."}, {"id": 18, "string": "The algorithm which he proposed for solving the weighted parsing problem is again a pipeline with two phases, where the first phase is the same as in the framework of Goodman (1999) and the resulting CFG G is denoted by c(G, a)."}, {"id": 19, "string": "In the second phase, he employed the algorithm of Knuth (1977) , which generalizes the shortest distance algorithm of Dijkstra (1959) from graphs to hypergraphs and also works if G is cyclic."}, {"id": 20, "string": "If the CFG G is non-branching, i.e., a linear grammar (Khabbaz, 1974, Def."}, {"id": 21, "string": "1) , then in the second phase a graph algorithm can be used as an alternative to Knuth's algorithm; e.g., the single source shortest distance algorithm of Mohri (2002) if the weight algebra K is a complete semiring which is closed for G ."}, {"id": 22, "string": "In this paper, we generalize the two-phase pipeline approach of Goodman (1999) and Nederhof (2003) as follows."}, {"id": 23, "string": "We specify the LM by using the general approach of initial algebra semantics (Goguen et al., 1977) ."}, {"id": 24, "string": "For this, we employ weighted regular tree grammars (wRTG) and evaluate the generated trees (by the unique homomorphism) in some language algebra L, which provides the set of syntactic objects as carrier set."}, {"id": 25, "string": "This approach is very flexible and covers LMs for strings (CFG, LCFRS), but also trees and graphs (Drewes et al., 2016) ."}, {"id": 26, "string": "Our second generalization concerns the weight algebra."}, {"id": 27, "string": "We consider complete multioperator monoids (Kuich, 1999) which are algebras of the form (K, \u2295, 0, \u2126, \u2295 ), where \u2126 is a set of operations on K and \u2295 is the infinitary sum operation which extends \u2295."}, {"id": 28, "string": "We call the combination of such an LM and weight algebra weighted RTG-based language model (wRTG-LM)."}, {"id": 29, "string": "These combinations are very general and even exceed the scope of parsing; e.g., each algebraic dynamic programming problem (Giegerich et al., 2004) , like minimum edit distance or matrix chain multiplication, can be formalized within this framework."}, {"id": 30, "string": "For solving the weighted parsing problem, given a wRTG-LM and a syntactic object a, we formalize the first phase as canonical weighted deduction system, which uses a CYK-like deduction system."}, {"id": 31, "string": "For the second phase (value computation algorithm), we propose a generalization of Mohri's approach to hypergraphs, in the spirit of Knuth's generalization of Dijkstra's algorithm."}, {"id": 32, "string": "We prove (in sketches) that our weighted parsing algorithm is terminating and solves the weighted parsing problem for every closed wRTG-LM with a finitely decomposing language algebra."}, {"id": 33, "string": "This covers the approaches of Goodman (1999) and Nederhof (2003) ; our value computation algorithm subsumes the algorithms of Knuth (1977) and Mohri (2002) ."}, {"id": 34, "string": "Due to space restrictions, we cannot show our detailed proofs of the theorems in this paper."}, {"id": 35, "string": "Preliminaries Mathematical notions."}, {"id": 36, "string": "We let N = {0, 1, 2, ."}, {"id": 37, "string": "."}, {"id": 38, "string": ".}"}, {"id": 39, "string": "be the set of natural numbers and [m] = {1, ."}, {"id": 40, "string": "."}, {"id": 41, "string": "."}, {"id": 42, "string": ", m} for each m \u2208 N. An alphabet is a finite, nonempty set."}, {"id": 43, "string": "The powerset of a set A is denoted by P(A)."}, {"id": 44, "string": "Let f : A \u2192 B be a mapping; we extend it to the mapping f : P(A) \u2192 P(B) by letting f (U) = { f (a) | a \u2208 U}, and we denote f also by f ."}, {"id": 45, "string": "A family over A is a mapping f : I \u2192 A, where I is a countable set (index set)."}, {"id": 46, "string": "As usual, we represent each family f over A by ( f (i) | i \u2208 I) and abbreviate f (i) by f i ."}, {"id": 47, "string": "Ranked sets, trees, and regular tree grammars."}, {"id": 48, "string": "A ranked set is a set \u0393 such that each \u03b3 \u2208 \u0393 is associated with a natural number rk \u0393 (\u03b3), its rank."}, {"id": 49, "string": "The set of all elements of \u0393 with rank m \u2208 N is denoted by \u0393 m ."}, {"id": 50, "string": "A ranked set \u03a3 with \u03a3 \u2286 \u0393 is rank preserving (in \u0393) if \u03a3 m \u2286 \u0393 m for each m \u2208 N. Let H be a set."}, {"id": 51, "string": "The set of trees over \u0393 and H is defined in the usual way, where elements of H may only occur at leaves."}, {"id": 52, "string": "We denote this set by T \u0393 (H) and abbreviate T \u0393 (\u2205) by T \u0393 ."}, {"id": 53, "string": "Let t \u2208 T \u0393 (H)."}, {"id": 54, "string": "A path in t is a sequence of positions of d from the root to a leaf."}, {"id": 55, "string": "Let p be a path in t. The sequence of labels of d along p is denoted by seq (d, p) ."}, {"id": 56, "string": "A ranked alphabet is a ranked set which is an alphabet."}, {"id": 57, "string": "A regular tree grammar (RTG) (Brainerd, 1969 ) is a tuple G = (N, \u03a3, A 0 , R) where N is an alphabet (nonterminals), \u03a3 is a ranked alphabet (terminals) with N \u2229 \u03a3 = \u2205, A 0 \u2208 N (initial nonterminal), and R is finite set of rules where each rule has the form A \u2192 \u03c3(A 1 , ."}, {"id": 58, "string": "."}, {"id": 59, "string": "."}, {"id": 60, "string": ", A m ) with m \u2208 N, A, A 1 , ."}, {"id": 61, "string": "."}, {"id": 62, "string": "."}, {"id": 63, "string": ", A m \u2208 N, and \u03c3 \u2208 \u03a3 m ."}, {"id": 64, "string": "Each RTG G can be considered as a context-free grammar G (with terminal alphabet \u03a3 \u222a {(, ), comma}), which generates well-formed expressions."}, {"id": 65, "string": "Thus the derivation relation \u21d2 G is the usual derivation relation of G ."}, {"id": 66, "string": "The tree language generated by G is the set L(G) = {t \u2208 T \u03a3 | A 0 \u21d2 * G t}."}, {"id": 67, "string": "By viewing each rule A \u2192 \u03c3(A 1 , ."}, {"id": 68, "string": "."}, {"id": 69, "string": "."}, {"id": 70, "string": ", A m ) of R as symbol with rank m, we can define the set AST(G) of abstract syntax trees of G to be the set of all d \u2208 T R such that for each position w of d the following holds: if d has label A \u2192 \u03c3(A 1 , ."}, {"id": 71, "string": "."}, {"id": 72, "string": "."}, {"id": 73, "string": ", A m ) at w, then the i-th successor of w (i \u2208 [m]) is labeled by a rule with left-hand side A i (cf."}, {"id": 74, "string": "Fig."}, {"id": 75, "string": "2 )."}, {"id": 76, "string": "We define the mapping \u03c0 \u03a3 : AST(G) \u2192 T \u03a3 such that \u03c0 \u03a3 (d) is obtained from d by replacing each label A \u2192 \u03c3(A 1 , ."}, {"id": 77, "string": "."}, {"id": 78, "string": "."}, {"id": 79, "string": ", A m ) by \u03c3 (cf."}, {"id": 80, "string": "Fig."}, {"id": 81, "string": "2 )."}, {"id": 82, "string": "Hence \u03c0 \u03a3 (AST(G)) = L(G)."}, {"id": 83, "string": "\u0393-algebras."}, {"id": 84, "string": "Let \u0393 be a ranked set."}, {"id": 85, "string": "A \u0393-algebra (or: algebra) is a pair (A, \u03c6) where A is a set (carrier set) and \u03c6 is a mapping (interpretation map-ping) which maps each \u03b3 \u2208 \u0393 m (m \u2208 N) to an mary operation \u03c6(\u03b3) over A, i.e., \u03c6(\u03b3): A m \u2192 A."}, {"id": 86, "string": "In the sequel, we will sometimes identify \u03c6(\u03b3) and \u03b3 (as it is usual in algebra)."}, {"id": 87, "string": "The \u0393-term algebra is the \u0393-algebra (T \u0393 , \u03c6 \u0393 ) where \u03c6 \u0393 (\u03b3)(t 1 , ."}, {"id": 88, "string": "."}, {"id": 89, "string": "."}, {"id": 90, "string": ", t m ) = \u03b3(t 1 , ."}, {"id": 91, "string": "."}, {"id": 92, "string": "."}, {"id": 93, "string": ", t m ) for every m \u2208 N, \u03b3 \u2208 \u0393 m , and t 1 , ."}, {"id": 94, "string": "."}, {"id": 95, "string": "."}, {"id": 96, "string": ", t m \u2208 T \u0393 ."}, {"id": 97, "string": "For each \u0393-algebra (A, \u03c6) there is exactly one homomorphism, denoted by (.)"}, {"id": 98, "string": "A , from the \u0393-term algebra to (A, \u03c6) (Wechler, 1992) ."}, {"id": 99, "string": "We write its application to an argument t \u2208 T \u0393 as t A ."}, {"id": 100, "string": "Intuitively, (.)"}, {"id": 101, "string": "A evaluates a tree t in (A, \u03c6), in the same way as arithmetic expressions (e.g., 3 + 2 \u00b7 (4 + 5)) are evaluated in the {+, \u00b7}-algebra (Z, +, \u00b7) to some values (here: 21)."}, {"id": 102, "string": "Often we abbreviate an algebra (A, \u03c6) by its carrier set A."}, {"id": 103, "string": "For every a \u2208 A we let factors (a) = {b \u2208 A | b < factor * a}, where for every a, b \u2208 A, b < factor a if there is a \u03b3 \u2208 \u0393 such that b occurs in some tuple (b 1 , ."}, {"id": 104, "string": "."}, {"id": 105, "string": "."}, {"id": 106, "string": ", b m ) with \u03c6(\u03b3)(b 1 , ."}, {"id": 107, "string": "."}, {"id": 108, "string": "."}, {"id": 109, "string": ", b m ) = a."}, {"id": 110, "string": "We call (A, \u03c6) finitely de- composable if factors(a) is finite for every a \u2208 A. Monoids."}, {"id": 111, "string": "A monoid is an algebra (K, \u2295, 0) such that \u2295 is a binary, associative operation on K and 0 \u2295 k = k = k \u2295 0 for each k \u2208 K. In the rest of this paper, each occurrence of k, k 1 , k 2 , ."}, {"id": 112, "string": "."}, {"id": 113, "string": "."}, {"id": 114, "string": "is assumed to be universally quantified over K if not specified otherwise."}, {"id": 115, "string": "The monoid is commutative if \u2295 is commutative; it is extremal (Mahr, 1984) if k 1 \u2295k 2 \u2208 {k 1 , k 2 }; it is idempotent if k\u2295k = k. It is naturally ordered if the binary relation \u2286 K \u00d7 K (defined by k 1 k 2 if there is a k \u2208 K such that k 1 \u2295k = k 2 ) is anti-symmetric (in which case it is a partial order, since reflexivity and transitivity hold by definition)."}, {"id": 116, "string": "It is complete if for each countable set I, there is an operation \u2295 I which maps each family (k i | i \u2208 I) to an element of K, coincides with \u2295 when I is finite, and otherwise satisfies axioms which guarantee commutativity and associativity (Eilenberg, 1974, p. 124) ."}, {"id": 117, "string": "We abbreviate \u2295 (Karner, 1992) if for every k \u2208 K and family (k i | i \u2208 N) of elements of K the following holds: if there is an n 0 \u2208 N such that for every n \u2208 N with n \u2265 n 0 , \u2295 i\u2208N:i\u2264n k i = k, then \u2295 i\u2208N k i = k. A complete monoid is completely idempotent if for every k \u2208 K and countable set I it holds that \u2295 i\u2208I k = k. By easy calculations we obtain the following implications: (1) if K is extremal, then it is idempotent, (2) if K is completely idempotent, then it is d-complete, and (3) if K is d-complete, then it is naturally ordered."}, {"id": 118, "string": "I (k i | i \u2208 I) by \u2295 i\u2208I k i ."}, {"id": 119, "string": "A complete monoid is d-complete Multioperator monoids."}, {"id": 120, "string": "A multioperator monoid (M-monoid) (Kuich, 1999) is an algebra (K, \u2295, 0, \u2126) such that (K, \u2295, 0) is a commutative monoid and \u2126 is a set of operations on K which contains at least the unary identity id: K \u2192 K. We view \u2126 as a ranked set, and hence (K, \u03c6) as an \u2126-algebra where \u03c6(\u03c9) = \u03c9 for each \u03c9 \u2208 \u2126."}, {"id": 121, "string": "Thus t K \u2208 K is the evaluation of t \u2208 T \u2126 in the algebra (K, \u03c6)."}, {"id": 122, "string": "An M-monoid inherits the properties of its monoid (e.g., being complete)."}, {"id": 123, "string": "We denote a complete M-monoid by (K, \u2295, 0, \u2126, \u2295 )."}, {"id": 124, "string": "An M-monoid is distributive if for each m-ary \u03c9 \u2208 \u2126 and every i \u2208 [m], \u03c9(k 1,i\u22121 , k i \u2295 k, k i+1,m ) = \u03c9(k 1,i\u22121 , k i , k i+1,m ) \u2295 \u03c9(k 1,i\u22121 , k, k i+1,m ) where k 1,i\u22121 and k i+1,m abbreviate k 1 , ."}, {"id": 125, "string": "."}, {"id": 126, "string": "."}, {"id": 127, "string": ", k i\u22121 and k i+1 , ."}, {"id": 128, "string": "."}, {"id": 129, "string": "."}, {"id": 130, "string": ", k m , respectively."}, {"id": 131, "string": "If K is complete, then we additionally require that the above equation also holds for each countable set of summands."}, {"id": 132, "string": "Next we show examples of M-monoids."}, {"id": 133, "string": "\u2022 Each semiring (K, \u2295, \u2297, 0, 1) can be considered as the M-monoid (K, \u2295, 0, \u2126 \u2297 ) (F\u00fcl\u00f6p et al., 2009) where Knuth (1977) uses complete, distributive Mmonoids of the form (K, min, 0, \u2126, min ) where K is a totally ordered set, inf(K) \u2208 K, and the operations in \u2126 are superior functions."}, {"id": 134, "string": "We will call such M-monoids superior M-monoids."}, {"id": 135, "string": "We note that each superior M-monoid is dcomplete."}, {"id": 136, "string": "\u2126 \u2297 = {mul (m) k | m \u2208 N, k \u2208 K} and for every m \u2208 N we define mul (m) k (k 1 , ."}, {"id": 137, "string": "."}, {"id": 138, "string": "."}, {"id": 139, "string": ", k m ) = k \u2297 k 1 \u2297 \u00b7 \u00b7 \u00b7 \u2297 k m ."}, {"id": 140, "string": "Note that 1 = mul (0) 1 ()."}, {"id": 141, "string": "\u2022 3 Weighted RTG-based language models and the weighted parsing problem As framework for the definition of our language models we use the initial algebra approach (Goguen et al., 1977) ."}, {"id": 142, "string": "An RTG-based language model (RTG-LM) is a tuple (G, (L, \u03c6)) where \u2022 G = (N, \u03a3, A 0 , R) is an RTG and \u2022 (L, \u03c6) is a \u0393-algebra (language algebra) such that \u03a3 \u2286 \u0393 is rank preserving; the elements of L are called syntactic objects."}, {"id": 143, "string": "The language generated by (G, (L, \u03c6)) is the set from evaluating trees of L(G) in the language algebra L. For each a \u2208 L, we let L(G) L = {t L | t \u2208 L(G)} \u2286 L , i.e., AST(G, a) = {d \u2208 AST(G) | \u03c0 \u03a3 (d) L = a} ."}, {"id": 144, "string": "Example 1."}, {"id": 145, "string": "We consider the \u0393-algebra CFG \u2206 = (\u2206 * , \u03c6) as language algebra where \u2206 = {fruit, flies, like, bananas}, \u0393 = m\u2208N \u0393 m , and \u0393 m = { u 0 x 1 u 1 \u00b7 \u00b7 \u00b7 x m u m | u i \u2208 \u2206 * }."}, {"id": 146, "string": "We define \u03c6( u 0 x 1 u 1 \u00b7 \u00b7 \u00b7 x m u m )(a 1 , ."}, {"id": 147, "string": "."}, {"id": 148, "string": "."}, {"id": 149, "string": ", a m ) = u 0 a 1 u 1 \u00b7 \u00b7 \u00b7 a m u m for every a 1 , ."}, {"id": 150, "string": "."}, {"id": 151, "string": "."}, {"id": 152, "string": ", a m \u2208 \u2206 * ."}, {"id": 153, "string": "We consider the RTG G = (N, \u03a3, S, R) with N = {S, NP, VP, PP, NN, NNS, VBZ, VBP, IN} and \u03a3 = { \u03b4 | \u03b4 \u2208 \u2206} \u222a { x 1 , x 1 x 2 } \u2286 \u0393, and R contains the rules shown in Fig."}, {"id": 154, "string": "1 (ignoring the numbers above the arrows for the time being)."}, {"id": 155, "string": "The tree in the middle of the upper row of Fig."}, {"id": 156, "string": "2 is an abstract syntax tree d \u2208 AST(G)."}, {"id": 157, "string": "It expresses that certain insects (fruit flies) like something (bananas)."}, {"id": 158, "string": "We obtain \u03c0 \u03a3 (d) by dropping the non-highlighted parts of d (left of upper row)."}, {"id": 159, "string": "The application of the homomorphism (.)"}, {"id": 160, "string": "CFG \u2206 : T \u03a3 \u2192 CFG \u2206 to \u03c0 \u03a3 (d) yields the string a = fruit flies like bananas."}, {"id": 161, "string": "We note that there is another abstract syntax tree d \u2208 AST(G), viz., d = r 1 (r 2 (r 8 ), r 5 (r 11 , r 7 (r 13 , r 4 (r 10 )))) such that \u03c0 \u03a3 (d ) CFG \u2206 = a."}, {"id": 162, "string": "It expresses how fruit performs a certain activity (to fly like bananas)."}, {"id": 163, "string": "Hence this RTG-LM is ambiguous."}, {"id": 164, "string": "It should be clear from Ex."}, {"id": 165, "string": "1 that each contextfree grammar with terminal alphabet \u2206 can be represented as an RTG-LM (G, CFG \u2206 ), and vice versa, each RTG-LM (G, CFG \u2206 ) represents a CFG."}, {"id": 166, "string": "In the same way, one can characterize LCFRS and tree adjoining grammars by (1) superposing sorts to the set N of nonterminals of the RTG (in order to represent fanout and the characteristic \"substitution tree / adjoining tree\" of arguments, respectively), and (2) by defining ap-propriate \u0393-algebras LCFRS \u2206 (Kallmeyer, 2010, Def."}, {"id": 167, "string": "6.2+6 .3) and TAG \u2206 (B\u00fcchse et al., 2012; Koller and Kuhlmann, 2012) , respectively."}, {"id": 168, "string": "The language algebras CFG \u2206 , LCFRS \u2206 , and TAG \u2206 are finitely decomposable."}, {"id": 169, "string": "A weighted RTG-based language model (wRTG-LM) is a tuple (G, (L, \u03c6)), (K, \u2295, 0, \u2126, \u2295 ), wt , where \u2022 (G, (L, \u03c6)) is an RTG-LM, \u2022 (K, \u2295, 0, \u2126, \u2295 ) is a complete M-monoid (weight algebra), and \u2022 wt maps each rule of G with rank m to an mary operation in \u2126."}, {"id": 170, "string": "We lift wt to the mapping wt : T R \u2192 T \u2126 and denote wt also by wt."}, {"id": 171, "string": "Definition 2."}, {"id": 172, "string": "The weighted parsing problem is the following problem: given a wRTG-LM (G, (L, \u03c6)), (K, \u2295, 0, \u2126, \u2295 ), wt and an a \u2208 L, compute the value parse(a) \u2208 K where parse(a) = \u2295 d\u2208AST(G,a) wt(d) K ."}, {"id": 173, "string": "Example 3."}, {"id": 174, "string": "(Ex."}, {"id": 175, "string": "1 cont.)"}, {"id": 176, "string": "The best derivation problem of (Goodman, 1999) consists of computing, given a syntactic object a and a grammar, the abstract syntax trees of a with maximal probability (and this probability)."}, {"id": 177, "string": "Let R \u221e be a ranked set such that (R \u221e ) m is infinite for each m \u2208 N. In analogy to Goodman, we define the best derivation Mmonoid to be the d-complete M-monoid BD = V, max BD , (0, \u2205), \u2126 BD , max BD , where V = [0, 1] \u00d7 P(T R \u221e ) and [0, 1] is the interval of real numbers from 0 to 1 and \u2022 for every (p 1 , D 1 ), (p 2 , D 2 ) \u2208 V, the value max BD ((p 1 , D 1 ), (p 2 , D 2 )) is (p i , D i ) if p i > p j for i, j \u2208 {1, 2}, and (p 1 , D 1 \u222a D 2 ) if p 1 = p 2 , \u2022 \u2126 BD = {tc p,r | p \u2208 [0, 1] and r \u2208 R \u221e }, where for each p \u2208 [0, 1] and r \u2208 R \u221e of rank m, we define tc p,r : V m \u2192 V (tc abbreviates top concatenation) such that for every (p 1 , D 1 ), ."}, {"id": 178, "string": "."}, {"id": 179, "string": "."}, {"id": 180, "string": ", (p m , D m ) \u2208 V tc p,r (p 1 , D 1 ), ."}, {"id": 181, "string": "."}, {"id": 182, "string": "."}, {"id": 183, "string": ", (p m , D m ) = (p , D ) where p = p \u00b7 p 1 \u00b7 ."}, {"id": 184, "string": "."}, {"id": 185, "string": "."}, {"id": 186, "string": "\u00b7 p m and D = {r(d 1 , ."}, {"id": 187, "string": "."}, {"id": 188, "string": "."}, {"id": 189, "string": ", d m ) | d i \u2208 D i , 1 \u2264 i \u2264 m}, and \u2022 for every family ((p i , D i ) | i \u2208 I) over V, we define max BD i\u2208I (p i , D i ) = (p, D), where p = sup{p i | i \u2208 I} and D = i\u2208I:p i =p D i ."}, {"id": 190, "string": "Since BD is completely idempotent, it is also dcomplete."}, {"id": 191, "string": "x 1 x 2 x 1 x 2 fruit flies x 1 x 2 like x 1 bananas S \u2192 NP \u2192 NN \u2192 NNS \u2192 VP \u2192 VBP \u2192 NP \u2192 NNS \u2192 (NP, VP) (NN, NNS) (VBP, NP) (NNS) d \u2208 AST(G) x 1 x 2 x 1 x 2 fruit flies x 1 x 2 like x 1 bananas t \u2208 T \u03a3 tc 1.0,r1 tc 0.5,r3 tc 1.0,r8 tc 0.4,r9 tc 0.6,r6 tc 1.0,r12 tc 0.3,r4 tc 0.6,r10 in T \u2126 0.0216, {r 1 (r 3 (r 8 , r 9 ), r 6 (r 12 , r 4 (r 10 )))} 0.0144, {r 1 (r 2 (r 8 ), r 5 (r 11 , r 7 (r 13 , r 4 (r 10 ))))} max BD a = fruit flies like bananas Figure 2 : Illustration of the weighted parsing problem for the wRTG-LM (G, CFG \u2206 ), BD, wt and the syntactic object a = fruit flies like bananas of \u2206 * , see Ex."}, {"id": 192, "string": "3."}, {"id": 193, "string": "Now we consider the finite set R of rules of the RTG G given in Ex."}, {"id": 194, "string": "1."}, {"id": 195, "string": "We can assume that R \u2286 R \u221e is rank preserving."}, {"id": 196, "string": "We define the mapping wt: R \u2192 \u2126 BD by wt(r i ) = tc p i ,r i where p i is shown in Fig."}, {"id": 197, "string": "1 above the arrow of r i ."}, {"id": 198, "string": "For each d \u2208 AST(G, a), the second component of wt(d) BD has exactly one element."}, {"id": 199, "string": "Recall d from Ex."}, {"id": 200, "string": "1, a second AST which is evaluated to a."}, {"id": 201, "string": "We obtain wt(d ) BD = (0.0144, {r 1 (r 2 (r 8 ), r 5 (r 11 , r 7 (r 13 , r 4 (r 10 ))))})."}, {"id": 202, "string": "Thus wt(d ) \u2208 T \u2126 d \u2208 AST(G) \u03c0 \u03a3 (d ) \u2208 T \u03a3 \u03c0 \u03a3 wt (.)"}, {"id": 203, "string": "CFG \u2206 (.)"}, {"id": 204, "string": "BD (.)"}, {"id": 205, "string": "BD wt \u03c0 \u03a3 (.)"}, {"id": 206, "string": "CFG \u2206 parse max BD wt(d) BD , wt(d ) BD = wt(d) BD ."}, {"id": 207, "string": "As one might expect, it is more likely that a refers to the preferences (to like bananas) of certain insects (fruit flies)."}, {"id": 208, "string": "Fig."}, {"id": 209, "string": "2 illustrates the parsing problem for the wRTG-LM ((G, CFG \u2206 ), BD, wt) and a = fruit flies like bananas."}, {"id": 210, "string": "In summary, each wRTG-LM consists of two components: a syntax component and a weight component."}, {"id": 211, "string": "The syntax component (cf."}, {"id": 212, "string": "the left of Fig."}, {"id": 213, "string": "2 ) contains the language algebra (L, \u03c6)."}, {"id": 214, "string": "This is a \u0393-algebra whose carrier set is the set of syntactic objects."}, {"id": 215, "string": "The mapping \u03c0 \u03a3 maps each abstract syntax tree to a tree in the \u03a3-term algebra T \u03a3 , which is then evaluated to a syntactic object by the unique homomorphism (.)"}, {"id": 216, "string": "L (recall that \u03a3 \u2286 \u0393)."}, {"id": 217, "string": "The weight component (cf."}, {"id": 218, "string": "the right of Fig."}, {"id": 219, "string": "2 ) contains a complete M-monoid (K, \u2295, 0, \u2126, \u2295 ) whose carrier set is the set of weights."}, {"id": 220, "string": "The mapping wt maps each abstract syntax tree to a tree in the \u2126-term algebra T \u2126 , which is then evaluated to a weight in K by the unique homomorphism (.)"}, {"id": 221, "string": "K ."}, {"id": 222, "string": "Weights in K are accumulated using \u2295."}, {"id": 223, "string": "The weighted parsing problem takes as input a wRTG-LM and a syntactic object a, and it computes the \u2295-accumulation of the weights of each AST of a."}, {"id": 224, "string": "A \u2192 del a (A) \u03c6(del a )(w) = aw del a (n) = n + 1 A \u2192 ins a (A) \u03c6(ins a )(w) = wa ins a (n) = n + 1 A \u2192 rep a,b (A) \u03c6(rep a,b )(w) = awb rep a,b (n) = n A \u2192 nil \u03c6(nil)() = $ nil() = 0 Example 4."}, {"id": 225, "string": "Giegerich et al."}, {"id": 226, "string": "(2004) formalized dynamic programming (Bellman, 1952 (Bellman, , 1954 in an algebraic setting, called algebraic dynamic programming (ADP)."}, {"id": 227, "string": "We claim that each ADP problem is a weighted parsing problem."}, {"id": 228, "string": "To support this statement, we consider the computation of the minimum edit distance (med) between two words over some alphabet \u2206 by deletion, insertion, and replacement, and we \"simulate\" its ADPspecification as wRTG-LM ((G, (L, \u03c6)), K, wt)."}, {"id": 229, "string": "The rules of the RTG G and the interpretation \u03c6 are shown in the first and second columns of Fig."}, {"id": 230, "string": "3 , respectively."}, {"id": 231, "string": "Thus, for each tree t \u2208 L(G), t L = u$v for some u, v \u2208 \u2206 * ."}, {"id": 232, "string": "We choose the complete, distributive M-monoid (K, \u2295, \u2205, \u2126, \u2295 ) with K = {h(F) | F \u2208 P(N)} for the singlevalued objective function h: P(N) \u2192 P(N) with h(F) = {min(F)}."}, {"id": 233, "string": "We let F 1 \u2295 F 2 = h(F 1 \u222a F 2 ) for every F 1 , F 2 \u2208 K, and \u2295 i\u2208N F i = {inf( i\u2208N F i )}."}, {"id": 234, "string": "The set \u2126 is shown in the third column of Fig."}, {"id": 235, "string": "3 ."}, {"id": 236, "string": "Note that h satisfies Bellman's principle of optimality: h(\u03c9(F)) = h(\u03c9(h(F))) for each unary \u03c9 \u2208 \u2126 and F \u2208 K. Then med (u, v) = parse(u$v \u22121 ) for every u, v \u2208 \u2206 * , where v \u22121 is the reversal of v. This construction can be generalized to a procedure which turns every specification of an ADP problem into a weighted parsing problem."}, {"id": 237, "string": "Due to space restrictions, we cannot present this procedure in its entirety."}, {"id": 238, "string": "The weighted parsing algorithm The weighted parsing algorithm is supposed to solve the weighted parsing problem."}, {"id": 239, "string": "As input, it takes a wRTG-LM G and a syntactic object a."}, {"id": 240, "string": "Its output is intended to be parse(a)."}, {"id": 241, "string": "The algorithm is a pipeline with two phases (cf."}, {"id": 242, "string": "Fig."}, {"id": 243, "string": "4 ) and follows the modular approach of Nederhof (2003) ."}, {"id": 244, "string": "First, a canonical weighted deduction system computes from G and a a new wRTG-LM G with the same weight structure as G, but a different RTG and the language algebra CFG \u2205 ."}, {"id": 245, "string": "Second, G is the input to the value computation algorithm (Alg."}, {"id": 246, "string": "1), which computes the value V(A 0 ); this is supposed to be \u2295 d\u2208AST(G ) wt(d) K = parse(a)."}, {"id": 247, "string": "Weighted deduction systems."}, {"id": 248, "string": "Parsing of some string w with some grammar G can be formalized as a deduction system D (Shieber et al., 1995) ."}, {"id": 249, "string": "D consists of a set of inference rules I 1 ..."}, {"id": 250, "string": "I m I {c 1 , ."}, {"id": 251, "string": "."}, {"id": 252, "string": "."}, {"id": 253, "string": ", c p } where m \u2208 N, I, I 1 , ."}, {"id": 254, "string": "."}, {"id": 255, "string": "."}, {"id": 256, "string": ", I m are items, and c 1 , ."}, {"id": 257, "string": "."}, {"id": 258, "string": "."}, {"id": 259, "string": ", c p are side conditions."}, {"id": 260, "string": "Each item represents a Boolean-valued property (of some combination of nonterminals of G and/or substrings of a = w)."}, {"id": 261, "string": "The meaning of an inference rule is: given that I 1 , ."}, {"id": 262, "string": "."}, {"id": 263, "string": "."}, {"id": 264, "string": ", I m and c 1 , ."}, {"id": 265, "string": "."}, {"id": 266, "string": "."}, {"id": 267, "string": ", c p are true, I is true as well."}, {"id": 268, "string": "Nederhof (2003) pointed out that \"a deduction system having a grammar G [...] and input string w in the side conditions can be seen as a construction c of a context-free grammar c(G, w) [...]\"; also, he extended D and c(G, a) with weights."}, {"id": 269, "string": "Inspired by this, we define the canonical weighted deduction system as a mapping cwds which takes two arguments: (a) a wRTG-LM G = (G, L), K, wt such that the language algebra (L, \u03c6) is finitely decomposable and (b) a syntactic object a \u2208 L. Let G = (N, \u03a3, A 0 , R) ."}, {"id": 270, "string": "Then we define cwds G, a = (G , CFG \u2205 ), K, wt , where G = (N , \u03a3 , A 0 , R ) and a) , and \u2022 for each \u03c3 \u2208 \u03a3, the rule r = (A 0 , a) \u2192 (A 0 , \u03c3, a) is in R and wt (r ) = id; for each r = A \u2192 \u03c3(A 1 , ."}, {"id": 271, "string": "."}, {"id": 272, "string": "."}, {"id": 273, "string": ", A m ) in R and a 0 , a 1 , ."}, {"id": 274, "string": "."}, {"id": 275, "string": "."}, {"id": 276, "string": ", a m \u2208 factors(a) with \u03c6(\u03c3)(a 1 , ."}, {"id": 277, "string": "."}, {"id": 278, "string": "."}, {"id": 279, "string": ", a m ) = a 0 and every \u2022 N = {(A 0 , a)} \u222a N \u00d7 \u03a3 \u00d7 factors(a) ; N is finite, because L is finitely decomposable, \u2022 \u03a3 = { x 1 ."}, {"id": 280, "string": "."}, {"id": 281, "string": "."}, {"id": 282, "string": "x m | a rule with rank m is in R}, \u2022 A 0 = (A 0 , rule A i \u2192 \u03c3 i (."}, {"id": 283, "string": "."}, {"id": 284, "string": ". )"}, {"id": 285, "string": "(i \u2208 [m]) in R, the rule r (A, \u03c3, a 0 ) \u2192 x 1 ."}, {"id": 286, "string": "."}, {"id": 287, "string": "."}, {"id": 288, "string": "x m (A 1 , \u03c3 1 , a 1 ), ."}, {"id": 289, "string": "."}, {"id": 290, "string": "."}, {"id": 291, "string": ", (A m , \u03c3 m , a m ) is in R and we let wt (r ) = wt(r)."}, {"id": 292, "string": "Note that cwds implements a CYK-like deduction system."}, {"id": 293, "string": "The elements of N have a very general form."}, {"id": 294, "string": "Depending on L, they can be understood as, e.g., spans of strings, occurrences of patterns in trees, or occurrences of subgraphs in graphs."}, {"id": 295, "string": "We note that for every d \u2208 AST(G ) it holds that \u03c0 \u03a3 (d) CFG \u2205 = \u03b5, i.e., each abstract syntax tree is evaluated to the empty string."}, {"id": 296, "string": "Moreover, cwds is weight-preserving in the following sense: (1) there is a bijective mapping \u03c8 from the set AST(G, a) to AST(G ) and (2) for every d \u2208 AST(G, a) we have that wt(d) K = wt (\u03c8(d)) K ."}, {"id": 297, "string": "Value computation algorithm."}, {"id": 298, "string": "This is Alg."}, {"id": 299, "string": "1."}, {"id": 300, "string": "Its input is a wRTG-LM G with language algebra CFG \u2205 ."}, {"id": 301, "string": "It maintains a mapping V, which assigns a weight to each nonterminal, and a Boolean variable changed."}, {"id": 302, "string": "The output is the value V(A 0 )."}, {"id": 303, "string": "The algorithm starts by assigning the weight 0 to each nonterminal (lines 1-2)."}, {"id": 304, "string": "Then, in a repeat-until loop (lines 3-12), the weight of each nonterminal is recomputed in every iteration of that loop as follows (where x 1,m abbreviates x 1 , ."}, {"id": 305, "string": "."}, {"id": 306, "string": "."}, {"id": 307, "string": ", x m ): V(A) = r\u2208R : r=(A\u2192 x 1,m (A 1 ,...,A m )) wt (r) V(A 1 ), ."}, {"id": 308, "string": "."}, {"id": 309, "string": "."}, {"id": 310, "string": ", V(A m ) ."}, {"id": 311, "string": "Algorithm 1 Value computation algorithm Input: (G , CFG \u2205 ), (K, \u2295, 0, \u2126, \u2295 ), wt which is a wRTG-LM with G = (N , \u03a3 , A 0 , R ) Variables: V: N \u2192 K, V \u2208 K, changed \u2208 B Output: V(A 0 ) 1: for each A \u2208 N do 2: V(A) \u2190 0 3: repeat 4: changed \u2190 false 5: for each A \u2208 N do 6: V \u2190 0 7: for each r = (A \u2192 x 1,m (A 1 , ."}, {"id": 312, "string": "."}, {"id": 313, "string": "."}, {"id": 314, "string": ", A m )) in R do 8: V \u2190 V \u2295 wt (r) V(A 1 ), ."}, {"id": 315, "string": "."}, {"id": 316, "string": "."}, {"id": 317, "string": ", V(A m ) 9: if V(A) V then 10: changed \u2190 true 11: V(A) \u2190 V 12: until changed = false The algorithm terminates after the first iteration in which no nonterminal has changed its weight."}, {"id": 318, "string": "We note that in practice, a complete computation of cwds(G, a) prior to the execution of the value computation algorithm (Alg."}, {"id": 319, "string": "1) is impossible."}, {"id": 320, "string": "Similar to Nederhof (2003) , we execute the value computation algorithm on an incomplete input which is extended on demand (lazy evaluation)."}, {"id": 321, "string": "More precisely, G is initialized so that it only contains the rules of rank 0 (and the nonterminals in their left-hand sides)."}, {"id": 322, "string": "Then, each time a value different from 0 is first assigned to a nonterminal A in line 11, we compute the following set of rules: each rule whose right-hand side only contains A and other nonterminals for which this computation has already been done is in that set."}, {"id": 323, "string": "These new rules (and the nonterminals in their left-hand sides) are added to G ."}, {"id": 324, "string": "Termination and correctness We are interested in two formal properties of the value computation algorithm (Alg."}, {"id": 325, "string": "1) and of the weighted parsing algorithm (Fig."}, {"id": 326, "string": "4) : termination and correctness."}, {"id": 327, "string": "The value computation algorithm computes the weights of the ASTs bottom-up and reuses the results of common subtrees (as in dynamic programming); this requires distributivity of the weight algebra."}, {"id": 328, "string": "Moreover, solving the weighted parsing problem by a terminating algorithm involves the following difficulty: there may be infinitely many ASTs (due to cycles) which are evaluated to the same syntactic object a."}, {"id": 329, "string": "Thus parse(a) is an infinite sum, which in general cannot be computed in finite time."}, {"id": 330, "string": "Hence, a terminating algorithm can only solve the weighted parsing problem if the infinite sum is equal to the sum over some finite subset of the infinite sum's index set."}, {"id": 331, "string": "We have organized this section as follows."}, {"id": 332, "string": "In Subsection 5.1 we define the class of closed wRTG-LMs (similar to Mohri, 2002) and prove that the value computation algorithm (Alg."}, {"id": 333, "string": "1) is terminating and correct for closed wRTG-LMs as input."}, {"id": 334, "string": "We say that the value computation algorithm is correct if after termination V(A 0 ) = \u2295 d\u2208AST(G ) wt (d) K ."}, {"id": 335, "string": "In Subsection 5.2 we prove that the weighted parsing algorithm (Fig."}, {"id": 336, "string": "4) is terminating and correct for two classes of inputs."}, {"id": 337, "string": "We say that the weighted parsing algorithm is correct if it computes parse(a)."}, {"id": 338, "string": "Properties of the value computation algorithm Since each wRTG-LM has a finite set of rules, an infinite set of ASTs is only possible if the ASTs are cyclic in the following sense."}, {"id": 339, "string": "Recall that R is the set of rules of the input G to the value computation algorithm (Alg."}, {"id": 340, "string": "1)."}, {"id": 341, "string": "Let \u03c1 \u2208 (R ) * ."}, {"id": 342, "string": "We call \u03c1 cyclic if |\u03c1| \u2265 2, \u03c1 1 = \u03c1 |\u03c1| , and for every i, j \u2208 N, if 1 \u2264 i < j < |\u03c1|, then \u03c1 i \u03c1 j ."}, {"id": 343, "string": "From now on, let \u03c1 \u2208 (R ) * be cyclic, d \u2208 T R , and c \u2208 N. A path p in d is (c, \u03c1)-cyclic if \u03c1 occurs exactly c times in seq (d, p) ."}, {"id": 344, "string": "We define the set cutout(d, \u03c1) which contains every tree obtained from d by cutting out at least one occurrence of \u03c1."}, {"id": 345, "string": "We illustrate cutout by an example in Fig."}, {"id": 346, "string": "5 ."}, {"id": 347, "string": "Definition 5."}, {"id": 348, "string": "Let c \u2208 N. A wRTG-LM G = (G , CFG \u2205 ), K, wt is c-closed if K is distributive and d-complete, and for each d \u2208 T R and cyclic string \u03c1 \u2208 (R ) * the following holds: if there is a (c, \u03c1)-cyclic path in d, then R \u2229AST(G ) for every c \u2208 N. Theorem 6."}, {"id": 349, "string": "For every c \u2208 N and c-closed wRTG-LM (G , CFG \u2205 ), K, wt the following holds: wt (d) K \u2295 d \u2208cutout(d,\u03c1) wt (d ) K = d \u2208cutout(d,\u03c1) wt (d ) K ."}, {"id": 350, "string": "G is closed if it is c-closed for some c \u2208 N. \u2295 d\u2208AST(G ) wt (d) K = d\u2208AST(G ) (c) wt (d) K ."}, {"id": 351, "string": "Proof (sketch)."}, {"id": 352, "string": "As K is distributive, we can show by induction on n \u2208 N that for every B \u2286 AST(G ) AST(G ) (c) with |B| = n, adding B to the index set of \u2295 does not change the sum's value."}, {"id": 353, "string": "Then, as K is d-complete, the equality holds."}, {"id": 354, "string": "This theorem reflects the desired property: given that our wRTG-LM is c-closed (with c \u2208 N), each (possibly infinite) sum over all ASTs can be computed as a sum over the finite set AST(G ) (c) ."}, {"id": 355, "string": "Theorem 7."}, {"id": 356, "string": "The value computation algorithm (Alg."}, {"id": 357, "string": "1) is terminating and correct for every closed wRTG-LM G with language algebra CFG \u2205 ."}, {"id": 358, "string": "Proof (sketch)."}, {"id": 359, "string": "Let G be c-closed."}, {"id": 360, "string": "We note that in line 8, the value in the right-hand side of \u2295 always corresponds to the sum over the weights of some trees in (T R ) A ; this is due to the fact that K is distributive."}, {"id": 361, "string": "By the form of recomputation in lines 3-12, each d \u2208 (T R ) A contributes to that sum at most once."}, {"id": 362, "string": "Furthermore, V only differs from V(A) if a tree from the finite set T (c) R has been used to compute V , but not V(A) (this is a consequence of G being closed)."}, {"id": 363, "string": "Thus, changed is only set to true finitely often and the algorithm eventually terminates."}, {"id": 364, "string": "Then, after termination, V(A 0 ) = d\u2208AST(G ) (c) wt (d) K and Theorem 6 implies correctness."}, {"id": 365, "string": "Properties of the weighted parsing algorithm We discuss two classes of wRTG-LMs for which the weighted parsing algorithm (Fig."}, {"id": 366, "string": "4) is termi-nating and correct."}, {"id": 367, "string": "(1) Closed wRTG-LMs with arbitrary language algebras."}, {"id": 368, "string": "Each of them is a wRTG-LM (G, (L, \u03c6)), (K, \u2295, 0, \u2126, \u2295 ), wt which is c-closed for some c \u2208 N, and c-closed is defined as in Def."}, {"id": 369, "string": "5."}, {"id": 370, "string": "(We note that this generalization is possible because Def."}, {"id": 371, "string": "5 does not use any property of CFG \u2205 .)"}, {"id": 372, "string": "The following particular wRTG-LMs are closed: \u2022 wRTG-LMs with acyclic RTG, where an RTG G is acyclic if AST(G) = AST(G) (0) , \u2022 wRTG-LMs with superior, d-complete Mmonoids as weight algebras, and \u2022 wRTG-LMs with weight algebra BD if no chain rule and \u03b5-rule has probability 1.0 (as in Ex."}, {"id": 373, "string": "3)."}, {"id": 374, "string": "(2) Non-looping wRTG-LMs with distributive Mmonoids as weight algebras."}, {"id": 375, "string": "A wRTG-LM G is non-looping if for every syntactic object a and tree d over the set of rules of G which is evaluated to a the following holds: no proper subtree of d is evaluated to a. ADP problems can be specified by non-looping wRTG-LMs, because the syntactic objects of ADP represent (sub-)problems which have to be solved."}, {"id": 376, "string": "Thus, if G is looping, then the solution of a subproblem would depend on itself, which contradicts dynamic programming."}, {"id": 377, "string": "In general, non-looping is not decidable, but it is for particular language algebras, e.g., CFG \u2206 ."}, {"id": 378, "string": "Lemma 8."}, {"id": 379, "string": "For every closed or nonlooping wRTG-LM G with finitely decomposable language algebra and syntactic object a, the wRTG-LM cwds(G, a) is closed."}, {"id": 380, "string": "Theorem 9."}, {"id": 381, "string": "The weighted parsing algorithm (Fig."}, {"id": 382, "string": "4) is terminating and correct for every closed or nonlooping wRTG-LM with finitely decomposable language algebra."}, {"id": 383, "string": "Proof."}, {"id": 384, "string": "The weighted parsing algorithm terminates because (a) the computation of cwds is terminating algorithm class of valid inputs class C 1 of RTG class C 2 of weight algebras (a) Knuth (1977) C 1 \u00d7 C 2 RTG superior M-monoid (b) Goodman (1999) C 1 \u00d7 C 2 acyclic RTG complete semiring (c) Mohri (2002) C 2 closed for C 1 monadic RTG commutative, d-complete semiring (d) Alg."}, {"id": 385, "string": "1 closed wRTG-LM RTG distributive, d-complete M-monoid = V(A 0 ) ."}, {"id": 386, "string": "Comparison of value computation algorithms Here we compare our value computation algorithm (Alg."}, {"id": 387, "string": "1) to the algorithm of Knuth (1977) , the second phase of Goodman (1999) , and the algorithm of Mohri (2002) ."}, {"id": 388, "string": "We focus on the question of applicability of the algorithms, i.e., we identify the classes of inputs for which the algorithms are terminating and correct (class of valid inputs)."}, {"id": 389, "string": "In order to have a basis for a fair comparison, we understand the inputs of the algorithms of Knuth (1977) , Goodman (1999) , and Mohri (2002) as particular wRTG-LMs of the form (G , CFG \u2205 ), (K, \u2295, 0, \u2126, \u2295 ), wt with G = (N , \u03a3 , A 0 , R )."}, {"id": 390, "string": "An algorithm is correct for such a wRTG-LM if it returns \u2295 d\u2208AST(G ) wt (d) K ."}, {"id": 391, "string": "We employ two parameters: C 1 (subset of the class of all RTGs) and C 2 (subset of the class of all weight algebras)."}, {"id": 392, "string": "Tab."}, {"id": 393, "string": "1 shows the classes of valid inputs parameterized with values for C 1 and C 2 ."}, {"id": 394, "string": "Each valid input in rows (a)-(d) is a closed wRTG-LM."}, {"id": 395, "string": "Thus, if one of the value computation algorithms (a)-(c) is applicable, then our value computation algorithm (Alg."}, {"id": 396, "string": "1) is applicable too."}, {"id": 397, "string": "In particular, Alg."}, {"id": 398, "string": "1 is applicable to wRTG-LMs with the best derivation M-monoid BD as weight algebra (cf."}, {"id": 399, "string": "Ex."}, {"id": 400, "string": "3), which in general is the case for neither of algorithms (a)-(c)."}, {"id": 401, "string": "The reason for this is that BD is not superior (opposing (a)) and RTG-LMs are in general neither acyclic (opposing (b)) nor monadic (opposing (c))."}, {"id": 402, "string": "The same holds for ADP problems."}, {"id": 403, "string": "We cannot give a general statement about the complexity of our value computation algorithm (Alg."}, {"id": 404, "string": "1), because the operations in the weight algebra of a wRTG-LM can be undecidable."}, {"id": 405, "string": "If we abstract from the costs of particular operations, then we obtain the complexity of Mohri's algorithm."}, {"id": 406, "string": "This complexity depends on the number of times the value of a nonterminal changes, which in general is not polynomial in the size of the input wRTG-LM."}, {"id": 407, "string": "Mohri circumvents this problem by specifying the order in which nonterminals are processed for well-known classes of inputs, e.g., acyclic graphs or superior weight algebras."}, {"id": 408, "string": "We can adapt this idea by imposing such an ordering on the iteration over the nonterminals in line 5."}, {"id": 409, "string": "Thus our value computation algorithm achieves the same complexity as Knuth's algorithm (if the input is restricted to superior wRTG-LMs) or the algorithm in Goodman's second phase (if the input is restricted to acyclic wRTG-LMs), respectively."}, {"id": 410, "string": "We note that although our value computation algorithm (Alg."}, {"id": 411, "string": "1) has the same complexity as the other algorithms, in average it performs more computations than those."}, {"id": 412, "string": "This is because in each iteration of lines 5-11, the values of all nonterminals are recomputed."}, {"id": 413, "string": "This could be avoided by using a direct generalization of Mohri's algorithm to the branching case rather than Alg."}, {"id": 414, "string": "1."}, {"id": 415, "string": "However, the intricacies of such a generalization would exceed the scope of this paper."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 34}, {"section": "Preliminaries", "n": "2", "start": 35, "end": 237}, {"section": "The weighted parsing algorithm", "n": "4", "start": 238, "end": 323}, {"section": "Termination and correctness", "n": "5", "start": 324, "end": 337}, {"section": "Properties of the value computation algorithm", "n": "5.1", "start": 338, "end": 364}, {"section": "Properties of the weighted parsing algorithm", "n": "5.2", "start": 365, "end": 385}, {"section": "Comparison of value computation algorithms", "n": "6", "start": 386, "end": 415}], "figures": [{"filename": "../figure/image/1103-Figure4-1.png", "caption": "Figure 4: Two-phase pipeline for solving the weighted parsing problem (A\u20320 is the initial nonterminal of G \u2032).", "page": 5, "bbox": {"x1": 72.96, "x2": 524.64, "y1": 53.28, "y2": 119.03999999999999}}, {"filename": "../figure/image/1103-Figure5-1.png", "caption": "Figure 5: Top: tree d over the ranked set R\u2032 = {r(2)1 , r (1) 2 , r (1) 3 , r (0) 4 } with a (2, \u03c1)-cyclic path (horizontal line) for \u03c1 = r1r2r1. Bottom: the set cutout(d, \u03c1). Please do not confuse the elements of R\u2032 with the rules of Ex. 1 and 3.", "page": 7, "bbox": {"x1": 86.39999999999999, "x2": 510.71999999999997, "y1": 65.75999999999999, "y2": 169.44}}, {"filename": "../figure/image/1103-Figure1-1.png", "caption": "Figure 1: Rules of RTG of Ex. 1.", "page": 3, "bbox": {"x1": 80.64, "x2": 281.76, "y1": 64.32, "y2": 183.84}}, {"filename": "../figure/image/1103-Table1-1.png", "caption": "Table 1: Comparison of four value computation algorithms. The second column represents the class of wRTG-LMs to which the corresponding algorithm is applicable. The expression C1 \u00d7 C2 denotes the class of all wRTG-LMs with RTGs in C1 and weight algebras in C2.", "page": 8, "bbox": {"x1": 108.0, "x2": 487.2, "y1": 62.4, "y2": 125.28}}, {"filename": "../figure/image/1103-Figure3-1.png", "caption": "Figure 3: Rules of G for each a, b \u2208 \u2206, the interpretation \u03c6, and the operations in \u2126 where n\u2032 = n + 1 if a , b, and n otherwise.", "page": 4, "bbox": {"x1": 316.8, "x2": 516.0, "y1": 323.03999999999996, "y2": 371.52}}, {"filename": "../figure/image/1103-Figure2-1.png", "caption": "Figure 2: Illustration of the weighted parsing problem for the wRTG-LM ( (G,CFG\u2206),BD,wt ) and the syntactic object a = fruit flies like bananas of \u2206\u2217, see Ex. 3.", "page": 4, "bbox": {"x1": 73.92, "x2": 523.68, "y1": 65.75999999999999, "y2": 261.59999999999997}}]}