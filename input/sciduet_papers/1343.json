{"title": "Sequence-to-sequence Models for Cache Transition Systems", "abstract": "In this paper, we present a sequenceto-sequence based approach for mapping natural language sentences to AMR semantic graphs. We transform the sequence to graph mapping problem to a word sequence to transition action sequence problem using a special transition system called a cache transition system. To address the sparsity issue of neural AMR parsing, we feed feature embeddings from the transition state to provide relevant local information for each decoder state. We present a monotonic hard attention model for the transition framework to handle the strictly left-to-right alignment between each transition state and the current buffer input focus. We evaluate our neural transition model on the AMR parsing task, and our parser outperforms other sequence-to-sequence approaches and achieves competitive results in comparison with the best-performing models. 1", "text": [{"id": 0, "string": "Introduction Abstract Meaning Representation (AMR) (Banarescu et al., 2013 ) is a semantic formalism where the meaning of a sentence is encoded as a rooted, directed graph."}, {"id": 1, "string": "Figure 1 shows an example of an AMR in which the nodes represent the AMR concepts and the edges represent the relations between the concepts."}, {"id": 2, "string": "AMR has been used in various applications such as text summarization (Liu et al., 2015) , sentence compression (Takase et al., 2016) , and event extraction (Huang et al., 2016) ."}, {"id": 3, "string": "1 The implementation of our parser is available at https://github.com/xiaochang13/CacheTransition-Seq2seq The task of AMR graph parsing is to map natural language strings to AMR semantic graphs."}, {"id": 4, "string": "Different parsers have been developed to tackle this problem (Flanigan et al., 2014; Wang et al., 2015b,a; Peng et al., 2015; Artzi et al., 2015; Pust et al., 2015; van Noord and Bos, 2017) ."}, {"id": 5, "string": "On the other hand, due to the limited amount of labeled data and the large output vocabulary, the sequence-to-sequence model has not been very successful on AMR parsing."}, {"id": 6, "string": "Peng et al."}, {"id": 7, "string": "(2017) propose a linearization approach that encodes labeled graphs as sequences."}, {"id": 8, "string": "To address the data sparsity issue, low-frequency entities and tokens are mapped to special categories to reduce the vocabulary size for the neural models."}, {"id": 9, "string": "Konstas et al."}, {"id": 10, "string": "(2017) use self-training on a huge amount of unlabeled text to lower the out-of-vocabulary rate."}, {"id": 11, "string": "However, the final performance still falls behind the best-performing models."}, {"id": 12, "string": "The best performing AMR parsers model graph structures directly."}, {"id": 13, "string": "One approach to modeling graph structures is to use a transition system to build graphs step by step, as shown by the system of , which is currently the top performing system."}, {"id": 14, "string": "This raises the question of whether the advantages of neural and transitionbased system can be combined, as for example with the syntactic parser of Dyer et al."}, {"id": 15, "string": "(2015) , who use stack LSTMs to capture action history information in the transition state of the transition system."}, {"id": 16, "string": "Ballesteros and Al-Onaizan (2017) apply stack-LSTM to transition-based AMR parsing and achieve competitive results, which shows that local transition state information is important for predicting transition actions."}, {"id": 17, "string": "Instead of linearizing the target AMR graph to a sequence structure, Buys and Blunsom (2017) propose a sequence-to-action-sequence approach where the reference AMR graph is replaced with an action derivation sequence by running a deterministic oracle algorithm on the training sentence, AMR graph pairs."}, {"id": 18, "string": "They use a separate alignment probability to explicitly model the hard alignment from graph nodes to sentence tokens in the buffer."}, {"id": 19, "string": "propose a special transition framework called a cache transition system to generate the set of semantic graphs."}, {"id": 20, "string": "They adapt the stack-based parsing system by adding a working set, which they refer to as a cache, to the traditional stack and buffer."}, {"id": 21, "string": "apply the cache transition system to AMR parsing and design refined action phases, each modeled with a separate feedforward neural network, to deal with some practical implementation issues."}, {"id": 22, "string": "In this paper, we propose a sequence-to-actionsequence approach for AMR parsing with cache transition systems."}, {"id": 23, "string": "We want to take advantage of the sequence-to-sequence model to encode wholesentence context information and the history action sequence, while using the transition system to constrain the possible output."}, {"id": 24, "string": "The transition system can also provide better local context information than the linearized graph representation, which is important for neural AMR parsing given the limited amount of data."}, {"id": 25, "string": "More specifically, we use bi-LSTM to encode two levels of input information for AMR parsing: word level and concept level, each refined with more general category information such as lemmatization, POS tags, and concept categories."}, {"id": 26, "string": "We also want to make better use of the complex transition system to address the data sparsity issue for neural AMR parsing."}, {"id": 27, "string": "We extend the hard attention model of Aharoni and Goldberg (2017) , which deals with the nearly-monotonic alignment in the morphological inflection task, to the more general scenario of transition systems where the input buffer is processed from left-to-right."}, {"id": 28, "string": "When we process the buffer in this ordered manner, the sequence of target transition actions are also strictly aligned left-to-right according to the input order."}, {"id": 29, "string": "On the decoder side, we augment the prediction of output action with embedding features from the current transition state."}, {"id": 30, "string": "Our experiments show that encoding information from the transition state significantly improves sequenceto-sequence models for AMR parsing."}, {"id": 31, "string": "Cache Transition Parser We adopt the transition system of , which has been shown to have good coverage of the graphs found in AMR."}, {"id": 32, "string": "A cache transition parser consists of a stack, a cache, and an input buffer."}, {"id": 33, "string": "The stack is a sequence \u03c3 of (integer, concept) pairs, as explained below, with the topmost element always at the rightmost position."}, {"id": 34, "string": "The buffer is a sequence of ordered concepts \u03b2 containing a suffix of the input concept sequence, with the first element to be read as a newly introduced concept/vertex of the graph."}, {"id": 35, "string": "(We use the terms concept and vertex interchangeably in this paper.)"}, {"id": 36, "string": "Finally, the cache is a sequence of concepts \u03b7 = [v 1 , ."}, {"id": 37, "string": "."}, {"id": 38, "string": "."}, {"id": 39, "string": ", v m ]."}, {"id": 40, "string": "The element at the leftmost position is called the first element of the cache, and the element at the rightmost position is called the last element."}, {"id": 41, "string": "Operationally, the functioning of the parser can be described in terms of configurations and transitions."}, {"id": 42, "string": "A configuration of our parser has the form: C = (\u03c3, \u03b7, \u03b2, G p ) where \u03c3, \u03b7 and \u03b2 are as described above, and G p is the partial graph that has been built so far."}, {"id": 43, "string": "The initial configuration of the parser is ([], [$, ."}, {"id": 44, "string": "."}, {"id": 45, "string": "."}, {"id": 46, "string": ", $], [c 1 , ."}, {"id": 47, "string": "."}, {"id": 48, "string": "."}, {"id": 49, "string": ", c n ], \u2205), meaning that the stack and the partial graph are initially empty, and the cache is filled with m occurrences of the special symbol $."}, {"id": 50, "string": "The buffer is initialized with all the graph vertices constrained by the order of the input sentence."}, {"id": 51, "string": "The final configuration is ([], [$, ."}, {"id": 52, "string": "."}, {"id": 53, "string": "."}, {"id": 54, "string": ", $] , [], G), where the stack and the cache are as in the initial configuration and the buffer is empty."}, {"id": 55, "string": "The constructed graph is the target AMR graph."}, {"id": 56, "string": "In the first step, which is called concept identification, we map the input sentence w 1:n = w 1 , ."}, {"id": 57, "string": "."}, {"id": 58, "string": "."}, {"id": 59, "string": ", w n to a sequence of concepts c 1:n = c 1 , ."}, {"id": 60, "string": "."}, {"id": 61, "string": "."}, {"id": 62, "string": ", c n ."}, {"id": 63, "string": "We decouple the problem of concept identification from the transition system and initialize the buffer with a recognized concept sequence from another classifier, which we will introduce later."}, {"id": 64, "string": "As the sequence-to-sequence model uses all possible output actions as the target vocabulary, this can significantly reduce the target vocabulary size."}, {"id": 65, "string": "The transitions of the parser are specified as follows."}, {"id": 66, "string": "1."}, {"id": 67, "string": "Pop pops a pair (i, v) from the stack, where the integer i records the position in the cache that it originally came from."}, {"id": 68, "string": "We place concept v in position i in the cache, shifting the remainder of the cache one position to the right, and discarding the last element in the cache."}, {"id": 69, "string": "2."}, {"id": 70, "string": "Shift signals that we will start processing the next input concept, which will become a new vertex in the output graph."}, {"id": 71, "string": "3."}, {"id": 72, "string": "PushIndex(i) shifts the next input concept out of the buffer and moves it into the last position of the cache."}, {"id": 73, "string": "We also take out the concept v i appearing at position i in the cache and push it onto the stack \u03c3, along with the integer i recording its original position in the cache."}, {"id": 74, "string": "2 4."}, {"id": 75, "string": "Arc(i, d, l) builds an arc with direction d and label l between the rightmost concept and the i-th concept in the cache."}, {"id": 76, "string": "The label l is NULL if no arc is made and we use the action NOARC in this case."}, {"id": 77, "string": "Otherwise we decompose the arc decision into two actions ARC and d-l. We consider all arc decisions between the rightmost cache concept and each of the other concepts in the cache."}, {"id": 78, "string": "We can consider this phase as first making a binary decision whether there is an arc, and then predicting the label in case there is one, between each concept pair."}, {"id": 79, "string": "Given the sentence \"John wants to go\" and the recognized concept sequence \"Per want-01 go-01\" (person name category Per for \"John\"), our cache transition parser can construct the AMR graph shown in Figure 1 using the run shown in Figure 2 with cache size of 3."}, {"id": 80, "string": "Oracle Extraction Algorithm We use the following oracle algorithm (Nivre, 2008) to derive the sequence of actions that leads to the gold AMR graph for a cache transition parser with cache size m. The correctness of the oracle is shown by ."}, {"id": 81, "string": "Let E G be the set of edges of the gold graph G. We maintain the set of vertices that is not yet shifted into the cache as S, which is initialized with all vertices in G. The vertices are ordered according to their aligned position in the word sequence and the unaligned vertices are listed according to their order in the depth-first traversal of the graph."}, {"id": 82, "string": "The oracle algorithm can look into E G to decide which transition to take next, or else to decide that it should fail."}, {"id": 83, "string": "This decision is based on the mutually exclusive rules listed below."}, {"id": 84, "string": "ShiftOrPop phase: the oracle chooses transi - tion Pop, in case there is no edge (v m , v) in E G such that vertex v is in S, or chooses tran- sition Shift and proceeds to the next phase."}, {"id": 85, "string": "2."}, {"id": 86, "string": "PushIndex phase: in this phase, the oracle first chooses a position i (as explained below) in the cache to place the candidate concept and removes the vertex at this position and places its index, vertex pair onto the stack."}, {"id": 87, "string": "The oracle chooses transition PushIndex(i) and proceeds to the next phase."}, {"id": 88, "string": "3."}, {"id": 89, "string": "ArcBinary, ArcLabel phases: between the rightmost cache concept and each concept in the cache, we make a binary decision about whether there is an arc between them."}, {"id": 90, "string": "If there is an arc, the oracle chooses its direction and label."}, {"id": 91, "string": "After arc decisions to m\u22121 cache concepts are made, we jump to the next step."}, {"id": 92, "string": "4."}, {"id": 93, "string": "If the stack and buffer are both empty, and the cache is in the initial state, the oracle finishes with success, otherwise we proceed to the first step."}, {"id": 94, "string": "We use the equation below to choose the cache concept to take out in the step PushIndex(i)."}, {"id": 95, "string": "For j \u2208 [|\u03b2|], we write \u03b2 j to denote the j-th vertex in \u03b2."}, {"id": 96, "string": "We choose a vertex v i * in \u03b7 such that: In words, v i * is the concept from the cache whose closest neighbor in the buffer \u03b2 is furthest forward in \u03b2."}, {"id": 97, "string": "We move out of the cache vertex v i * and push it onto the stack, for later processing."}, {"id": 98, "string": "i * = argmax i\u2208[m] min {j | (v i , \u03b2 j ) \u2208 E G } For each training example (x 1:n , g), the transition system generates the output AMR graph g from the input sequence x 1:n through an oracle sequence a 1:q \u2208 \u03a3 * a , where \u03a3 a is the union of all possible actions."}, {"id": 99, "string": "We model the probability of the output with the action sequence: P (a 1:q |x 1:n ) = q t=1 P (a t |a 1 , ."}, {"id": 100, "string": "."}, {"id": 101, "string": "."}, {"id": 102, "string": ", a t\u22121 , x 1:n ; \u03b8) which we estimate using a sequence-to-sequence model, as we will describe in the next section."}, {"id": 103, "string": "Soft vs Hard Attention for Sequence-to-action-sequence Shown in Figure 3 , our sequence-to-sequence model takes a word sequence w 1:n and its mapped concept sequence c 1:n as the input, and the action sequence a 1:q as the output."}, {"id": 104, "string": "It uses two BiLSTM encoders, each encoding an input sequence."}, {"id": 105, "string": "As the two encoders have the same structure, we only introduce the encoder for the word sequence in detail below."}, {"id": 106, "string": "BiLSTM Encoder Given an input word sequence w 1:n , we use a bidirectional LSTM to encode it."}, {"id": 107, "string": "At each step j, the current hidden states \u2190 \u2212 h w j and \u2212 \u2192 h w j are generated from the previous hidden states \u2190 \u2212 h w j+1 and \u2212 \u2192 h w j\u22121 , and the representation vector x j of the current input word w j : \u2190 \u2212 h w j = LSTM( \u2190 \u2212 h w j+1 , x j ) \u2212 \u2192 h w j = LSTM( \u2212 \u2192 h w j\u22121 , x j ) The representation vector x j is the concatenation of the embeddings of its word, lemma, and POS tag, respectively."}, {"id": 108, "string": "Then the hidden states of both directions are concatenated as the final hidden state for word w j : h w j = [ \u2190 \u2212 h w j ; \u2212 \u2192 h w j ] Similarly, for the concept sequence, the final hidden state for concept c j is: h c j = [ \u2190 \u2212 h c j ; \u2212 \u2192 h c j ] LSTM Decoder with Soft Attention We use an attention-based LSTM decoder (Bahdanau et al., 2014) with two attention memories H w and H c , where H w is the concatenation of the state vectors of all input words, and H c for input concepts correspondingly: H w = [h w 1 ; h w 2 ; ."}, {"id": 109, "string": "."}, {"id": 110, "string": "."}, {"id": 111, "string": "; h w n ] (1) H c = [h c 1 ; h c 2 ; ."}, {"id": 112, "string": "."}, {"id": 113, "string": "."}, {"id": 114, "string": "; h c n ] (2) The decoder yields an action sequence a 1 , a 2 , ."}, {"id": 115, "string": "."}, {"id": 116, "string": "."}, {"id": 117, "string": ", a q as the output by calculating a sequence of hidden states s 1 , s 2 ."}, {"id": 118, "string": "."}, {"id": 119, "string": "."}, {"id": 120, "string": ", s q recurrently."}, {"id": 121, "string": "While generating the t-th output action, the decoder considers three factors: (1) the previous hidden state of the LSTM model s t\u22121 ; (2) the embedding of the previous generated action e t\u22121 ; and (3) the previous context vectors for words \u00b5 w t\u22121 and concepts \u00b5 c t\u22121 , which are calculated using H w and H c , respectively."}, {"id": 122, "string": "When t = 1, we initialize \u00b5 0 as a zero vector, and set e 0 to the embedding of the start token \" s \"."}, {"id": 123, "string": "The hidden state s 0 is initialized as: s 0 = W d [ \u2190 \u2212 h w 1 ; \u2212 \u2192 h w n ; \u2190 \u2212 h c 1 ; \u2212 \u2192 h c n ] + b d , where W d and b d are model parameters."}, {"id": 124, "string": "For each time-step t, the decoder feeds the concatenation of the embedding of previous action e t\u22121 and the previous context vectors for words \u00b5 w t\u22121 and concepts \u00b5 c t\u22121 into the LSTM model to update its hidden state."}, {"id": 125, "string": "s t = LSTM(s t\u22121 , [e t\u22121 ; \u00b5 w t\u22121 ; \u00b5 c t\u22121 ]) (3) Then the attention probabilities for the word sequence and the concept sequence are calculated similarly."}, {"id": 126, "string": "Take the word sequence as an example, \u03b1 w t,i on h w i \u2208 H w for time-step t is calculated as: t,i = v T c tanh(W h h w i + W s s t + b c ) \u03b1 w t,i = exp( t,i ) N j=1 exp( t,j ) W h , W s , v c and b c are model parameters."}, {"id": 127, "string": "The new context vector \u00b5 w t = n i=1 \u03b1 w t,i h w i ."}, {"id": 128, "string": "The calculation of \u00b5 c t follows the same procedure, but with a different set of model parameters."}, {"id": 129, "string": "The output probability distribution over all actions at the current state is calculated by: (4) where V a and b a are learnable parameters, and the number of rows in V a represents the number of all actions."}, {"id": 130, "string": "The symbol \u03a3 a is the set of all actions."}, {"id": 131, "string": "P \u03a3a = softmax(V a [s t ; \u00b5 w t ; \u00b5 c t ] + b a ), Monotonic Hard Attention for Transition Systems When we process each buffer input, the next few transition actions are closely related to this input position."}, {"id": 132, "string": "The buffer maintains the order information of the input sequence and is processed strictly left-to-right, which essentially encodes a monotone alignment between the transition action sequence and the input sequence."}, {"id": 133, "string": "As we have generated a concept sequence from the input word sequence, we maintain two hard attention pointers, l w and l c , to model monotonic attention to word and concept sequences respectively."}, {"id": 134, "string": "The update to the decoder state now relies on a single position of each input sequence in contrast to Equation 3: s t = LSTM(s t\u22121 , [e t\u22121 ; h w lw ; h c lc ]) (5) Control Mechanism."}, {"id": 135, "string": "Both pointers are initialized as 0 and advanced to the next position deterministically."}, {"id": 136, "string": "We move the concept attention focus l c to the next position after arc decisions to all the other m \u2212 1 cache concepts are made."}, {"id": 137, "string": "We move the word attention focus l w to its aligned position in case the new concept is aligned, otherwise we don't move the word focus."}, {"id": 138, "string": "As shown in Figure 4 , after we have made arc decisions from concept want-01 to the other cache concepts, we move the concept focus to the next concept go-01."}, {"id": 139, "string": "As this concept is aligned, we move the word focus to its aligned position go in the word sequence and skip the unaligned word to."}, {"id": 140, "string": "Transition State Features for Decoder Another difference of our model with Buys and Blunsom (2017) is that we extract features from the current transition state configuration C t : e f (C t ) = [e f 1 (C t ); e f 2 (C t ); \u00b7 \u00b7 \u00b7 ; e f l (C t )] where l is the number of features extracted from C t and e f k (C t ) (k = 1, ."}, {"id": 141, "string": "."}, {"id": 142, "string": "."}, {"id": 143, "string": ", l) represents the embedding for the k-th feature, which is learned during training."}, {"id": 144, "string": "These feature embeddings are concatenated as e f (C t ), and fed as additional input to the decoder."}, {"id": 145, "string": "For the soft attention decoder: s t = LSTM(s t\u22121 , [e t\u22121 ; \u00b5 w t\u22121 ; \u00b5 c t\u22121 ; e f (C t )]) and for the hard attention decoder: s t = LSTM(s t\u22121 , [e t\u22121 ; h w lw ; h c lc ; e f (C t )]) We use the following features in our experiments: 1."}, {"id": 146, "string": "Phase type: indicator features showing which phase the next transition is."}, {"id": 147, "string": "2."}, {"id": 148, "string": "ShiftOrPop features: token features 3 for the rightmost cache concept and the leftmost buffer concept."}, {"id": 149, "string": "Number of dependencies to words on the right, and the top three dependency labels for them."}, {"id": 150, "string": "3."}, {"id": 151, "string": "ArcBinary or ArcLabel features: token features for the rightmost concept and the current cache concept it makes arc decisions to."}, {"id": 152, "string": "Word, concept and dependency distance between the two concepts."}, {"id": 153, "string": "The labels for the two most recent outgoing arcs for these two concepts and their first incoming arc and the number of incoming arcs."}, {"id": 154, "string": "Dependency label between the two positions if there is a dependency arc between them."}, {"id": 155, "string": "4."}, {"id": 156, "string": "PushIndex features: token features for the leftmost buffer concept and all the concepts in the cache."}, {"id": 157, "string": "The phase type features are deterministic from the last action output."}, {"id": 158, "string": "For example, if the last action output is Shift, the current phase type would be PushIndex."}, {"id": 159, "string": "We only extract corresponding features for this phase and fill all the other feature types with -NULLas placeholders."}, {"id": 160, "string": "The features for other phases are similar."}, {"id": 161, "string": "AMR Parsing Training and Decoding We train our models using the cross-entropy loss, over each oracle action sequence a * 1 , ."}, {"id": 162, "string": "."}, {"id": 163, "string": "."}, {"id": 164, "string": ", a * q : L = \u2212 q t=1 log P (a * t |a * 1 , ."}, {"id": 165, "string": "."}, {"id": 166, "string": "."}, {"id": 167, "string": ", a * t\u22121 , X; \u03b8), (6) where X represents the input word and concept sequences, and \u03b8 is the model parameters."}, {"id": 168, "string": "Adam (Kingma and Ba, 2014) with a learning rate of 0.001 is used as the optimizer, and the model that yields the best performance on the dev set is selected to evaluate on the test set."}, {"id": 169, "string": "Dropout with rate 0.3 is used during training."}, {"id": 170, "string": "Beam search with a beam size of 10 is used for decoding."}, {"id": 171, "string": "Both training and decoding use a Tesla K20X GPU."}, {"id": 172, "string": "Hidden state sizes for both encoder and decoder are set to 100."}, {"id": 173, "string": "The word embeddings are initialized from Glove pretrained word embeddings (Pennington et al., 2014) on Common Crawl, and are not updated during training."}, {"id": 174, "string": "The embeddings for POS tags and features are randomly initialized, with the sizes of 20 and 50, respectively."}, {"id": 175, "string": "Preprocessing and Postprocessing As the AMR data is very sparse, we collapse some subgraphs or spans into categories based on the alignment."}, {"id": 176, "string": "We define some special categories such as named entities (NE), dates (DATE), single rooted subgraphs involving multiple concepts (MULT) 4 , numbers (NUMBER) and phrases (PHRASE)."}, {"id": 177, "string": "The phrases are extracted based on the multiple-to-one alignment in the training data."}, {"id": 178, "string": "One example phrase is more than which aligns to a single concept more-than."}, {"id": 179, "string": "We first collapse spans and subgraphs into these categories based on the alignment from the JAMR aligner (Flanigan et al., 2014) , which greedily aligns a span of words to AMR subgraphs using a set of heuristics."}, {"id": 180, "string": "This categorization procedure enables the parser to capture mappings from continuous spans on the sentence side to connected subgraphs on the AMR side."}, {"id": 181, "string": "We use the semi-Markov model from Flanigan et al."}, {"id": 182, "string": "(2016) as the concept identifier, which jointly segments the sentence into a sequence of spans and maps each span to a subgraph."}, {"id": 183, "string": "During decoding, our output has categories, and we need to map  each category to the corresponding AMR concept or subgraph."}, {"id": 184, "string": "We save a table Q which shows the original subgraph each category is collapsed from, and map each category to its original subgraph representation."}, {"id": 185, "string": "We also use heuristic rules to generate the target-side AMR subgraph representation for NE, DATE, and NUMBER based on the source side tokens."}, {"id": 186, "string": "Experiments We evaluate our system on the released dataset (LDC2015E86) for SemEval 2016 task 8 on meaning representation parsing (May, 2016) ."}, {"id": 187, "string": "The dataset contains 16,833 training, 1,368 development, and 1,371 test sentences which mainly cover domains like newswire, discussion forum, etc."}, {"id": 188, "string": "All parsing results are measured by Smatch (version 2.0.2) ."}, {"id": 189, "string": "Experiment Settings We categorize the training data using the automatic alignment and dump a template for date entities and frequent phrases from the multiple to one alignment."}, {"id": 190, "string": "We also generate an alignment table from tokens or phrases to their candidate targetside subgraphs."}, {"id": 191, "string": "For the dev and test data, we first extract the named entities using the Illinois Named Entity Tagger (Ratinov and Roth, 2009 ) and extract date entities by matching spans with the date template."}, {"id": 192, "string": "We further categorize the dataset with the categories we have defined."}, {"id": 193, "string": "After categorization, we use Stanford CoreNLP  to get the POS tags and dependencies of the categorized dataset."}, {"id": 194, "string": "We run the oracle algorithm separately for training and dev data (with alignment) to get the statistics of individual phases."}, {"id": 195, "string": "We use a cache size of 5 in our experiments."}, {"id": 196, "string": "Results Individual Phase Accuracy We first evaluate the prediction accuracy of individual phases on the dev oracle data assuming gold prediction history."}, {"id": 197, "string": "The four transition phases ShiftOrPop, PushIndex, ArcBinary, and ArcLabel account for 25%, 12.5%, 50.1%, and 12.4% of the total transition actions respectively."}, {"id": 198, "string": "Table 1 shows the phase-wise accuracy of our sequence-to-sequence model."}, {"id": 199, "string": "use a separate feedforward network to predict each phase independently."}, {"id": 200, "string": "We use the same alignment from the SemEval dataset as in  to avoid differences resulting from the aligner."}, {"id": 201, "string": "Soft+feats shows the performance of our sequence-to-sequence model with soft attention and transition state features, while Hard+feats is using hard attention."}, {"id": 202, "string": "We can see that the hard attention model outperforms the soft attention model in all phases, which shows that the single-pointer attention finds more relevant information than the soft attention on the relatively small dataset."}, {"id": 203, "string": "The sequence-to-sequence models perform better than the feedforward model of  on ShiftOrPop and ArcBinary, which shows that the whole-sentence context information is important for the prediction of these two phases."}, {"id": 204, "string": "On the other hand, the sequence-tosequence models perform worse than the feedforward models on PushIndex and ArcLabel."}, {"id": 205, "string": "One possible reason is that the model tries to optimize the overall accuracy, while these two phases account for fewer than 25% of the total transition actions and might be less attended to during the update."}, {"id": 206, "string": "Table 2 shows the impact of different components for the sequence-to-sequence model."}, {"id": 207, "string": "We can see that the transition state features play a very important role for predicting the correct transition action."}, {"id": 208, "string": "This is because different transition phases have very different prediction behaviors and need different types of local information for the prediction."}, {"id": 209, "string": "Relying on the sequence-to-sequence model alone does not perform well in disambiguating these choices, while the transition state can enforce direct constraints."}, {"id": 210, "string": "We can also see that while the hard attention only attends to one position of the input, it performs slightly better than the soft attention model, while the time complexity is lower."}, {"id": 211, "string": "Impact of Different Components Impact of Different Cache Sizes The cache size of the transition system can be optimized as a trade-off between coverage of AMR graphs and the prediction accuracy."}, {"id": 212, "string": "While larger cache size increases the coverage of AMR graphs, it complicates the prediction procedure with more cache decisions to make."}, {"id": 213, "string": "From Table 3 we can see that   Comparison with other Parsers Table 4 shows the comparison with other AMR parsers."}, {"id": 214, "string": "The first three systems are some competitive neural models."}, {"id": 215, "string": "We can see that our parser significantly outperforms the sequence-to-action-sequence model of Buys and Blunsom (2017) ."}, {"id": 216, "string": "Konstas et al."}, {"id": 217, "string": "(2017) use a linearization approach that linearizes the AMR graph to a sequence structure and use selftraining on 20M unlabeled Gigaword sentences."}, {"id": 218, "string": "Our model achieves better results without using additional unlabeled data, which shows that relevant information from the transition system is very useful for the prediction."}, {"id": 219, "string": "Our model also   We also show the performance of some of the best-performing models."}, {"id": 220, "string": "While our hard attention achieves slightly lower performance in comparison with Wang et al."}, {"id": 221, "string": "(2015a) and , it is worth noting that their approaches of using WordNet, semantic role labels and word cluster features are complimentary to ours."}, {"id": 222, "string": "The alignment from the aligner and the concept identification identifier also play an important role for improving the performance."}, {"id": 223, "string": "propose to improve AMR parsing by improving the alignment and concept identification, which can also be combined with our system to improve the performance of a sequence-to-sequence model."}, {"id": 224, "string": "Dealing with Reentrancy Reentrancy is an important characteristic of AMR, and we evaluate the Smatch score only on the reentrant edges following Damonte et al."}, {"id": 225, "string": "(2017) ."}, {"id": 226, "string": "From Table 5 we can see that our hard attention model significantly outperforms the feedforward model of  in predicting reentrancies."}, {"id": 227, "string": "This is because predicting reentrancy is directly related to the Ar-cBinary phase of the cache transition system since it decides to make multiple arc decisions to the same vertex, and we can see from Table 1 that the hard attention model has significantly better prediction accuracy in this phase."}, {"id": 228, "string": "We also compare the reentrancy results of our transition system with two other systems, Damonte et al."}, {"id": 229, "string": "(2017) and JAMR, where these statistics are available."}, {"id": 230, "string": "From Table 5 , we can see that our cache transition system slightly outperforms these two systems in predicting reentrancies."}, {"id": 231, "string": "Figure 5 shows a reentrancy example where JAMR and the feedforward network of  do not predict well, while our system predicts the correct output."}, {"id": 232, "string": "JAMR fails to predict the reentrancy arc from desire-01 to i, and connects the wrong arc from \"live-01\" to \"-\" instead of from \"desire-01\"."}, {"id": 233, "string": "The feedforward model of   and live-01 to i."}, {"id": 234, "string": "This error is because their feedforward ArcBinary classifier does not model longterm dependency and usually prefers making arcs between words that are close and not if they are distant."}, {"id": 235, "string": "Our classifier, which encodes both word and concept sequence information, can accurately predict the reentrancy through the two arc decisions shown in Figure 5 ."}, {"id": 236, "string": "When desire-01 and live-01 are shifted into the cache respectively, the transition system makes a left-going arc from each of them to the same concept i, thus creating the reentrancy as desired."}, {"id": 237, "string": "Conclusion In this paper, we have presented a sequence-toaction-sequence approach for cache transition systems and applied it to AMR parsing."}, {"id": 238, "string": "To address the data sparsity issue for neural AMR parsing, we show that the transition state features are very helpful in constraining the possible output and improving the performance of sequence-to-sequence models."}, {"id": 239, "string": "We also show that the monotonic hard attention model can be generalized to the transitionbased framework and outperforms the soft attention model when limited data is available."}, {"id": 240, "string": "While we are focused on AMR parsing in this paper, in future work our cache transition system and the presented sequence-to-sequence models can be potentially applied to other semantic graph parsing tasks (Oepen et al., 2015; Du et al., 2015; Zhang et al., 2016; Cao et al., 2017) ."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 30}, {"section": "Cache Transition Parser", "n": "2", "start": 31, "end": 79}, {"section": "Oracle Extraction Algorithm", "n": "2.1", "start": 80, "end": 83}, {"section": "ShiftOrPop phase: the oracle chooses transi", "n": "1.", "start": 84, "end": 102}, {"section": "Soft vs Hard Attention for", "n": "3", "start": 103, "end": 105}, {"section": "BiLSTM Encoder", "n": "3.1", "start": 106, "end": 107}, {"section": "LSTM Decoder with Soft Attention", "n": "3.2", "start": 108, "end": 130}, {"section": "Monotonic Hard Attention for Transition Systems", "n": "3.3", "start": 131, "end": 139}, {"section": "Transition State Features for Decoder", "n": "3.4", "start": 140, "end": 160}, {"section": "Training and Decoding", "n": "4.1", "start": 161, "end": 174}, {"section": "Preprocessing and Postprocessing", "n": "4.2", "start": 175, "end": 185}, {"section": "Experiments", "n": "5", "start": 186, "end": 188}, {"section": "Experiment Settings", "n": "5.1", "start": 189, "end": 195}, {"section": "Results", "n": "5.2", "start": 196, "end": 236}, {"section": "Conclusion", "n": "6", "start": 237, "end": 240}], "figures": [{"filename": "../figure/image/1343-Table1-1.png", "caption": "Table 1: Performance breakdown of each transition phase.", "page": 6, "bbox": {"x1": 72.96, "x2": 292.32, "y1": 63.839999999999996, "y2": 102.24}}, {"filename": "../figure/image/1343-Figure2-1.png", "caption": "Figure 2: Example run of the cache transition system constructing the graph for the sentence \u201cJohn wants to go\u201d with cache size of 3. The left four columns show the parser configurations after taking the actions shown in the last column. E1 = {(Per,want-01,L-ARG0)}, E2 = {(Per,want-01,L-ARG0), (Per, go-01,L-ARG0), (want-01, go-01,R-ARG1)}.", "page": 2, "bbox": {"x1": 73.92, "x2": 527.04, "y1": 64.32, "y2": 198.23999999999998}}, {"filename": "../figure/image/1343-Table4-1.png", "caption": "Table 4: Comparison to other AMR parsers. *Model has been trained on the previous release of the corpus (LDC2014T12).", "page": 7, "bbox": {"x1": 73.92, "x2": 291.36, "y1": 574.56, "y2": 711.36}}, {"filename": "../figure/image/1343-Table2-1.png", "caption": "Table 2: Impact of various components for the sequence-to-sequence model (dev).", "page": 7, "bbox": {"x1": 103.67999999999999, "x2": 258.24, "y1": 62.879999999999995, "y2": 119.03999999999999}}, {"filename": "../figure/image/1343-Table3-1.png", "caption": "Table 3: Impact of cache size for the sequenceto-sequence model, hard attention (dev).", "page": 7, "bbox": {"x1": 103.67999999999999, "x2": 259.2, "y1": 170.88, "y2": 227.04}}, {"filename": "../figure/image/1343-Table5-1.png", "caption": "Table 5: Reentrancy statistics.", "page": 7, "bbox": {"x1": 314.88, "x2": 517.4399999999999, "y1": 62.879999999999995, "y2": 132.0}}, {"filename": "../figure/image/1343-Figure4-1.png", "caption": "Figure 4: Sequence-to-sequence model with monotonic hard attention. Different colors show the changes of hard attention focus.", "page": 3, "bbox": {"x1": 312.0, "x2": 519.36, "y1": 63.839999999999996, "y2": 234.23999999999998}}, {"filename": "../figure/image/1343-Figure3-1.png", "caption": "Figure 3: Sequence-to-sequence model with soft attention, encoding a word sequence and concept sequence separately by two BiLSTM encoders.", "page": 3, "bbox": {"x1": 75.84, "x2": 284.15999999999997, "y1": 63.839999999999996, "y2": 234.23999999999998}}, {"filename": "../figure/image/1343-Figure5-1.png", "caption": "Figure 5: An example showing how our system predicts the correct reentrancy.", "page": 8, "bbox": {"x1": 109.44, "x2": 488.15999999999997, "y1": 102.72, "y2": 356.15999999999997}}]}