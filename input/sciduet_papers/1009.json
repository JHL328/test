{"title": "Marrying Up Regular Expressions with Neural Networks: A Case Study for Spoken Language Understanding", "abstract": "The success of many natural language processing (NLP) tasks is bound by the number and quality of annotated data, but there is often a shortage of such training data. In this paper, we ask the question: \"Can we combine a neural network (NN) with regular expressions (RE) to improve supervised learning for NLP?\". In answer, we develop novel methods to exploit the rich expressiveness of REs at different levels within a NN, showing that the combination significantly enhances the learning effectiveness when a small number of training examples are available. We evaluate our approach by applying it to spoken language understanding for intent detection and slot filling. Experimental results show that our approach is highly effective in exploiting the available training data, giving a clear boost to the RE-unaware NN. flights from Boston to Miami Intent RE: Intent Label: flight /from (__CITY) to (__CITY)/ O O B-fromloc.city O B-toloc.city Sentence: Slot Labels: Slot RE: /^flights? from/ REtag: flight city / toloc.city REtag: city / fromloc.city", "text": [{"id": 0, "string": "Introduction Regular expressions (REs) are widely used in various natural language processing (NLP) tasks like pattern matching, sentence classification, sequence labeling, etc."}, {"id": 1, "string": "(Chang and Manning, 2014) ."}, {"id": 2, "string": "As a technique based on human-crafted rules, it is concise, interpretable, tunable, and does not rely on much training data to generate."}, {"id": 3, "string": "As such, it is commonly used in industry, especially when the available training examples are limited -a problem known as few-shot learning (GC et al., 2015) ."}, {"id": 4, "string": "While powerful, REs have a poor generalization ability because all synonyms and variations in a RE must be explicitly specified."}, {"id": 5, "string": "As a result, REs are often ensembled with data-driven methods, such as neural network (NN) based techniques, where a set of carefully-written REs are used to handle certain cases with high precision, leaving the rest for data-driven methods."}, {"id": 6, "string": "We believe the use of REs can go beyond simple pattern matching."}, {"id": 7, "string": "In addition to being a separate classifier to be ensembled, a RE also encodes a developer's knowledge for the problem domain."}, {"id": 8, "string": "The knowledge could be, for example, the informative words (clue words) within a RE's surface form."}, {"id": 9, "string": "We argue that such information can be utilized by data-driven methods to achieve better prediction results, especially in few-shot learning."}, {"id": 10, "string": "This work investigates the use of REs to improve NNs -a learning framework that is widely used in many NLP tasks (Goldberg, 2017) ."}, {"id": 11, "string": "The combination of REs and a NN allows us to exploit the conciseness and effectiveness of REs and the strong generalization ability of NNs."}, {"id": 12, "string": "This also provides us an opportunity to learn from various kinds of REs, since NNs are known to be good at tolerating noises (Xie et al., 2016) ."}, {"id": 13, "string": "This paper presents novel approaches to combine REs with a NN at different levels."}, {"id": 14, "string": "At the input layer, we propose to use the evaluation outcome of REs as the input features of a NN (Sec.3.2)."}, {"id": 15, "string": "At the network module level, we show how to exploit the knowledge encoded in REs to guide the attention mechanism of a NN (Sec."}, {"id": 16, "string": "3.3)."}, {"id": 17, "string": "At the output layer, we combine the evaluation outcome of a RE with the NN output in a learnable manner (Sec."}, {"id": 18, "string": "3.4) ."}, {"id": 19, "string": "We evaluate our approach by applying it to two spoken language understanding (SLU) tasks, namely intent detection and slot filling, which respectively correspond to two fundamental NLP tasks: sentence classification and sequence labeling."}, {"id": 20, "string": "To demonstrate the usefulness of REs in realworld scenarios where the available number of annotated data can vary, we explore both the fewshot learning setting and the one with full training data."}, {"id": 21, "string": "Experimental results show that our approach is highly effective in utilizing the available Figure 1 : A sentence from the ATIS dataset."}, {"id": 22, "string": "REs can be used to detect the intent and label slots."}, {"id": 23, "string": "annotated data, yielding significantly better learning performance over the RE-unaware method."}, {"id": 24, "string": "Our contributions are as follows."}, {"id": 25, "string": "(1) We present the first work to systematically investigate methods for combining REs with NNs."}, {"id": 26, "string": "(2) The proposed methods are shown to clearly improve the NN performance in both the few-shot learning and the full annotation settings."}, {"id": 27, "string": "(3) We provide a set of guidance on how to combine REs with NNs and RE annotation."}, {"id": 28, "string": "Background Typesetting In this paper, we use italic for emphasis like intent detection, the Courier typeface for abbreviations like RE, bold italic for the first appearance of a concept like clue words, Courier surrounded by / for regular expressions like /list( the)?"}, {"id": 29, "string": "AIRLINE/, and underlined italic for words of sentences in our dataset like Boston."}, {"id": 30, "string": "Problem Definition Our work targets two SLU tasks: intent detection and slot filling."}, {"id": 31, "string": "The former is a sentence classification task where we learn a function to map an input sentence of n words, x = [x 1 , ..., x n ], to a corresponding intent label, c. The latter is a sequence labeling task for which we learn a function to take in an input query sentence of n words, x = [x 1 , ..., x n ], to produce a corresponding labeling sequence, y = [y 1 , ..., y n ], where y i is the slot label of the corresponding word, x i ."}, {"id": 32, "string": "Take the sentence in Fig."}, {"id": 33, "string": "1 as an example."}, {"id": 34, "string": "A successful intent detector would suggest the intent of the sentence as flight, i.e., querying about flight-related information."}, {"id": 35, "string": "A slot filler, on the other hand, should identify the slots fromloc.city and toloc.city by labeling Boston and Miami, respectively, using the begin-inside-outside (BIO) scheme."}, {"id": 36, "string": "The Use of Regular Expressions In this work, a RE defines a mapping from a text pattern to several REtags which are the same as or related to the target labels (i.e., intent and slot labels)."}, {"id": 37, "string": "A search function takes in a RE, applies it to all sentences, and returns any texts that match the pattern."}, {"id": 38, "string": "We then assign the REtag (s) (that are associated with the matching RE) to either the matched sentence (for intent detection) or some matched phrases (for slot filling)."}, {"id": 39, "string": "Specifically, our REtags for intent detection are the same as the intent labels."}, {"id": 40, "string": "For example, in Fig."}, {"id": 41, "string": "1 , we get a REtag of flight that is the same as the intent label flight."}, {"id": 42, "string": "For slot filling, we use two different sets of REs."}, {"id": 43, "string": "Given the group functionality of RE, we can assign REtags to our interested RE groups (i.e., the expressions defined inside parentheses)."}, {"id": 44, "string": "The translation from REtags to slot labels depends on how the corresponding REs are used."}, {"id": 45, "string": "(1) When REs are used at the network module level (Sec."}, {"id": 46, "string": "3.3), the corresponding REtags are the same as the target slot labels."}, {"id": 47, "string": "For instance, the slot RE in Fig."}, {"id": 48, "string": "1 will assign fromloc.city to the first RE group and toloc.city to the second one."}, {"id": 49, "string": "Here, CITY is a list of city names, which can be replaced with a RE string like /Boston|Miami|LA|.../."}, {"id": 50, "string": "(2) If REs are used in the input (Sec."}, {"id": 51, "string": "3.2) and the output layers (Sec."}, {"id": 52, "string": "3.4) of a NN, the corresponding REtag would be different from the target slot labels."}, {"id": 53, "string": "In this context, the two RE groups in Fig."}, {"id": 54, "string": "1 would be simply tagged as city to capture the commonality of three related target slot labels: fromloc.city, toloc.city, stoploc.city."}, {"id": 55, "string": "Note that we could use the target slot labels as REtags for all the settings."}, {"id": 56, "string": "The purpose of abstracting REtags to a simplified version of the target slot labels here is to show that REs can still be useful when their evaluation outcome does not exactly match our learning objective."}, {"id": 57, "string": "Further, as shown in Sec."}, {"id": 58, "string": "4.2, using simplified REtags can also make the development of REs easier in our tasks."}, {"id": 59, "string": "Intuitively, complicated REs can lead to better performance but require more efforts to generate."}, {"id": 60, "string": "Generally, there are two aspects affecting RE complexity most: the number of RE groups 1 and or clauses (i.e., expressions separated by the disjunction operator |) in a RE group."}, {"id": 61, "string": "Having a larger number of RE groups often leads to better 1 When discussing complexity, we consider each semantically independent consecutive word sequence as a RE group (excluding clauses, such as \\w+, that can match any word)."}, {"id": 62, "string": "For instance, the RE: /how long( \\w+){1,2}?"}, {"id": 63, "string": "(it take|flight)/ has two RE groups: (how long) and (it take|flight)."}, {"id": 64, "string": "precision but lower coverage on pattern matching, while a larger number of or clauses usually gives a higher coverage but slightly lower precision."}, {"id": 65, "string": "Our Approach As depicted in Fig."}, {"id": 66, "string": "2 , we propose to combine NNs and REs from three different angles."}, {"id": 67, "string": "Base Models We use the Bi-directional LSTM (BLSTM) as our base NN model because it is effective in both intent detection and slot filling (Liu and Lane, 2016) ."}, {"id": 68, "string": "Intent Detection."}, {"id": 69, "string": "As shown in Fig."}, {"id": 70, "string": "2 , the BLSTM takes as input the word embeddings [x 1 , ..., x n ] of a n-word sentence, and produces a vector h i for each word i."}, {"id": 71, "string": "A self-attention layer then takes in the vectors produced by the BLSTM to compute the sentence embedding s: s = i \u03b1 i h i , \u03b1 i = exp(h i Wc) i exp(h i Wc) (1) where \u03b1 i is the attention for word i, c is a randomly initialized trainable vector used to select informative words for classification, and W is a weight matrix."}, {"id": 72, "string": "Finally, s is fed to a softmax classifier for intent classification."}, {"id": 73, "string": "Slot Filling."}, {"id": 74, "string": "The model for slot filling is straightforward -the slot label prediction is generated by a softmax classier which takes in the BLSTM's output h i and produces the slot label of word i."}, {"id": 75, "string": "Note that attention aggregation in Fig."}, {"id": 76, "string": "2 is only employed by the network module level method presented in Sec."}, {"id": 77, "string": "3.3."}, {"id": 78, "string": "Using REs at the Input Level At the input level, we use the evaluation outcomes of REs as features which are fed to NN models."}, {"id": 79, "string": "Intent Detection."}, {"id": 80, "string": "Our REtag for intent detection is the same as our target intent label."}, {"id": 81, "string": "Because real-world REs are unlikely to be perfect, one sentence may be matched by more than one RE."}, {"id": 82, "string": "This may result in several REtags that are conflict with each other."}, {"id": 83, "string": "For instance, the sentence list the Delta airlines flights to Miami can match a RE: /list( the)?"}, {"id": 84, "string": "AIRLINE/ that outputs tag airline, and another RE: /list( \\w+){0,3} flights?/ that outputs tag flight."}, {"id": 85, "string": "To resolve the conflicting situations illustrated above, we average the randomly initialized trainable tag embeddings to form an aggregated embedding as the NN input."}, {"id": 86, "string": "There are two ways to use the aggregated embedding."}, {"id": 87, "string": "We can append the aggregated embedding to either the embedding of every input word, or the input of the softmax classifier (see 1 in Fig."}, {"id": 88, "string": "2(a) )."}, {"id": 89, "string": "To determine which strategy works best, we perform a pilot study."}, {"id": 90, "string": "We found that the first method causes the tag embedding to be copied many times; consequently, the NN tends to heavily rely on the REtags, and the resulting performance is similar to the one given by using REs alone in few-shot settings."}, {"id": 91, "string": "Thus, we adopt the second approach."}, {"id": 92, "string": "Slot Filling."}, {"id": 93, "string": "Since the evaluation outcomes of slot REs are word-level tags, we can simply embed and average the REtags into a vector f i for each word, and append it to the corresponding word embedding w i (as shown in 1 in Fig."}, {"id": 94, "string": "2(b) )."}, {"id": 95, "string": "Note that we also extend the slot REtags into the BIO format, e.g., the REtags of phrase New York are B-city and I-city if its original tag is city."}, {"id": 96, "string": "Using REs at the Network Module Level At the network module level, we explore ways to utilize the clue words in the surface form of a RE (bold blue arrows and words in 2 of Fig."}, {"id": 97, "string": "2 ) to guide the attention module in NNs."}, {"id": 98, "string": "Intent Detection."}, {"id": 99, "string": "Taking the sentence in Fig."}, {"id": 100, "string": "1 for example, the RE: /\u02c6flights?"}, {"id": 101, "string": "from/ that leads to intent flight means that flights from are the key words to decide the intent flight."}, {"id": 102, "string": "Therefore, the attention module in NNs should leverage these two words to get the correct prediction."}, {"id": 103, "string": "To this end, we extend the base intent model by making two changes to incorporate the guidance from REs."}, {"id": 104, "string": "First, since each intent has its own clue words, using a single sentence embedding for all intent labels would make the attention less focused."}, {"id": 105, "string": "Therefore, we let each intent label k use different attention a k , which is then used to generate the sentence embedding s k for that intent: s k = i \u03b1 ki h i , \u03b1 ki = exp(h i W a c k ) i exp(h i W a c k ) (2) where c k is a trainable vector for intent k which is used to compute attention a k , h i is the BLSTM output for word i, and W a is a weight matrix."}, {"id": 106, "string": "The probability p k that the input sentence expresses intent k is computed by: where w k , logit k , b k are weight vector, logit, and bias for intent k, respectively."}, {"id": 107, "string": "p k = exp(logit k ) k exp(logit k ) , logit k = w k s k + b k (3) x 1 x 2 h 1 h 2 x 3 h Second, apart from indicating a sentence for intent k (positive REs), a RE can also indicate that a sentence does not express intent k (negative REs)."}, {"id": 108, "string": "We thus use a new set of attention (negative attentions, in contrast to positive attentions), to compute another set of logits for each intent with Eqs."}, {"id": 109, "string": "2 and 3."}, {"id": 110, "string": "We denote the logits computed by positive attentions as logit pk , and those by negative attentions as logit nk , the final logit for intent k can then be calculated as: logit k = logit pk \u2212 logit nk (4) To use REs to guide attention, we add an attention loss to the final loss: loss att = k i t ki log(\u03b1 ki ) (5) where t ki is set to 0 when none of the matched REs (that leads to intent k) marks word i as a clue word -otherwise t ki is set to 1/l k , where l k is the number of clue words for intent k (if no matched RE leads to intent k, then t k * = 0)."}, {"id": 111, "string": "We use Eq."}, {"id": 112, "string": "5 to compute the positive attention loss, loss att p , for positive REs and negative attention loss, loss att n , for negative ones."}, {"id": 113, "string": "The final loss is computed as: loss = loss c + \u03b2 p loss att p + \u03b2 n loss att n (6) where loss c is the original classification loss, \u03b2 p and \u03b2 n are weights for the two attention losses."}, {"id": 114, "string": "Slot Filling."}, {"id": 115, "string": "The two-side attention (positive and negative attention) mechanism introduced for intent prediction is unsuitable for slot filling."}, {"id": 116, "string": "Because for slot filling, we need to compute attention for each word, which demands more compu-tational and memory resources than doing that for intent detection 2 ."}, {"id": 117, "string": "Because of the aforementioned reason, we use a simplified version of the two-side attention, where all the slot labels share the same set of positive and negative attention."}, {"id": 118, "string": "Specifically, to predict the slot label of word i, we use the following equations, which are similar to Eq."}, {"id": 119, "string": "1, to generate a sentence embedding s pi with regard to word i from positive attention: s pi = j \u03b1 pij h j , \u03b1 pij = exp(h j W sp h i ) j exp(h j W sp h i ) (7) where h i and h j are the BLSTM outputs for word i and j respectively, W sp is a weight matrix, and \u03b1 pij is the positive attention value for word j with respect to word i."}, {"id": 120, "string": "Further, by replacing W sp with W sn , we use Eq."}, {"id": 121, "string": "7 again to compute negative attention and generate the corresponding sentence embedding s ni ."}, {"id": 122, "string": "Finally, the prediction p i for word i can be calculated as: p i = softmax((W p [s pi ; h i ] + b p ) \u2212(W n [s ni ; h i ] + b n )) (8) where W p , W n , b p , b n are weight matrices and bias vectors for positive and negative attention, respectively."}, {"id": 123, "string": "Here we append the BLSTM output h i to s pi and s ni because the word i itself also plays a crucial part in identifying its slot label."}, {"id": 124, "string": "Using REs at the Output Level At the output level, REs are used to amend the output of NNs."}, {"id": 125, "string": "At this level, we take the same approach used for intent detection and slot filling (see 3 in Fig."}, {"id": 126, "string": "2 )."}, {"id": 127, "string": "As mentioned in Sec."}, {"id": 128, "string": "2.3, the slot REs used in the output level only produce a simplified version of target slot labels, for which we can further annotate their corresponding target slot labels."}, {"id": 129, "string": "For instance, a RE that outputs city can lead to three slot labels: fromloc.city, toloc.city, stoploc.city."}, {"id": 130, "string": "Let z k be a 0-1 indicator of whether there is at least one matched RE that leads to target label k (intent or slot label), the final logits of label k for a sentence (or a specific word for slot filling) is: logit k = logit k + w k z k (9) where logit k is the logit produced by the original NN, and w k is a trainable weight indicating the overall confidence for REs that lead to target label k. Here we do not assign a trainable weight for each RE because it is often that only a few sentences match a RE."}, {"id": 131, "string": "We modify the logit instead of the final probability because a logit is an unconstrained real value, which matches the property of w k z k better than probability."}, {"id": 132, "string": "Actually, when performing model ensemble, ensembling with logits is often empirically better than with the final probability 3 ."}, {"id": 133, "string": "This is also the reason why we choose to operate on logits in Sec."}, {"id": 134, "string": "3.3."}, {"id": 135, "string": "Evaluation Methodology Our experiments aim to answer three questions: Q1: Does the use of REs enhance the learning quality when the number of annotated instances is small?"}, {"id": 136, "string": "Q2: Does the use of REs still help when using the full training data?"}, {"id": 137, "string": "Q3: How can we choose from different combination methods?"}, {"id": 138, "string": "Datasets We use the ATIS dataset (Hemphill et al., 1990) to evaluate our approach."}, {"id": 139, "string": "This dataset is widely used in SLU research."}, {"id": 140, "string": "It includes queries of flights, meal, etc."}, {"id": 141, "string": "We follow the setup of Liu and Lane (2016) by using 4,978 queries for training and 893 for testing, with 18 intent labels and 127 slot labels."}, {"id": 142, "string": "We also split words like Miami's into Miami 's during the tokenization phase to reduce the number of words that do not have a pre-trained word embedding."}, {"id": 143, "string": "This strategy is useful for fewshot learning."}, {"id": 144, "string": "To answer Q1 , we also exploit the full few-shot learning setting."}, {"id": 145, "string": "Specifically, for intent detection, we randomly select 5, 10, 20 training instances for each intent to form the few-shot training set; and for slot filling, we also explore 5, 10, 20 shots settings."}, {"id": 146, "string": "However, since a sentence typically contains multiple slots, the number of mentions of frequent slot labels may inevitably exceeds the target shot count."}, {"id": 147, "string": "To better approximate the target shot count, we select sentences for each slot label in ascending order of label frequencies."}, {"id": 148, "string": "That is k 1 -shot dataset will contain k 2 -shot dataset if k 1 > k 2 ."}, {"id": 149, "string": "All settings use the original test set."}, {"id": 150, "string": "Since most existing few-shot learning methods require either many few-shot classes or some classes with enough data for training, we also explore the partial few-shot learning setting for intent detection to provide a fair comparison for existing few-shot learning methods."}, {"id": 151, "string": "Specifically, we let the 3 most frequent intents have 300 training instances, and the rest remains untouched."}, {"id": 152, "string": "This is also a common scenario in real world, where we often have several frequent classes and many classes with limited data."}, {"id": 153, "string": "As for slot filling, however, since the number of mentions of frequent slot labels already exceeds the target shot count, the original slot filling few-shot dataset can be directly used to train existing few-shot learning methods."}, {"id": 154, "string": "Therefore, we do not distinguish full and partial few-shot learning for slot filling."}, {"id": 155, "string": "Preparing REs We use the syntax of REs in Perl in this work."}, {"id": 156, "string": "Our REs are written by a paid annotator who is familiar with the domain."}, {"id": 157, "string": "It took the annotator in total less than 10 hours to develop all the REs, while a domain expert can accomplish the task faster."}, {"id": 158, "string": "We use the 20-shot training data to develop the REs, but word lists like cities are obtained from the full training set."}, {"id": 159, "string": "The development of REs is considered completed when the REs can cover most of the cases in the 20-shot training data with resonable precision."}, {"id": 160, "string": "After that, the REs are fixed throughout the experiments."}, {"id": 161, "string": "The majority of the time for writing the REs is proportional to the number of RE groups."}, {"id": 162, "string": "It took about 1.5 hours to write the 54 intent REs with on average 2.2 groups per RE."}, {"id": 163, "string": "It is straightforward to write the slot REs for the input and output level methods, for which it took around 1 hour to write the 60 REs with 1.7 groups on average."}, {"id": 164, "string": "By con-trast, writing slot REs to guide attention requires more efforts as the annotator needs to carefully select clue words and annotate the full slot label."}, {"id": 165, "string": "As a result, it took about 5.5 hours to generate 115 REs with on average 3.3 groups."}, {"id": 166, "string": "The performance of the REs can be found in the last line of Table 1."}, {"id": 167, "string": "In practice, a positive RE for intent (or slot) k can often be treated as negative REs for other intents (or slots)."}, {"id": 168, "string": "As such, we use the positive REs for intent (or slot) k as the negative REs for other intents (or slots) in our experiments."}, {"id": 169, "string": "Experimental Setup Hyper-parameters."}, {"id": 170, "string": "Our hyper-parameters for the BLSTM are similar to the ones used by Liu and Lane (2016) ."}, {"id": 171, "string": "Specifically, we use batch size 16, dropout probability 0.5, and BLSTM cell size 100."}, {"id": 172, "string": "The attention loss weight is 16 (both positive and negative) for full few-shot learning settings and 1 for other settings."}, {"id": 173, "string": "We use the 100d GloVe word vectors (Pennington et al., 2014) pre-trained on Wikipedia and Gigaword (Parker et al., 2011) , and the Adam optimizer (Kingma and Ba, 2014) with learning rate 0.001."}, {"id": 174, "string": "Evaluation Metrics."}, {"id": 175, "string": "We report accuracy and macro-F1 for intent detection, and micro/macro-F1 for slot filling."}, {"id": 176, "string": "Micro/macro-F1 are the harmonic mean of micro/macro precision and recall."}, {"id": 177, "string": "Macro-precision/recall are calculated by averaging precision/recall of each label, and microprecision/recall are averaged over each prediction."}, {"id": 178, "string": "Competitors and Naming Conventions."}, {"id": 179, "string": "Here, a bold Courier typeface like BLSTM denotes the notations of the models that we will compare in Sec."}, {"id": 180, "string": "5."}, {"id": 181, "string": "Specifically, we compare our methods with the baseline BLSTM model (Sec."}, {"id": 182, "string": "3.1)."}, {"id": 183, "string": "Since our attention loss method (Sec."}, {"id": 184, "string": "3.3) uses two-side attention, we include the raw two-side attention model without attention loss (+two) for comparison as well."}, {"id": 185, "string": "Besides, we also evaluate the RE output (REO), which uses the REtags as prediction directly, to show the quality of the REs that we will use in the experiments."}, {"id": 186, "string": "4 As for our methods for combinging REs with NN, +feat refers to using REtag as input features (Sec."}, {"id": 187, "string": "3.2), +posi and +neg refer to using positive and negative attention loss respectively, +both refers to using both postive and negative attention losses (Sec."}, {"id": 188, "string": "3.3), and +logit means using REtag to modify NN output (Sec."}, {"id": 189, "string": "3.4)."}, {"id": 190, "string": "Moverover, since the REs can also be formatted as first-order-logic (FOL) rules, we also compare our methods with the teacher-student framework proposed by Hu et al."}, {"id": 191, "string": "(2016a) , which is a general framework for distilling knowledge from FOL rules into NN (+hu16)."}, {"id": 192, "string": "Besides, since we consider few-short learning, we also include the memory module proposed by Kaiser et al."}, {"id": 193, "string": "(2017) , which performs well in various few-shot datasets (+mem) 5 ."}, {"id": 194, "string": "Finally, the state-of-art model on the ATIS dataset is also included (L&L16), which jointly models the intent detection and slot filling in a single network (Liu and Lane, 2016) ."}, {"id": 195, "string": "Experimental Results Full Few-Shot Learning To answer Q1 , we first explore the full few-shot learning scenario."}, {"id": 196, "string": "Intent Detection."}, {"id": 197, "string": "As shown in Table 1 , except for 5-shot, all approaches improve the baseline BLSTM."}, {"id": 198, "string": "Our network-module-level methods give the best performance because our attention module directly receives signals from the clue words in REs that contain more meaningful information than the REtag itself used by other methods."}, {"id": 199, "string": "We also observe that since negative REs are derived from positive REs with some noises, posi performs better than neg when the amount of available data is limited."}, {"id": 200, "string": "However, neg is slightly better in 20-shot, possibly because negative REs significantly outnumbers the positive ones."}, {"id": 201, "string": "Besides, two alone works better than the BLSTM when there are sufficient data, confirming the advantage of our two-side attention architecture."}, {"id": 202, "string": "As for other proposed methods, the output level method (logit) works generally better than the input level method (feat), except for the 5-shot case."}, {"id": 203, "string": "We believe this is due to the fewer number of RE related parameters and the shorter distance that the gradient needs to travel from the loss to these parameters -both make logit easier to train."}, {"id": 204, "string": "However, since logit directly modifies the output, the final prediction is more sensitive to the insufficiently trained weights in logit, leading to the inferior results in the 5-shot setting."}, {"id": 205, "string": "Model Type Model Name 90 / 74.47 68.69 / 84.66 72.43 / 85.78 59.59 / 83.47 73.62 / 89.28 78.94 / 92.21 +two+neg 49.01 / 68.31 64.67 / 79.17 72.32 / 86.34 59.51 / 83.23 72.92 / 89.11 78.83 / 92.07 +two+both 54.86 / 75.36 71.23 / 85.44 75.58 / 88.80 59.47 / 83.35 73.55 / 89.54 To compare with existing methods of combining NN and rules, we also implement the teacherstudent network (Hu et al., 2016a) ."}, {"id": 206, "string": "This method lets the NN learn from the posterior label distribution produced by FOL rules in a teacher-student framework, but requires considerable amounts of data."}, {"id": 207, "string": "Therefore, although both hu16 and logit operate at the output level, logit still performs better than hu16 in these few-shot settings, since logit is easier to train."}, {"id": 208, "string": "It can also be seen that starting from 10-shot, two+both significantly outperforms pure REO."}, {"id": 209, "string": "This suggests that by using our attention loss to connect the distributional representation of the NN and the clue words of REs, we can generalize RE patterns within a NN architecture by using a small amount of annotated data."}, {"id": 210, "string": "Slot Filling."}, {"id": 211, "string": "Different from intent detection, as shown in Table 1 , our attention loss does not work for slot filling."}, {"id": 212, "string": "The reason is that the slot label of a target word (the word for which we are trying to predict a slot label) is decided mainly by the semantic meaning of the word itself, together with 0-3 phrases in the context to provide supplementary information."}, {"id": 213, "string": "However, our attention mechanism can only help in recognizing clue words in the context, which is less important than the word itself and have already been captured by the BLSTM, to some extent."}, {"id": 214, "string": "Therefore, the attention loss and the attention related parameters are more of a burden than a benefit."}, {"id": 215, "string": "As is shown in Fig."}, {"id": 216, "string": "1 , the model recognizes Boston as fromloc.city mainly because Boston itself is a city, and its context word from may have already been captured by the BLSTM and our attention mechanism does not help much."}, {"id": 217, "string": "By examining the attention values of +two trained on the full dataset, we find that instead of mark-ing informative context words, the attention tends to concentrate on the target word itself."}, {"id": 218, "string": "This observation further reinforces our hypothesis on the attention loss."}, {"id": 219, "string": "On the other hand, since the REtags provide extra information, such as type, about words in the sentence, logit and feat generally work better."}, {"id": 220, "string": "However, different from intent detection, feat only outperforms logit by a margin."}, {"id": 221, "string": "This is because feat can use the REtags of all words to generate better context representations through the NN, while logit can only utilize the REtag of the target word before the final output layer."}, {"id": 222, "string": "As a result, feat actually gathers more information from REs and can make better use of them than logit."}, {"id": 223, "string": "Again, hu16 is still outperformed by logit, possibly due to the insufficient data support in this few-shot scenario."}, {"id": 224, "string": "We also see that even the BLSTM outperforms REO in 5-shot, indicating while it is hard to write high-quality RE patterns, using REs to boost NNs is still feasible."}, {"id": 225, "string": "Summary."}, {"id": 226, "string": "The amount of extra information that a NN can utilize from the combined REs significantly affects the resulting performance."}, {"id": 227, "string": "Thus, the attention loss methods work best for intent detection and feat works best for slot filling."}, {"id": 228, "string": "We also see that the improvements from REs decreases as having more training data."}, {"id": 229, "string": "This is not surprising because the implicit knowledge embedded in the REs are likely to have already been captured by a sufficient large annotated dataset and in this scenario using the REs will bring in fewer benefits."}, {"id": 230, "string": "Partial Few-Shot Learning To better understand the relationship between our approach and existing few-shot learning methods, we also implement the memory network method Table 3 : Results on Full Dataset."}, {"id": 231, "string": "The left side of '/' applies for intent, and the right side for slot."}, {"id": 232, "string": "(Kaiser et al., 2017) which achieves good results in various few-shot datasets."}, {"id": 233, "string": "We adapt their opensource code, and add their memory module (mem) to our BLSTM model."}, {"id": 234, "string": "Since the memory module requires to be trained on either many few-shot classes or several classes with extra data, we expand our full few-shot dataset for intent detection, so that the top 3 intent labels have 300 sentences (partial few-shot)."}, {"id": 235, "string": "As shown in Table 2 , mem works better than BLSTM, and our attention loss can be further combined with the memory module (mem+posi), with even better performance."}, {"id": 236, "string": "hu16 also works here, but worse than two+both."}, {"id": 237, "string": "Note that, the memory module requires the input sentence to have only one embedding, thus we only use one set of positive attention for combination."}, {"id": 238, "string": "As for slot filling, since we already have extra data for frequent tags in the original few-shot data (see Sec."}, {"id": 239, "string": "4.1), we use them directly to run the memory module."}, {"id": 240, "string": "As shown in the bottom of Table  1 , mem also improves the base BLSTM, and gains further boost when it is combined with feat 6 ."}, {"id": 241, "string": "Full Dataset To answer Q2, we also evaluate our methods on the full dataset."}, {"id": 242, "string": "As seen in Table 3 , for intent detection, while two+both still works, feat and logit no longer give improvements."}, {"id": 243, "string": "This shows 6 For compactness, we only combine the best method in each task with mem, but others can also be combined."}, {"id": 244, "string": "that since both REtag and annotated data provide intent labels for the input sentence, the value of the extra noisy tag from RE become limited as we have more annotated data."}, {"id": 245, "string": "However, as there is no guidance on attention in the annotations, the clue words from REs are still useful."}, {"id": 246, "string": "Further, since feat concatenates REtags at the input level, the powerful NN makes it more likely to overfit than logit, therefore feat performs even worse when compared to the BLSTM."}, {"id": 247, "string": "As for slot filling, introducing feat and logit can still bring further improvements."}, {"id": 248, "string": "This shows that the word type information contained in the REtags is still hard to be fully learned even when we have more annotated data."}, {"id": 249, "string": "Moreover, different from few-shot settings, two+both has a better macro-F1 score than the BLSTM for this task, suggesting that better attention is still useful when the base model is properly trained."}, {"id": 250, "string": "Again, hu16 outperforms the BLSTM in both tasks, showing that although the REtags are noisy, their teacher-student network can still distill useful information."}, {"id": 251, "string": "However, hu16 is a general framework to combine FOL rules, which is more indirect in transferring knowledge from rules to NN than our methods."}, {"id": 252, "string": "Therefore, it is still inferior to attention loss in intent detection and feat in slot filling, which are designed to combine REs."}, {"id": 253, "string": "Further, mem generally works in this setting, and can receive further improvement by combining our fusion methods."}, {"id": 254, "string": "We can also see that two+both works clearly better than the stateof-art method (L&L16) in intent detection, which jointly models the two tasks."}, {"id": 255, "string": "And mem+feat is comparative to L&L16 in slot filling."}, {"id": 256, "string": "Impact of the RE Complexity We now discuss how the RE complexity affects the performance of the combination."}, {"id": 257, "string": "We choose to control the RE complexity by modifying the number of groups."}, {"id": 258, "string": "Specifically, we reduce the number of groups for existing REs to decrease RE complexity."}, {"id": 259, "string": "To mimic the process of writing simple REs from scratch, we try our best to keep the key RE groups."}, {"id": 260, "string": "For intent detection, all the REs are reduced to at most 2 groups."}, {"id": 261, "string": "As for slot filling, we also reduce the REs to at most 2 groups, and for some simples case, we further reduce them into word-list patterns, e.g., ( CITY)."}, {"id": 262, "string": "As shown in Table 4 , the simple REs already deliver clear improvements to the base NN models, which shows the effectiveness of our methods, and indicates that simple REs are quite costefficient since these simple REs only contain 1-2 RE groups and thus very easy to produce."}, {"id": 263, "string": "We can also see that using complex REs generally leads to better results compared to using simple REs."}, {"id": 264, "string": "This indicates that when considering using REs to improve a NN model, we can start with simple REs, and gradually increase the RE complexity to improve the performance over time 7 ."}, {"id": 265, "string": "Related Work Our work builds upon the following techniques, while qualitatively differing from each NN with Rules."}, {"id": 266, "string": "On the initialization side,  uses important n-grams to initialize the convolution filters."}, {"id": 267, "string": "On the input side, Wang et al."}, {"id": 268, "string": "(2017a) uses knowledge base rules to find relevant concepts for short texts to augment input."}, {"id": 269, "string": "On the output side, Hu et al."}, {"id": 270, "string": "(2016a; 2016b) and Guo et al."}, {"id": 271, "string": "(2017) use FOL rules to rectify the output probability of NN, and then let NN learn from the rectified distribution in a teacher-student framework."}, {"id": 272, "string": "Xiao et al."}, {"id": 273, "string": "(2017) , on the other hand, modifies the decoding score of NN by multiplying a weight derived from rules."}, {"id": 274, "string": "On the loss function side, people modify the loss function to model the relationship between premise and conclusion (Demeester et al., 2016) , and fit both human-annotated and rule-annotated labels (Alashkar et al., 2017) ."}, {"id": 275, "string": "Since fusing in initialization or in loss function often require special properties of the task, these approaches are not applicable to our problem."}, {"id": 276, "string": "Our work thus offers new ways to exploit RE rules at different levels of a NN."}, {"id": 277, "string": "NNs and REs."}, {"id": 278, "string": "As for NNs and REs, previous work has tried to use RE to speed up the decoding phase of a NN (Strau\u00df et al., 2016) and generating REs from natural language specifications of the 7 We do not include results of both for slot filling since its REs are different from feat and logit, and we have already shown that the attention loss method does not work for slot filling."}, {"id": 279, "string": "RE (Locascio et al., 2016) ."}, {"id": 280, "string": "By contrast, our work aims to use REs to improve the prediction ability of a NN."}, {"id": 281, "string": "Few-Shot Learning."}, {"id": 282, "string": "Prior work either considers few-shot learning in a metric learning framework (Koch et al., 2015; Vinyals et al., 2016) , or stores instances in a memory (Santoro et al., 2016; Kaiser et al., 2017) to match similar instances in the future."}, {"id": 283, "string": "Wang et al."}, {"id": 284, "string": "(2017b) further uses the semantic meaning of the class name itself to provide extra information for few-shot learning."}, {"id": 285, "string": "Unlike these previous studies, we seek to use the humangenerated REs to provide additional information."}, {"id": 286, "string": "Natural Language Understanding."}, {"id": 287, "string": "Recurrent neural networks are proven to be effective in both intent detection (Ravuri and Stoicke, 2015) and slot filling (Mesnil et al., 2015) ."}, {"id": 288, "string": "Researchers also find ways to jointly model the two tasks (Liu and Lane, 2016; Zhang and Wang, 2016) ."}, {"id": 289, "string": "However, no work so far has combined REs and NNs to improve intent detection and slot filling."}, {"id": 290, "string": "Conclusions In this paper, we investigate different ways to combine NNs and REs for solving typical SLU tasks."}, {"id": 291, "string": "Our experiments demonstrate that the combination clearly improves the NN performance in both the few-shot learning and the full dataset settings."}, {"id": 292, "string": "We show that by exploiting the implicit knowledge encoded within REs, one can significantly improve the learning performance."}, {"id": 293, "string": "Specifically, we observe that using REs to guide the attention module works best for intent detection, and using REtags as features is an effective approach for slot filling."}, {"id": 294, "string": "We provide interesting insights on how REs of various forms can be employed to improve NNs, showing that while simple REs are very cost-effective, complex REs generally yield better results."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 27}, {"section": "Typesetting", "n": "2.1", "start": 28, "end": 29}, {"section": "Problem Definition", "n": "2.2", "start": 30, "end": 35}, {"section": "The Use of Regular Expressions", "n": "2.3", "start": 36, "end": 63}, {"section": "Our Approach", "n": "3", "start": 64, "end": 66}, {"section": "Base Models", "n": "3.1", "start": 67, "end": 77}, {"section": "Using REs at the Input Level", "n": "3.2", "start": 78, "end": 95}, {"section": "Using REs at the Network Module Level", "n": "3.3", "start": 96, "end": 123}, {"section": "Using REs at the Output Level", "n": "3.4", "start": 124, "end": 134}, {"section": "Evaluation Methodology", "n": "4", "start": 135, "end": 137}, {"section": "Datasets", "n": "4.1", "start": 138, "end": 154}, {"section": "Preparing REs", "n": "4.2", "start": 155, "end": 168}, {"section": "Experimental Setup", "n": "4.3", "start": 169, "end": 194}, {"section": "Full Few-Shot Learning", "n": "5.1", "start": 195, "end": 229}, {"section": "Partial Few-Shot Learning", "n": "5.2", "start": 230, "end": 240}, {"section": "Full Dataset", "n": "5.3", "start": 241, "end": 255}, {"section": "Impact of the RE Complexity", "n": "5.4", "start": 256, "end": 264}, {"section": "Related Work", "n": "6", "start": 265, "end": 289}, {"section": "Conclusions", "n": "7", "start": 290, "end": 294}], "figures": [{"filename": "../figure/image/1009-Table4-1.png", "caption": "Table 4: Results on 20-Shot Data with Simple REs. +both refers to +two +both for short.", "page": 7, "bbox": {"x1": 306.71999999999997, "x2": 539.04, "y1": 62.879999999999995, "y2": 135.35999999999999}}, {"filename": "../figure/image/1009-Table2-1.png", "caption": "Table 2: Intent Detection Results on Partial FewShot Learning Setting.", "page": 7, "bbox": {"x1": 72.96, "x2": 287.03999999999996, "y1": 62.879999999999995, "y2": 145.92}}, {"filename": "../figure/image/1009-Table3-1.png", "caption": "Table 3: Results on Full Dataset. The left side of \u2018/\u2019 applies for intent, and the right side for slot.", "page": 7, "bbox": {"x1": 73.92, "x2": 286.08, "y1": 182.88, "y2": 300.0}}, {"filename": "../figure/image/1009-Figure1-1.png", "caption": "Figure 1: A sentence from the ATIS dataset. REs can be used to detect the intent and label slots.", "page": 1, "bbox": {"x1": 73.92, "x2": 288.0, "y1": 65.75999999999999, "y2": 131.04}}, {"filename": "../figure/image/1009-Figure2-1.png", "caption": "Figure 2: Overview of our methods. 1 , 2 , 3 refers to the methods in Sec. 3.2, 3.3, 3.4 respectively.", "page": 3, "bbox": {"x1": 99.84, "x2": 495.84, "y1": 67.67999999999999, "y2": 214.07999999999998}}, {"filename": "../figure/image/1009-Table1-1.png", "caption": "Table 1: Results on Full Few-Shot Learning Settings. For slot filling, we do not distinguish full and partial few-shot learning settings (see Sec. 4.1).", "page": 6, "bbox": {"x1": 77.75999999999999, "x2": 517.4399999999999, "y1": 62.879999999999995, "y2": 208.32}}]}