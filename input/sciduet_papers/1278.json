{"title": "Backpropagating through Structured Argmax using a SPIGOT", "abstract": "We introduce the structured projection of intermediate gradients optimization technique (SPIGOT), a new method for backpropagating through neural networks that include hard-decision structured predictions (e.g., parsing) in intermediate layers. SPIGOT requires no marginal inference, unlike structured attention networks (Kim et al., 2017) and some reinforcement learning-inspired solutions (Yogatama et al., 2017) . Like socalled straight-through estimators (Hinton, 2012), SPIGOT defines gradient-like quantities associated with intermediate nondifferentiable operations, allowing backpropagation before and after them; SPIGOT's proxy aims to ensure that, after a parameter update, the intermediate structure will remain well-formed. We experiment on two structured NLP pipelines: syntactic-then-semantic dependency parsing, and semantic parsing followed by sentiment classification. We show that training with SPIGOT leads to a larger improvement on the downstream task than a modularly-trained pipeline, the straight-through estimator, and structured attention, reaching a new state of the art on semantic dependency parsing.", "text": [{"id": 0, "string": "Introduction Learning methods for natural language processing are increasingly dominated by end-to-end differentiable functions that can be trained using gradient-based optimization."}, {"id": 1, "string": "Yet traditional NLP often assumed modular stages of processing that formed a pipeline; e.g., text was tokenized, then tagged with parts of speech, then parsed into a phrase-structure or dependency tree, then semantically analyzed."}, {"id": 2, "string": "Pipelines, which make \"hard\" (i.e., discrete) decisions at each stage, appear to be incompatible with neural learning, leading many researchers to abandon earlier-stage processing."}, {"id": 3, "string": "Inspired by findings that continue to see benefit from various kinds of linguistic or domain-specific preprocessing (He et al., 2017; Oepen et al., 2017; Ji and Smith, 2017) , we argue that pipelines can be treated as layers in neural architectures for NLP tasks."}, {"id": 4, "string": "Several solutions are readily available: \u2022 Reinforcement learning (most notably the REINFORCE algorithm; Williams, 1992) , and structured attention (SA; Kim et al., 2017) ."}, {"id": 5, "string": "These methods replace argmax with a sampling or marginalization operation."}, {"id": 6, "string": "We note two potential downsides of these approaches: (i) not all argmax-able operations have corresponding sampling or marginalization methods that are efficient, and (ii) inspection of intermediate outputs, which could benefit error analysis and system improvement, is more straightforward for hard decisions than for posteriors."}, {"id": 7, "string": "\u2022 The straight-through estimator (STE; Hinton, 2012) treats discrete decisions as if they were differentiable and simply passes through gradients."}, {"id": 8, "string": "While fast and surprisingly effective, it ignores constraints on the argmax problem, such as the requirement that every word has exactly one syntactic parent."}, {"id": 9, "string": "We will find, experimentally, that the quality of intermediate representations degrades substantially under STE."}, {"id": 10, "string": "This paper introduces a new method, the structured projection of intermediate gradients optimization technique (SPIGOT; \u00a72), which defines a proxy for the gradient of a loss function with respect to the input to argmax."}, {"id": 11, "string": "Unlike STE's gradient proxy, SPIGOT aims to respect the constraints in the argmax problem."}, {"id": 12, "string": "SPIGOT can be applied with any intermediate layer that is expressible as a constrained maximization problem, and whose feasible set can be projected onto."}, {"id": 13, "string": "We show empirically that SPIGOT works even when the maximization and the projection are done approximately."}, {"id": 14, "string": "We offer two concrete architectures that employ structured argmax as an intermediate layer: semantic parsing with syntactic parsing in the middle, and sentiment analysis with semantic parsing in the middle ( \u00a73)."}, {"id": 15, "string": "These architectures are trained using a joint objective, with one part using data for the intermediate task, and the other using data for the end task."}, {"id": 16, "string": "The datasets are not assumed to overlap at all, but the parameters for the intermediate task are affected by both parts of the training data."}, {"id": 17, "string": "Our experiments ( \u00a74) show that our architecture improves over a state-of-the-art semantic dependency parser, and that SPIGOT offers stronger performance than a pipeline, SA, and STE."}, {"id": 18, "string": "On sentiment classification, we show that semantic parsing offers improvement over a BiLSTM, more so with SPIGOT than with alternatives."}, {"id": 19, "string": "Our analysis considers how the behavior of the intermediate parser is affected by the end task ( \u00a75)."}, {"id": 20, "string": "Our code is open-source and available at https:// github.com/Noahs-ARK/SPIGOT."}, {"id": 21, "string": "Method Our aim is to allow a (structured) argmax layer in a neural network to be treated almost like any other differentiable function."}, {"id": 22, "string": "This would allow us to place, for example, a syntactic parser in the middle of a neural network, so that the forward calculation simply calls the parser and passes the parse tree to the next layer, which might derive syntactic features for the next stage of processing."}, {"id": 23, "string": "The challenge is in the backward computation, which is key to learning with standard gradientbased methods."}, {"id": 24, "string": "When its output is discrete as we assume here, argmax is a piecewise constant function."}, {"id": 25, "string": "At every point, its gradient is either zero or undefined."}, {"id": 26, "string": "So instead of using the true gradient, we will introduce a proxy for the gradient of the loss function with respect to the inputs to argmax, allowing backpropagation to proceed through the argmax layer."}, {"id": 27, "string": "Our proxy is designed as an improvement to earlier methods (discussed below) that completely ignore constraints on the argmax operation."}, {"id": 28, "string": "It accomplishes this through a projec-tion of the gradients."}, {"id": 29, "string": "We first lay out notation, and then briefly review max-decoding and its relaxation ( \u00a72.1)."}, {"id": 30, "string": "We define SPIGOT in \u00a72.2, and show how to use it to backpropagate through NLP pipelines in \u00a72.3."}, {"id": 31, "string": "Notation."}, {"id": 32, "string": "Our discussion centers around two tasks: a structured intermediate task followed by an end task, where the latter considers the outputs of the former (e.g., syntactic-then-semantic parsing)."}, {"id": 33, "string": "Inputs are denoted as x, and end task outputs as y."}, {"id": 34, "string": "We use z to denote intermediate structures derived from x."}, {"id": 35, "string": "We will often refer to the intermediate task as \"decoding\", in the structured prediction sense."}, {"id": 36, "string": "It seeks an output z = argmax z\u2208Z S from the feasible set Z, maximizing a (learned, parameterized) scoring function S for the structured intermediate task."}, {"id": 37, "string": "L denotes the loss of the end task, which may or may not also involve structured predictions."}, {"id": 38, "string": "We use \u2206 k\u22121 = {p \u2208 R k | 1 p = 1, p \u2265 0} to denote the (k \u2212 1)-dimensional simplex."}, {"id": 39, "string": "We denote the domain of binary variables as B = {0, 1}, and the unit interval as U = [0, 1]."}, {"id": 40, "string": "By projection of a vector v onto a set A, we mean the closest point in A to v, measured by Euclidean distance: proj A (v) = argmin v \u2208A v \u2212 v 2 ."}, {"id": 41, "string": "Relaxed Decoding Decoding problems are typically decomposed into a collection of \"parts\", such as arcs in a dependency tree or graph."}, {"id": 42, "string": "In such a setup, each element of z, z i , corresponds to one possible part, and z i takes a boolean value to indicate whether the part is included in the output structure."}, {"id": 43, "string": "The scoring function S is assumed to decompose into a vector s(x) of part-local, input-specific scores: z = argmax z\u2208Z S(x, z) = argmax z\u2208Z z s(x) (1) In the following, we drop s's dependence on x for clarity."}, {"id": 44, "string": "In many NLP problems, the output space Z can be specified by linear constraints (Roth and Yih, 2004) : A z \u03c8 \u2264 b, (2) where \u03c8 are auxiliary variables (also scoped by argmax), together with integer constraints (typically, each z i \u2208 B)."}, {"id": 45, "string": "Figure 1 : The original feasible set Z (red vertices), is relaxed into a convex polytope P (the area encompassed by blue edges)."}, {"id": 46, "string": "Left: making a gradient update to\u1e91 makes it step outside the polytope, and it is projected back to P, resulting in the projected pointz."}, {"id": 47, "string": "\u2207 s L is then along the edge."}, {"id": 48, "string": "Right: updating\u1e91 keeps it within P, and thus \u2207 s L = \u03b7\u2207\u1e91L."}, {"id": 49, "string": "The problem in Equation 1 can be NP-complete in general, so the {0, 1} constraints are often relaxed to [0, 1] to make decoding tractable (Martins et al., 2009) ."}, {"id": 50, "string": "Then the discrete combinatorial problem over Z is transformed into the optimization of a linear objective over a convex polytope P ={p \u2208 R d |Ap\u2264b}, which is solvable in polynomial time (Bertsimas and Tsitsiklis, 1997) ."}, {"id": 51, "string": "This is not necessary in some cases, where the argmax can be solved exactly with dynamic programming."}, {"id": 52, "string": "From STE to SPIGOT We now view structured argmax as an activation function that takes a vector of input-specific partscores s and outputs a solution\u1e91."}, {"id": 53, "string": "For backpropagation, to calculate gradients for parameters of s, the chain rule defines: \u2207 s L = J \u2207\u1e91L, (3) where the Jacobian matrix J = \u2202\u1e91 \u2202s contains the derivative of each element of\u1e91 with respect to each element of s. Unfortunately, argmax is a piecewise constant function, so its Jacobian is either zero (almost everywhere) or undefined (in the case of ties)."}, {"id": 54, "string": "One solution, taken in structured attention, is to replace the argmax with marginal inference and a softmax function, so that\u1e91 encodes probability distributions over parts (Kim et al., 2017; Liu and Lapata, 2018) ."}, {"id": 55, "string": "As discussed in \u00a71, there are two reasons to avoid this modification."}, {"id": 56, "string": "Softmax can only be used when marginal inference is feasible, by sum-product algorithms for example (Eisner, 2016; Friesen and Domingos, 2016) ; in general marginal inference can be #P-complete."}, {"id": 57, "string": "Further, a soft intermediate layer will be less amenable to inspection by anyone wishing to understand and improve the model."}, {"id": 58, "string": "In another line of work, argmax is augmented with a strongly-convex penalty on the solutions (Martins and Astudillo, 2016; Amos and Kolter, 2017; Niculae and Blondel, 2017; Niculae et al., 2018; Mensch and Blondel, 2018) ."}, {"id": 59, "string": "However, their approaches require solving a relaxation even when exact decoding is tractable."}, {"id": 60, "string": "Also, the penalty will bias the solutions found by the decoder, which may be an undesirable conflation of computational and modeling concerns."}, {"id": 61, "string": "A simpler solution is the STE method (Hinton, 2012), which replaces the Jacobian matrix in Equation 3 by the identity matrix."}, {"id": 62, "string": "This method has been demonstrated to work well when used to \"backpropagate\" through hard threshold functions Friesen and Domingos, 2018) and categorical random variables (Jang et al., 2016; Choi et al., 2017) ."}, {"id": 63, "string": "Consider for a moment what we would do if\u1e91 were a vector of parameters, rather than intermediate predictions."}, {"id": 64, "string": "In this case, we are seeking points in Z that minimize L; denote that set of minimizers by Z * ."}, {"id": 65, "string": "Given \u2207\u1e91L and step size \u03b7, we would update\u1e91 to be\u1e91 \u2212 \u03b7\u2207\u1e91L."}, {"id": 66, "string": "This update, however, might not return a value in the feasible set Z, or even (if we are using a linear relaxation) the relaxed set P. SPIGOT therefore introduces a projection step that aims to keep the \"updated\"\u1e91 in the feasible set."}, {"id": 67, "string": "Of course, we do not directly update\u1e91; we continue backpropagation through s and onward to the parameters."}, {"id": 68, "string": "But the projection step nonetheless alters the parameter updates in the way that our proxy for \"\u2207 s L\" is defined."}, {"id": 69, "string": "The procedure is defined as follows: Due to the convexity of P, the projected pointz will always be unique, and is guaranteed to be no farther thanp from any point in Z * (Luenberger and Ye, 2015)."}, {"id": 70, "string": "1 Compared to STE, SPIGOT in-volves a projection and limits \u2207 s L to a smaller space to satisfy constraints."}, {"id": 71, "string": "See Figure 1 for an illustration."}, {"id": 72, "string": "p =\u1e91 \u2212 \u03b7\u2207\u1e91L, (4a) z = proj P (p), (4b) \u2207 s L \u1e91 \u2212z."}, {"id": 73, "string": "(4c) When efficient exact solutions (such as dynamic programming) are available, they can be used."}, {"id": 74, "string": "Yet, we note that SPIGOT does not assume the argmax operation is solved exactly."}, {"id": 75, "string": "Backpropagation through Pipelines Using SPIGOT, we now devise an algorithm to \"backpropagate\" through NLP pipelines."}, {"id": 76, "string": "In these pipelines, an intermediate task's output is fed into an end task for use as features."}, {"id": 77, "string": "The parameters of the complete model are divided into two parts: denote the parameters of the intermediate task model by \u03c6 (used to calculate s), and those in the end task model as \u03b8."}, {"id": 78, "string": "2 As introduced earlier, the end-task loss function to be minimized is L, which depends on both \u03c6 and \u03b8. Algorithm 1 describes the forward and backward computations."}, {"id": 79, "string": "It takes an end task training pair x, y , along with the intermediate task's feasible set Z, which is determined by x."}, {"id": 80, "string": "It first runs the intermediate model and decodes to get intermediate structure\u1e91, just as in a standard pipeline."}, {"id": 81, "string": "Then forward propagation is continued into the end-task model to compute loss L, using\u1e91 to define input features."}, {"id": 82, "string": "Backpropagation in the endtask model computes \u2207 \u03b8 L and \u2207\u1e91L, and \u2207 s L is then constructed using Equations 4."}, {"id": 83, "string": "Backpropagation then continues into the intermediate model, computing \u2207 \u03c6 L. Due to its flexibility, SPIGOT is applicable to many training scenarios."}, {"id": 84, "string": "When there is no x, z training data for the intermediate task, SPIGOT can be used to induce latent structures for the end-task (Yogatama et al., 2017; Kim et al., 2017; Choi et al., 2017 , inter alia)."}, {"id": 85, "string": "When intermediate-task training data is available, one can use SPIGOT to adopt joint learning by minimizing an interpolation of L (on end-task data x, y ) and an intermediate-task loss function L (on intermediate task data x, z )."}, {"id": 86, "string": "This is the setting in our experiments; note that we do not assume any overlap in the training examples for the two tasks."}, {"id": 87, "string": "Algorithm 1 Forward and backward computation with SPIGOT."}, {"id": 88, "string": "1: procedure SPIGOT(x, y, Z) 2: Construct A, b such that Z = {p \u2208 Z d | Ap \u2264 b} 3: P \u2190 {p \u2208 R d | Ap \u2264 b} Relaxation 4: Forwardprop and compute s \u03c6 (x) 5:\u1e91 \u2190 argmax z\u2208Z z s \u03c6 (x) Intermediate decoding 6: Forwardprop and compute L given x, y, and\u1e91 7: Backprop and compute \u2207 \u03b8 L and \u2207\u1e91L 8:z \u2190 proj P (\u1e91 \u2212 \u03b7\u2207\u1e91L) Projection 9: \u2207sL \u2190\u1e91 \u2212z 10: Backprop and compute \u2207 \u03c6 L 11: end procedure considered in this work, arc-factored unlabeled dependency parsing and first-order semantic dependency parsing."}, {"id": 89, "string": "In early experiments we observe that for both tasks, projecting with respect to all constraints of their original formulations using a generic quadratic program solver was prohibitively slow."}, {"id": 90, "string": "Therefore, we construct relaxed polytopes by considering only a subset of the constraints."}, {"id": 91, "string": "3 The projection then decomposes into a series of singly constrained quadratic programs (QP), each of which can be efficiently solved in linear time."}, {"id": 92, "string": "The two approximate projections discussed here are used in backpropagation only."}, {"id": 93, "string": "In the forward pass, we solve the decoding problem using the models' original decoding algorithms."}, {"id": 94, "string": "Arc-factored unlabeled dependency parsing."}, {"id": 95, "string": "For unlabeled dependency trees, we impose [0, 1] constraints and single-headedness constraints."}, {"id": 96, "string": "4 Formally, given a length-n input sentence, excluding self-loops, an arc-factored parser considers d = n(n \u2212 1) candidate arcs."}, {"id": 97, "string": "Let i\u2192j denote an arc from the ith token to the jth, and \u03c3(i\u2192j) denote its index."}, {"id": 98, "string": "We construct the relaxed feasible set by: P DEP = \uf8f1 \uf8f2 \uf8f3 p \u2208 U d i =j p \u03c3(i\u2192j) = 1, \u2200j \uf8fc \uf8fd \uf8fe , (5) i.e., we consider each token j individually, and force single-headedness by constraining the number of arcs incoming to j to sum to 1."}, {"id": 99, "string": "Algorithm 2 summarizes the procedure to project onto P DEP ."}, {"id": 100, "string": "Line 3 forms a singly constrained QP, and can be solved in O(n) time (Brucker, 1984) ."}, {"id": 101, "string": "Algorithm 2 Projection onto the relaxed polytope P DEP for dependency tree structures."}, {"id": 102, "string": "Let bold \u03c3(\u00b7\u2192j) denote the index set of arcs incoming to j."}, {"id": 103, "string": "For a vector v, we use v \u03c3(\u00b7\u2192j) to denote vector [v k ] k\u2208\u03c3(\u00b7\u2192j) ."}, {"id": 104, "string": "1: procedure DEPPROJ(p) 2: for j = 1, 2, ."}, {"id": 105, "string": "."}, {"id": 106, "string": "."}, {"id": 107, "string": ", n do 3:z \u03c3(\u00b7\u2192j) \u2190 proj \u2206 n\u22122 p \u03c3(\u00b7\u2192j) 4: end for 5: returnz 6: end procedure First-order semantic dependency parsing."}, {"id": 108, "string": "Semantic dependency parsing uses labeled bilexical dependencies to represent sentence-level semantics (Oepen et al., 2014 (Oepen et al., , 2015 (Oepen et al., , 2016 ."}, {"id": 109, "string": "Each dependency is represented by a labeled directed arc from a head token to a modifier token, where the arc label encodes broadly applicable semantic relations."}, {"id": 110, "string": "Figure 2 diagrams a semantic graph from the DELPH-IN MRS-derived dependencies (DM), together with a syntactic tree."}, {"id": 111, "string": "We use a state-of-the-art semantic dependency parser (Peng et al., 2017) that considers three types of parts: heads, unlabeled arcs, and labeled arcs."}, {"id": 112, "string": "Let \u03c3(i \u2192 j) denote the index of the arc from i to j with semantic role ."}, {"id": 113, "string": "In addition to [0, 1] constraints, we constrain that the predictions for labeled arcs sum to the prediction of their associated unlabeled arc: P SDP p \u2208 U d p \u03c3(i \u2192j) = p \u03c3(i\u2192j) , \u2200i = j ."}, {"id": 114, "string": "(6) This ensures that exactly one label is predicted if and only if its arc is present."}, {"id": 115, "string": "The projection onto P SDP can be solved similarly to Algorithm 2."}, {"id": 116, "string": "We drop the determinism constraint imposed by Peng et al."}, {"id": 117, "string": "(2017) in the backward computation."}, {"id": 118, "string": "Experiments We empirically evaluate our method with two sets of experiments: using syntactic tree structures in semantic dependency parsing, and using semantic dependency graphs in sentiment classification."}, {"id": 119, "string": "Syntactic-then-Semantic Parsing In this experiment we consider an intermediate syntactic parsing task, followed by seman- tic dependency parsing as the end task."}, {"id": 120, "string": "We first briefly review the neural network architectures for the two models ( \u00a74.1.1), and then introduce the datasets ( \u00a74.1.2) and baselines ( \u00a74.1.3)."}, {"id": 121, "string": "Architectures Syntactic dependency parser."}, {"id": 122, "string": "For intermediate syntactic dependencies, we use the unlabeled arc-factored parser of Kiperwasser and Goldberg (2016) ."}, {"id": 123, "string": "It uses bidirectional LSTMs (BiLSTM) to encode the input, followed by a multilayerperceptron (MLP) to score each potential dependency."}, {"id": 124, "string": "One notable modification is that we replace their use of Chu-Liu/Edmonds' algorithm (Chu and Liu, 1965; Edmonds, 1967) with the Eisner algorithm (Eisner, 1996 (Eisner, , 2000 , since our dataset is in English and mostly projective."}, {"id": 125, "string": "Semantic dependency parser."}, {"id": 126, "string": "We use the basic model of Peng et al."}, {"id": 127, "string": "(2017) (denoted as NEUR-BOPARSER) as the end model."}, {"id": 128, "string": "It is a first-order parser, and uses local factors for heads, unlabeled arcs, and labeled arcs."}, {"id": 129, "string": "NEURBOPARSER does not use syntax."}, {"id": 130, "string": "It first encodes an input sentence with a two-layer BiLSTM, and then computes part scores with two-layer tanh-MLPs."}, {"id": 131, "string": "Inference is conducted with AD 3 ."}, {"id": 132, "string": "To add syntactic features to NEURBOPARSER, we concatenate a token's contextualized representation to that of its syntactic head, predicted by the intermediate parser."}, {"id": 133, "string": "Formally, given length-n input sentence, we first run a BiLSTM."}, {"id": 134, "string": "We use the concatenation of the two hidden representations h j = [ \u2212 \u2192 h j ; \u2190 \u2212 h j ] at each position j as the contextualized token representations."}, {"id": 135, "string": "We then concatenate h j with the representation of its head h HEAD(j) by h j = [h j ; h HEAD(j) ] = \uf8ee \uf8f0 h j ; i =j\u1e91 \u03c3(i\u2192j) h i \uf8f9 \uf8fb , (7) where\u1e91 \u2208 B n(n\u22121) is a binary encoding of the tree structure predicted by by the intermediate parser."}, {"id": 136, "string": "We then use h j anywhere h j would have been used in NEURBOPARSER."}, {"id": 137, "string": "In backpropagation, we compute \u2207\u1e91L with an automatic differentiation toolkit (DyNet; Neubig et al., 2017) ."}, {"id": 138, "string": "We note that this approach can be generalized to convolutional neural networks over graphs Duvenaud et al., 2015; Kipf and Welling, 2017, inter alia) , recurrent neural networks along paths Roth and Lapata, 2016, inter alia) or dependency trees (Tai et al., 2015) ."}, {"id": 139, "string": "We choose to use concatenations to control the model's complexity, and thus to better understand which parts of the model work."}, {"id": 140, "string": "We refer the readers to Kiperwasser and Goldberg (2016) and Peng et al."}, {"id": 141, "string": "(2017) for further details of the parsing models."}, {"id": 142, "string": "Training procedure."}, {"id": 143, "string": "Following previous work, we minimize structured hinge loss (Tsochantaridis et al., 2004) for both models."}, {"id": 144, "string": "We jointly train both models from scratch, by randomly sampling an instance from the union of their training data at each step."}, {"id": 145, "string": "In order to isolate the effect of backpropagation, we do not share any parameters between the two models."}, {"id": 146, "string": "5 Implementation details are summarized in the supplementary materials."}, {"id": 147, "string": "Datasets \u2022 For semantic dependencies, we use the English dataset from SemEval 2015 Task 18 (Oepen et al., 2015) ."}, {"id": 148, "string": "Among the three formalisms provided by the shared task, we consider DELPH-IN MRS-derived dependencies (DM) and Prague Semantic Dependencies (PSD)."}, {"id": 149, "string": "6 It includes \u00a700-19 of the WSJ corpus as training data, \u00a720 and \u00a721 for development and in-domain test data, resulting in a 33,961/1,692/1,410 train/dev./test split, and 5 Parameter sharing has proved successful in many related tasks (Collobert and Weston, 2008; S\u00f8gaard and Goldberg, 2016; Ammar et al., 2016; Swayamdipta et al., 2016 Swayamdipta et al., , 2017 , and could be easily combined with our approach."}, {"id": 150, "string": "6 We drop the third (PAS) because its structure is highly predictable from parts-of-speech, making it less interesting."}, {"id": 151, "string": "(Marcus et al., 1993) ."}, {"id": 152, "string": "To avoid data leak, we depart from standard split and use \u00a720 and \u00a721 as development and test data, and the remaining sections as training data."}, {"id": 153, "string": "The number of training/dev./test instances is 40,265/2,012/1,671."}, {"id": 154, "string": "Baselines We compare to the following baselines: \u2022 A pipelined system (PIPELINE)."}, {"id": 155, "string": "The pretrained parser achieves 92.9 test unlabeled attachment score (UAS)."}, {"id": 156, "string": "8 \u2022 Structured attention networks (SA; Kim et al., 2017) ."}, {"id": 157, "string": "We use the inside-outside algorithm (Baker, 1979) to populate z with arcs' marginal probabilities, use log-loss as the objective in training the intermediate parser."}, {"id": 158, "string": "\u2022 The straight-through estimator (STE; Hinton, 2012) , introduced in \u00a72.2."}, {"id": 159, "string": "Empirical Results Table 1 compares the semantic dependency parsing performance of SPIGOT to all five baselines."}, {"id": 160, "string": "FREDA3 (Peng et al., 2017) is a state-of-the-art variant of NEURBOPARSER that is trained using multitask learning to jointly predict three different semantic dependency graph formalisms."}, {"id": 161, "string": "Like the basic NEURBOPARSER model that we build from, FREDA3 does not use any syntax."}, {"id": 162, "string": "Strong DM performance is achieved in a more recent work by using joint learning and an ensemble (Peng et al., 2018) , which is beyond fair comparisons to the models discussed here."}, {"id": 163, "string": "We found that using syntactic information improves semantic parsing performance: using pipelined syntactic head features brings 0.5-1.4% absolute labeled F 1 improvement to NEUR-BOPARSER."}, {"id": 164, "string": "Such improvements are smaller compared to previous works, where dependency path and syntactic relation features are included (Almeida and Ribeyre et al., 2015; , indicating the potential to get better performance by using more syntactic information, which we leave to future work."}, {"id": 165, "string": "Both STE and SPIGOT use hard syntactic features."}, {"id": 166, "string": "By allowing backpropation into the intermediate syntactic parser, they both consistently outperform PIPELINE."}, {"id": 167, "string": "On the other hand, when marginal syntactic tree structures are used, SA outperforms PIPELINE only on the out-of-domain PSD test set, and improvements under other cases are not observed."}, {"id": 168, "string": "Compared to STE, SPIGOT outperforms STE on DM by more than 0.3% absolute labeled F 1 , both in-domain and out-of-domain."}, {"id": 169, "string": "For PSD, SPIGOT achieves similar performance to STE on in-domain test set, but has a 0.5% absolute labeled F 1 improvement on out-of-domain data, where syntactic parsing is less accurate."}, {"id": 170, "string": "tecture achieves 93.5 UAS when trained and evaluated with the standard split, close to the results reported by Kiperwasser and Goldberg (2016) ."}, {"id": 171, "string": "Semantic Dependencies for Sentiment Classification Our second experiment uses semantic dependency graphs to improve sentiment classification performance."}, {"id": 172, "string": "We are not aware of any efficient algorithm that solves marginal inference for semantic dependency graphs under determinism constraints, so we do not include a comparison to SA."}, {"id": 173, "string": "Architectures Here we use NEURBOPARSER as the intermediate model, as described in \u00a74.1.1, but with no syntactic enhancements."}, {"id": 174, "string": "Sentiment classifier."}, {"id": 175, "string": "We first introduce a baseline that does not use any structural information."}, {"id": 176, "string": "It learns a one-layer BiLSTM to encode the input sentence, and then feeds the sum of all hidden states into a two-layer ReLU-MLP."}, {"id": 177, "string": "To use semantic dependency features, we concatenate a word's BiLSTM-encoded representation to the averaged representation of its heads, together with the corresponding semantic roles, similarly to that in Equation 7."}, {"id": 178, "string": "9 Then the concatenation is fed into an affine transformation followed by a ReLU activation."}, {"id": 179, "string": "The rest of the model is kept the same as the BiLSTM baseline."}, {"id": 180, "string": "Training procedure."}, {"id": 181, "string": "We use structured hinge loss to train the semantic dependency parser, and log-loss for the sentiment classifier."}, {"id": 182, "string": "Due to the discrepancy in the training data size of the two tasks (33K vs. 7K), we pre-train a semantic dependency parser, and then adopt joint training together with the classifier."}, {"id": 183, "string": "In the joint training stage, we randomly sample 20% of the semantic dependency training instances each epoch."}, {"id": 184, "string": "Implementations are detailed in the supplementary materials."}, {"id": 185, "string": "Datasets For semantic dependencies, we use the DM dataset introduced in \u00a74.1.2."}, {"id": 186, "string": "We consider a binary classification task using the Stanford Sentiment Treebank (Socher et al., 2013) ."}, {"id": 187, "string": "It consists of roughly 10K movie review sentences from Rotten Tomatoes."}, {"id": 188, "string": "The full dataset includes a rating on a scale from 1 to 5 for each constituent (including the full sentences), resulting in more than 200K instances."}, {"id": 189, "string": "Following previous work (Iyyer et al., 2015) , we only use full-sentence  instances, with neutral instances excluded (3s) and the remaining four rating levels converted to binary \"positive\" or \"negative\" labels."}, {"id": 190, "string": "This results in a 6,920/872/1,821 train/dev./test split."}, {"id": 191, "string": "Empirical Results Table 2 compares our SPIGOT method to three baselines."}, {"id": 192, "string": "Pipelined semantic dependency predictions brings 0.9% absolute improvement in classification accuracy, and SPIGOT outperforms all baselines."}, {"id": 193, "string": "In this task STE achieves slightly worse performance than a fixed pre-trained PIPELINE."}, {"id": 194, "string": "Analysis We examine here how the intermediate model is affected by the end-task training signal."}, {"id": 195, "string": "Is the endtask signal able to \"overrule\" intermediate predictions?"}, {"id": 196, "string": "We use the syntactic-then-semantic parsing model ( \u00a74.1) as a case study."}, {"id": 197, "string": "Table 3 compares a pipelined system to one jointly trained using SPIGOT."}, {"id": 198, "string": "We consider the development set instances where both syntactic and semantic annotations are available, and partition them based on whether the two systems' syntactic predictions agree (SAME), or not (DIFF)."}, {"id": 199, "string": "The second group includes sentences with much lower syntactic parsing accuracy (91.3 vs. 97.4 UAS), and SPIGOT further reduces this to 89.6."}, {"id": 200, "string": "Even though these changes hurt syntactic parsing accuracy, they lead to a 1.1% absolute gain in labeled F 1 for semantic parsing."}, {"id": 201, "string": "Furthermore, SPIGOT Table 3 : Syntactic parsing performance (in unlabeled attachment score, UAS) and DM semantic parsing performance (in labeled F 1 ) on different groups of the development data."}, {"id": 202, "string": "Both systems predict the same syntactic parses for instances from SAME, and they disagree on instances from DIFF ( \u00a75)."}, {"id": 203, "string": "tree, we consider three cases: (a) h is a head of m in the semantic graph; (b) h is a modifier of m in the semantic graph; (c) h is the modifier of m in the semantic graph."}, {"id": 204, "string": "The first two reflect modifications to the syntactic parse that rearrange semantically linked words to be neighbors."}, {"id": 205, "string": "Under (c), the semantic parser removes a syntactic dependency that reverses the direction of a semantic dependency."}, {"id": 206, "string": "These cases account for 17.6%, 10.9%, and 12.8%, respectively (41.2% combined) of the total changes."}, {"id": 207, "string": "Making these changes, of course, is complicated, since they often require other modifications to maintain well-formedness of the tree."}, {"id": 208, "string": "Figure 2 gives an example."}, {"id": 209, "string": "Related Work Joint learning in NLP pipelines."}, {"id": 210, "string": "To avoid cascading errors, much effort has been devoted to joint decoding in NLP pipelines (Habash and Rambow, 2005; Cohen and Smith, 2007; Goldberg and Tsarfaty, 2008; Lewis et al., 2015; Zhang et al., 2015, inter alia) ."}, {"id": 211, "string": "However, joint inference can sometimes be prohibitively expensive."}, {"id": 212, "string": "Recent advances in representation learning facilitate exploration in the joint learning of multiple tasks by sharing parameters (Collobert and Weston, 2008; Blitzer et al., 2006; Finkel and Manning, 2010; Zhang and Weiss, 2016; Hashimoto et al., 2017, inter alia) ."}, {"id": 213, "string": "Differentiable optimization."}, {"id": 214, "string": "Gould et al."}, {"id": 215, "string": "(2016) review the generic approaches to differentiation in bi-level optimization (Bard, 2010; Kunisch and Pock, 2013) ."}, {"id": 216, "string": "Amos and Kolter (2017) extend their efforts to a class of subdifferentiable quadratic programs."}, {"id": 217, "string": "However, they both require that the intermediate objective has an invertible Hessian, limiting their application in NLP."}, {"id": 218, "string": "In another line of work, the steps of a gradient-based optimization procedure are unrolled into a single computation graph (Stoyanov et al., 2011; Domke, 2012; Goodfellow et al., 2013; Brakel et al., 2013) ."}, {"id": 219, "string": "This comes at a high computational cost due to the second-order derivative computation during backpropagation."}, {"id": 220, "string": "Moreover, constrained optimization problems (like many NLP problems) often require projection steps within the procedure, which can be difficult to differentiate through (Belanger and McCallum, 2016; Belanger et al., 2017) ."}, {"id": 221, "string": "Conclusion We presented SPIGOT, a novel approach to backpropagating through neural network architectures that include discrete structured decisions in intermediate layers."}, {"id": 222, "string": "SPIGOT devises a proxy for the gradients with respect to argmax's inputs, employing a projection that aims to respect the constraints in the intermediate task."}, {"id": 223, "string": "We empirically evaluate our method with two architectures: a semantic parser with an intermediate syntactic parser, and a sentiment classifier with an intermediate semantic parser."}, {"id": 224, "string": "Experiments show that SPIGOT achieves stronger performance than baselines under both settings, and outperforms stateof-the-art systems on semantic dependency parsing."}, {"id": 225, "string": "Our implementation is available at https: //github.com/Noahs-ARK/SPIGOT."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 20}, {"section": "Method", "n": "2", "start": 21, "end": 40}, {"section": "Relaxed Decoding", "n": "2.1", "start": 41, "end": 51}, {"section": "From STE to SPIGOT", "n": "2.2", "start": 52, "end": 74}, {"section": "Backpropagation through Pipelines", "n": "2.3", "start": 75, "end": 115}, {"section": "Experiments", "n": "4", "start": 116, "end": 118}, {"section": "Syntactic-then-Semantic Parsing", "n": "4.1", "start": 119, "end": 120}, {"section": "Architectures", "n": "4.1.1", "start": 121, "end": 146}, {"section": "Datasets", "n": "4.1.2", "start": 147, "end": 153}, {"section": "Baselines", "n": "4.1.3", "start": 154, "end": 158}, {"section": "Empirical Results", "n": "4.1.4", "start": 159, "end": 170}, {"section": "Semantic Dependencies for Sentiment Classification", "n": "4.2", "start": 171, "end": 172}, {"section": "Architectures", "n": "4.2.1", "start": 173, "end": 184}, {"section": "Datasets", "n": "4.2.2", "start": 185, "end": 190}, {"section": "Empirical Results", "n": "4.2.3", "start": 191, "end": 193}, {"section": "Analysis", "n": "5", "start": 194, "end": 208}, {"section": "Related Work", "n": "6", "start": 209, "end": 220}, {"section": "Conclusion", "n": "7", "start": 221, "end": 225}], "figures": [{"filename": "../figure/image/1278-Figure1-1.png", "caption": "Figure 1: The original feasible set Z (red vertices), is relaxed into a convex polytope P (the area encompassed by blue edges). Left: making a gradient update to z\u0302 makes it step outside the polytope, and it is projected back to P , resulting in the projected point z\u0303. \u2207sL is then along the edge. Right: updating z\u0302 keeps it within P , and thus\u2207sL = \u03b7\u2207z\u0302L.", "page": 2, "bbox": {"x1": 86.88, "x2": 269.28, "y1": 61.44, "y2": 120.96}}, {"filename": "../figure/image/1278-Table1-1.png", "caption": "Table 1: Semantic dependency parsing performance in both unlabeled (UF ) and labeled (LF ) F1 scores. Bold font indicates the best performance. Peng et al. (2017) does not report UF .", "page": 5, "bbox": {"x1": 308.64, "x2": 524.16, "y1": 62.4, "y2": 381.12}}, {"filename": "../figure/image/1278-Figure2-1.png", "caption": "Figure 2: A development instance annotated with both gold DM semantic dependency graph (red arcs on the top), and gold syntactic dependency tree (blue arcs at the bottom). A pretrained syntactic parser predicts the same tree as the gold; the semantic parser backpropagates into the intermediate syntactic parser, and changes the dashed blue arcs into dashed red arcs (\u00a75).", "page": 4, "bbox": {"x1": 333.59999999999997, "x2": 516.0, "y1": 97.44, "y2": 115.19999999999999}}, {"filename": "../figure/image/1278-Table2-1.png", "caption": "Table 2: Test accuracy of sentiment classification on Stanford Sentiment Treebank. Bold font indicates the best performance.", "page": 7, "bbox": {"x1": 120.96, "x2": 241.44, "y1": 62.4, "y2": 148.32}}, {"filename": "../figure/image/1278-Table3-1.png", "caption": "Table 3: Syntactic parsing performance (in unlabeled attachment score, UAS) and DM semantic parsing performance (in labeled F1) on different groups of the development data. Both systems predict the same syntactic parses for instances from SAME, and they disagree on instances from DIFF (\u00a75).", "page": 7, "bbox": {"x1": 320.64, "x2": 512.16, "y1": 61.44, "y2": 133.92}}]}