{"title": "KyotoEBMT System Description for the 2nd Workshop on Asian Translation", "abstract": "This paper introduces the Ky-otoEBMT example-based machine translation framework. Since last year's workshop we have replaced input trees with forests, improved alignment, added new features, and introduced bilingual neural network reranking. The major benefits of our system include online example retrieval and flexible reordering. We also use syntactic dependency analysis for both source and target languages in the hope of learning how to translate non-local structure. The system implementation (this paper refers to version 1.0) is available as open-source.", "text": [{"id": 0, "string": "Introduction This paper describes the KyotoEBMT system used in the 2nd Workshop on Asian Translation (Nakazawa et."}, {"id": 1, "string": "al, 2015) ."}, {"id": 2, "string": "Our system is a fully-fledged Example-Based Machine Translation (EBMT) platform making use of both source-language and target-language dependency structure."}, {"id": 3, "string": "This approach has been explored comparatively less in studies on syntax-based SMT/EBMT, which tend to focus on constituent trees rather than dependency trees, and on tree-to-string rather than tree-to-tree approaches."}, {"id": 4, "string": "Furthermore, we employ separate dependency parsers for each language rather than projecting the dependencies from one language to another, as in (Quirk et."}, {"id": 5, "string": "al, 2005) ."}, {"id": 6, "string": "The dependency structure information is used end-to-end: for improving the quality of the alignment of the translation examples, for constraining the translation rule extraction and for guiding the decoding."}, {"id": 7, "string": "We believe that dependency structure, which considers more than just local context, is important in order to generate fluent and accurate translations of complex sentences across distant language pairs."}, {"id": 8, "string": "The experiments described in this paper focus on technical domain translation for Japanese-Chinese and Japanese-English, however our implementation is applicable to any domain and language pair for which there exist parallel sentences and dependency parsers."}, {"id": 9, "string": "A further unique characteristic of our system is that, again contrary to the majority of similar systems, it does not rely on precomputation of translation rules."}, {"id": 10, "string": "Instead it matches each input sentence to the full database of translation examples before extracting translation rules online."}, {"id": 11, "string": "This has the merit of maximizing the information available when creating and combining translation rules, while retaining the ability to produce excellent translations for input sentences similar to an existing translation example."}, {"id": 12, "string": "The system is mostly developed in C++ and is available as open source."}, {"id": 13, "string": "The code and documentation are available from http://nlp.ist.i.kyoto-u.ac.jp/kyotoebmt/."}, {"id": 14, "string": "Experiments are facilitated through the inclusion of an end-to-end experiment management system (EMS) which has been greatly improved in this version."}, {"id": 15, "string": "The framework is simple to use and supports model training with multiple threads or across a cluster."}, {"id": 16, "string": "Figure 1 shows the basic structure of the Ky-otoEBMT translation pipeline."}, {"id": 17, "string": "System Overview The training process begins with parsing and aligning parallel sentences from the training corpus."}, {"id": 18, "string": "The alignments are then used to build an example database ('translation mem- Step 1 is the creation of the example database, trained from a parallel corpus."}, {"id": 19, "string": "Step 2 is the parsing of an input sentence and the generation of sets of initial hypotheses."}, {"id": 20, "string": "Step 3 consists in decoding and reranking."}, {"id": 21, "string": "The tuning of the weights for decoding and reranking is done by a modified version of step 3. ory') containing 'examples' or 'treelets' that form the hypotheses to be combined during decoding."}, {"id": 22, "string": "Translation is performed by first parsing an input sentence then searching for treelets matching entries in the example database."}, {"id": 23, "string": "The retrieved treelets are combined by a lattice-based decoder that optimizes a log linear model score."}, {"id": 24, "string": "Finally, we use a reranker to select the optimal translation from the n-best list provided by the decoder using additional non-local features (see section 3.4)."}, {"id": 25, "string": "Figure 2 shows the process of combining examples matching the input tree to create an output sentence."}, {"id": 26, "string": "Example retrieval and translation hypothesis construction An important characteristic of our system is that we do not extract and store translation rules in advance: the alignment of translation examples is performed offline."}, {"id": 27, "string": "However, for a given input sentence i, the steps for finding examples partially matching i and extracting their translation hypotheses is an online process."}, {"id": 28, "string": "This approach could be considered to be more faithful to the original EBMT approach advocated by Nagao (1984) ."}, {"id": 29, "string": "It has already been proposed for phrase-based (Callison-Burch et al., 2005) , hierarchical (Lopez, 2007) , and syntax-based (Cromi\u00e8res and Kurohashi, 2011) systems."}, {"id": 30, "string": "It does not however, seem to be very commonly integrated in syntax-based MT."}, {"id": 31, "string": "This approach has several benefits."}, {"id": 32, "string": "The first is that we are not required to impose a limit on the size of translation hypotheses."}, {"id": 33, "string": "Systems extracting rules in advance typically restrict the size and number of extracted rules for fear of becoming unmanageable."}, {"id": 34, "string": "In particular, if an input sentence is the same or very similar to one of our translation examples, we will be able to retrieve a perfect translation."}, {"id": 35, "string": "A second advantage is that we can make use of the full context of the example to assign features and scores to each translation hypothesis."}, {"id": 36, "string": "The main drawback of our approach is that it can be computationally more expensive to retrieve arbitrarily large matchings in the example database online than it is to match precomputed rules."}, {"id": 37, "string": "We use the techniques described in Cromi\u00e8res and Kurohashi (2011) to perform this step as efficiently as possible."}, {"id": 38, "string": "Once we have found an example translation (s, t) for which s partially matches i, we proceed to extract a translation hypothesis from it."}, {"id": 39, "string": "A translation hypothesis is defined as a generic translation rule for a part p of the input sentence that is represented as a targetlanguage treelet, with non-terminals representing the insertion positions for the translations of other parts of the sentence."}, {"id": 40, "string": "A translation hypothesis is created from a translation example as follows: 1."}, {"id": 41, "string": "We project the part of s that is matched into the target side t using the alignment of s and t. This is trivial if each word of s and t is aligned, but this is not typically the case."}, {"id": 42, "string": "Therefore our translation hypotheses will often have some target words/nodes marked as optionals: this means that we will decide if they should be added to the final translation only at the moment of combination."}, {"id": 43, "string": "2."}, {"id": 44, "string": "We insert the non-terminals as child nodes of the projected subtree."}, {"id": 45, "string": "This is Figure 2 : The process of translation."}, {"id": 46, "string": "The source sentence is parsed and matching subtrees from the example database are retrieved."}, {"id": 47, "string": "From the examples, we extract translation hypotheses than can contain optional target words and several position for each non-terminals."}, {"id": 48, "string": "For example the translation hypothesis containing \"textbook\" has three possible position for the non-terminal X3 (as a left-child before \"a\", as a left-child after \"a\" or as a right-child)."}, {"id": 49, "string": "The translation hypotheses are then combined during decoding."}, {"id": 50, "string": "Choice of optional words and final non-terminal positions is also done during decoding."}, {"id": 51, "string": "Figure 3 : A translation hypothesis endoded as a lattice."}, {"id": 52, "string": "This representation allows us to handle efficiently the ambiguities of our translation rules."}, {"id": 53, "string": "Note that each path in this lattice corresponds to different choices of insertion position for X2, morphological forms of \"be\", and the optional insertion of \"at\"."}, {"id": 54, "string": "simple if i, s and t have the same structure and are perfectly aligned, but again this is not typically the case."}, {"id": 55, "string": "A consequence is that we will sometimes have several possible insertion positions for each non-terminal."}, {"id": 56, "string": "The choice of insertion position is again made during combination."}, {"id": 57, "string": "Decoding After having extracted translation hypotheses for as many parts of the input tree as possible, we need to decide how to select and combine them."}, {"id": 58, "string": "Our approach here is similar to what has been proposed for Corpus-Based Machine Translation."}, {"id": 59, "string": "We first choose a number of features and create a linear model scoring each possible combination of hypotheses (see Section 3.3)."}, {"id": 60, "string": "We then attempt to find the combination that maximizes this model score."}, {"id": 61, "string": "The combination of rules is constrained by the structure of the input dependency tree."}, {"id": 62, "string": "If we only consider local features 1 , then a simple bottom-up dynamic programming approach can efficiently find the optimal combination with linear O(|H|) complexity 2 ."}, {"id": 63, "string": "However, non-local features (such as language models) will force us to prune the search space."}, {"id": 64, "string": "This pruning is done efficiently through a variation of cube-pruning (Chiang, 2007) ."}, {"id": 65, "string": "We use KenLM 3 (Heafield, 2011) for computing the target language model score."}, {"id": 66, "string": "Decoding is made more efficient by using some of the more advanced features of KenLM such as state-reduction ( (Li and Khudanpur, 2008) , ) and rest-cost estimations (Heafield et al., 2012) ."}, {"id": 67, "string": "Compared with the original cube-pruning algorithm, our decoder is designed to handle an arbitrary number of non-terminals."}, {"id": 68, "string": "In addition, as we have seen in Section 2.1, the translation hypotheses we initially extract from examples are ambiguous in term of which target word is going to be used and which will be the final position of each non-terminal."}, {"id": 69, "string": "In order to handle such ambiguities, we use a lattice-based internal representation that can encode them efficiently (see Figure 3 )."}, {"id": 70, "string": "This lattice representation also allows the decoder to make choices between various morphological variations of a word (e.g."}, {"id": 71, "string": "be/is/are)."}, {"id": 72, "string": "We use the decoding algorithm described in ."}, {"id": 73, "string": "Improvements from WAT2014 Alignment Based on the findings of Neubig and Duh (2014) , we experimented with supervised alignment using Nile (Riesa et al., 2011) as part of our translation framework."}, {"id": 74, "string": "We found that using supervised alignments made a considerable improvement to translation quality."}, {"id": 75, "string": "Since Nile supports only constituency parses, we also perform constituency parsing for source and target languages for generating bidirectional word alignments."}, {"id": 76, "string": "For the initial alignments for Nile, we use the alignments generated from the model described in last year's system description (Richardson et al., 2014) , which makes use of our dependency parses in order to capture non-local reorderings."}, {"id": 77, "string": "Forest Input We found that the quality of the source-side dependency parsing had an important impact 3 http://kheafield.com/code/kenlm/ on translation quality."}, {"id": 78, "string": "Unfortunately, parsing errors are unavoidable."}, {"id": 79, "string": "Chinese parsing is maybe especially challenging and our Chinese parser still produces a significant number of parsing errors."}, {"id": 80, "string": "In order to mitigate this problem, last year we used a k-best list of input parses."}, {"id": 81, "string": "We found this was somewhat successful but inefficient, and therefore have moved from a k-best list representation of multiple parses to a more compact and efficient forest representation."}, {"id": 82, "string": "In the future, we will consider also using forests for all the translation examples (and not just the input sentence)."}, {"id": 83, "string": "Features During decoding we use a linear model to score each possible combination of hypotheses."}, {"id": 84, "string": "This linear model is based on a linear combination of both local features (local to each translation hypothesis) and non-local features (such as a 5-gram language model score of the final translation)."}, {"id": 85, "string": "Despite our already relatively large set of dense features, we found there were a number of cases where these features were not enough to differentiate between good and bad translation hypotheses."}, {"id": 86, "string": "This year we have added ten new features, now reaching a total of 52, a selection of which are shown below: \u2022 Similarity between source and input word embeddings (Mikolov et al., 2013) The optimal weights for each feature are as before estimated using the implementation of k-best batch MIRA (Cherry and Foster, 2012) included in Moses."}, {"id": 87, "string": "Reranking A final reranking step allows us to use more advanced features for selecting the best translations."}, {"id": 88, "string": "We reranked the n-best output of our system using several additional language models: a standard 7-gram language model with Modified Kneser-Ney smoothing, a Recurrent Neural Network Language Model (RNNLM) (Mikolov et."}, {"id": 89, "string": "al, 2010) and several variations of a Bilingual Recurrent Neural Network Language Model."}, {"id": 90, "string": "The RNNLM model was trained with hidden layer size 200, and 5000 sentences from the training fold were used as validation data."}, {"id": 91, "string": "For the bilingual language model, we used the Neural Machine Translation Model of (Bahdanau et."}, {"id": 92, "string": "al, 2014) which has an open source implementation in the Ground-Hog/Theano framework 4 ."}, {"id": 93, "string": "For each language pair we trained two models, one for each translation direction."}, {"id": 94, "string": "In addition, for Japanese and Chinese, we considered two types of segmentation: the segmentation produced by our morphological analyzer, and a character-level segmentation."}, {"id": 95, "string": "We had therefore up to four models per language pair."}, {"id": 96, "string": "Rescoring our translations with these models gave up to four additional features."}, {"id": 97, "string": "It is interesting to note that although trying to directly translate our input sentences using these neural MT models typically resulted in a comparatively low BLEU score, they turned out to be useful for reranking in our system."}, {"id": 98, "string": "This is probably due to the fact that, since they represent a very different approach to translation, the models tend to learn different aspects of the translation and make different mistakes to our system."}, {"id": 99, "string": "Using a character-based segmentation further ensured the neural models learned a different kind of information."}, {"id": 100, "string": "The models took two to four days each to train on a GPU."}, {"id": 101, "string": "The settings we used were mostly the defaults of the implementations 5 ."}, {"id": 102, "string": "Reranking was conducted by first calculating the various language model scores for each 4 https://github.com/lisa-groundhog/GroundHog 5 More precisely, the hidden layer size was 1000."}, {"id": 103, "string": "Training done with a minibatch size of 64 and the adadelta algorithm (rho = 0.95, eps = 1e-6)."}, {"id": 104, "string": "Vocabulary size was reduced to 20,000 for the word-segmented model."}, {"id": 105, "string": "Backpropagation through time number of steps increased to up to 100 for the character-based models."}, {"id": 106, "string": "translation in the n-best list."}, {"id": 107, "string": "These features were added to those used in the first round of tuning, then one final iteration of tuning was run."}, {"id": 108, "string": "The tuning algorithm and settings were the same as for standard tuning."}, {"id": 109, "string": "This retuning step was added in order to find an optimal combination of the additional features with related features such as sentence length and the score given by the 5-gram language model used inside the decoder."}, {"id": 110, "string": "Experiments We conducted translation experiments on the four language pairs in the scientific papers subtask: Japanese-English (JA-EN), English-Japanese (EN-JA), Japanese-Chinese (JA-ZH) and Chinese-Japanese (ZH-JA)."}, {"id": 111, "string": "The proposed system used the following dependency parsers and show below their approximate parsing accuracies (micro-average), which were evaluated by hand on a random subset of sentences from the test data."}, {"id": 112, "string": "The parsers were trained on domains different to those used in the experiments."}, {"id": 113, "string": "\u2022 English: NLParser 6 (92%) (Charniak and Johnson, 2005) \u2022 Japanese: KNP (96%) (Kawahara and Kurohashi, 2006) \u2022 Chinese: SKP (88%) (Shen et al., 2012) For generating input for Nile we used the following constituency parsers: \u2022 English: Berkeley Parser (Petrov et al., 2006) \u2022 Japanese: Cyklark (Oda et al., 2015) \u2022 Chinese: Berkeley Parser (Petrov et al., 2006) Forests were created by packing the 200-best dependency parses for Japanese and English, and 50-best parses for Chinese."}, {"id": 114, "string": "Table 1 shows the results of our proposed system (WAT15) and a comparison with the system from last year (WAT14) (Richardson Nakazawa et al."}, {"id": 115, "string": "(2015) )."}, {"id": 116, "string": "We give results for evaluation on the test set after tuning (WAT15, WAT14) and tuning plus reranking (WAT15+Rerank, WAT14+Rerank)."}, {"id": 117, "string": "Tuning was conducted over 10 iterations on the development set using an n-best list of length 500, and we used the 1000best for reranking."}, {"id": 118, "string": "WAT15+Rerank was the strongest system in our comparison, outperforming the official baseline, non-reranked system (WAT15) and last year's systems in all metrics for all languages, with the minor exception of JA-ZH human evaluation for reranked vs. nonreranked."}, {"id": 119, "string": "Results Conclusion In this paper we have described the latest version of the KyotoEBMT example-based translation system."}, {"id": 120, "string": "Since last year we have improved alignment, introduced forest input, added new features and used bilingual neural network features in reranking."}, {"id": 121, "string": "In our preparation for this workshop we have focused mainly on improving Japanese-Chinese and Chinese-Japanese translation, particularly in terms of dealing with poor quality Chinese dependency parses."}, {"id": 122, "string": "As future work we plan to perform more extensive error analysis on the other language pairs."}, {"id": 123, "string": "We also found that despite using forest input there are still many issues caused by incorrect parsing and will consider in the future how best to overcome this."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 16}, {"section": "System Overview", "n": "2", "start": 17, "end": 25}, {"section": "Example retrieval and translation hypothesis construction", "n": "2.1", "start": 26, "end": 56}, {"section": "Decoding", "n": "2.2", "start": 57, "end": 72}, {"section": "Alignment", "n": "3.1", "start": 73, "end": 76}, {"section": "Forest Input", "n": "3.2", "start": 77, "end": 82}, {"section": "Features", "n": "3.3", "start": 83, "end": 86}, {"section": "Reranking", "n": "3.4", "start": 87, "end": 109}, {"section": "Experiments", "n": "4", "start": 110, "end": 118}, {"section": "Conclusion", "n": "5", "start": 119, "end": 123}], "figures": [{"filename": "../figure/image/1113-Figure3-1.png", "caption": "Figure 3: A translation hypothesis endoded as a lattice. This representation allows us to handle efficiently the ambiguities of our translation rules. Note that each path in this lattice corresponds to different choices of insertion position for X2, morphological forms of \u201cbe\u201d, and the optional insertion of \u201cat\u201d.", "page": 2, "bbox": {"x1": 80.64, "x2": 281.28, "y1": 476.64, "y2": 510.24}}, {"filename": "../figure/image/1113-Figure2-1.png", "caption": "Figure 2: The process of translation. The source sentence is parsed and matching subtrees from the example database are retrieved. From the examples, we extract translation hypotheses than can contain optional target words and several position for each non-terminals. For example the translation hypothesis containing \u201ctextbook\u201d has three possible position for the non-terminal X3 (as a left-child before \u201ca\u201d, as a left-child after \u201ca\u201d or as a right-child). The translation hypotheses are then combined during decoding. Choice of optional words and final non-terminal positions is also done during decoding.", "page": 2, "bbox": {"x1": 85.92, "x2": 512.16, "y1": 61.44, "y2": 346.08}}, {"filename": "../figure/image/1113-Table1-1.png", "caption": "Table 1: Official evaluation results for BLEU/RIBES/HUMAN. (NB: Human evaluation scores of WAT2014 and WAT2015 are not comparable.)", "page": 5, "bbox": {"x1": 127.67999999999999, "x2": 470.4, "y1": 62.879999999999995, "y2": 349.91999999999996}}, {"filename": "../figure/image/1113-Figure1-1.png", "caption": "Figure 1: The translation pipeline can be roughly divided in 3 steps. Step 1 is the creation of the example database, trained from a parallel corpus. Step 2 is the parsing of an input sentence and the generation of sets of initial hypotheses. Step 3 consists in decoding and reranking. The tuning of the weights for decoding and reranking is done by a modified version of step 3.", "page": 1, "bbox": {"x1": 73.92, "x2": 288.0, "y1": 61.44, "y2": 252.95999999999998}}]}